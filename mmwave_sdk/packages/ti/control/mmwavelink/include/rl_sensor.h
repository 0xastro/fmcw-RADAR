/****************************************************************************************
 * FileName     : rl_sensor.h
 *
 * Description  : This file defines the functions to configure RF/Sensor in mmwave radar device.
 *
 ****************************************************************************************
 * (C) Copyright 2014, Texas Instruments Incorporated. - TI web address www.ti.com
 *---------------------------------------------------------------------------------------
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *    Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 *  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  OWNER OR CONTRIBUTORS
 *  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 *  CONTRACT,  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *  POSSIBILITY OF SUCH DAMAGE.
 */

/****************************************************************************************
* FILE INCLUSION PROTECTION
****************************************************************************************
*/
#ifndef RL_SENSOR_H
#define RL_SENSOR_H

/******************************************************************************
 * INCLUDE FILES
 ******************************************************************************
 */

#ifdef __cplusplus
extern "C" {
#endif

/****************************************************************************************
 * MACRO DEFINITIONS
 ****************************************************************************************
 */

/* Count of Test Sources*/
#define RL_MAX_TST_SRC_OBJECTS        (2U)

/* Number of chunks in Calibration data generated by radarSS */
#define RL_MAX_CALIB_DATA_CHUNK       (3U)

/*! \brief
* Supported maximum number of RX channels
*/
#define RL_RX_CNT                     (4U)

/*! \brief
* Supported maximum number of TX channels
*/
#define RL_TX_CNT                     (3U)

/*! \brief
* Enable/Disable RX/TX Channels
*/
#define RL_CHANNEL_DISABLE            (0U)
#define RL_CHANNEL_ENABLE             (1U)

/*! \brief
* Start/Stop Frame Trigger constants
*/
#define RL_FRAME_TRIGGER_STOP         (0x0U)
#define RL_FRAME_TRIGGER_START        (0x1U)

/*! \brief
* Supported maximum number of subframes in a frame
*/
#define RL_MAX_SUBFRAMES              (4U)

/*! \brief
* Supported maximum number of chirp profiles
*/
#define RL_MAX_PROFILES_CNT          (4U)

/*! \brief
* Supported noise figure modes
*/
#define RL_RX_NOISE_FIGURE_LOW        (0U)
#define RL_RX_NOISE_FIGURE_HIGH       (1U)
#define RL_RX_NOISE_FIGURE_MAX        (2U)

/*! \brief
* Supported ADC data bitwidths
*/
#define RL_ADC_DATA_12_BIT            (0U)
#define RL_ADC_DATA_14_BIT            (1U)
#define RL_ADC_DATA_16_BIT            (2U)
#define RL_ADC_DATA_BIT_MAX           (3U)

/*! \brief
* Supported ADC modes of operation
*/
#define RL_ADC_FORMAT_REAL                      (0U)
#define RL_ADC_FORMAT_COMPLEX_1X                (1U)
#define RL_ADC_FORMAT_COMPLEX_2X                (2U)
#define RL_ADC_FORMAT_PSEUDO_REAL               (3U)
#define RL_ADC_FORMAT_MAX                       (4U)

/*! \brief
* Supported ADC modes of operation
*/
#define RL_ADC_MODE_REGULAR                     (0U)
#define RL_ADC_MODE_LOW_POWER                   (1U)
#define RL_ADC_MODE_MAX                         (2U)

/*! \brief
* Supported Rx baseband bandwidths
*/
#define RL_RX_BB_BW_AUTO                        (0x0U)
#define RL_RX_BB_BW_350_KHz                     (0x1U)
#define RL_RX_BB_BW_10_MHz                      (0x2U)
#define RL_RX_BB_BW_15_MHz                      (0x3U)
#define RL_RX_BB_BW_MAX                         (0x4U)

/*! \brief
* Supported HPF-1 corner frequencies
*/
#define RL_RX_HPF1_175_KHz                      (0U)
#define RL_RX_HPF1_235_KHz                      (1U)
#define RL_RX_HPF1_350_KHz                      (2U)
#define RL_RX_HPF1_700_KHz                      (3U)
#define RL_RX_HPF1_MAX                          (4U)

/*! \brief
* Supported HPF-2 corner frequencies
*/
#define RL_RX_HPF2_350_KHz                      (0U)
#define RL_RX_HPF2_700_KHz                      (1U)
#define RL_RX_HPF2_1p4_MHz                      (2U)
#define RL_RX_HPF2_2p8_MHz                      (3U)
#define RL_RX_HPF2_5p0_MHz                      (4U)
#define RL_RX_HPF2_7p5_MHz                      (5U)
#define RL_RX_HPF2_10_MHz                       (6U)
#define RL_RX_HPF2_15_MHz                       (7U)
#define RL_RX_HPF2_MAX                          (8U)

/*! \brief
* Supported Rx gains
*/
#define RL_RX_GAIN_30_dB                        (0x1EU)
#define RL_RX_GAIN_36_dB                        (0x24U)
#define RL_RX_GAIN_44_dB                        (0x2cU)
#define RL_RX_GAIN_50_dB                        (0x32U)

/*! \brief
* Supported frame sync modes
*/
#define RL_FRAME_SYNC_MODE_SINGLE_CHIP          (0x0U)
#define RL_FRAME_SYNC_MODE_MULT_CHIP_MASTER     (0x1U)
#define RL_FRAME_SYNC_MODE_MULT_CHIP_SLAVE      (0x2U)
#define RL_FRAME_SYNC_MODE_MAX                  (0x3U)


/*! \brief
* Supported frame start trigger modes
*/
#define RL_FRAMESTRT_API_TRIGGER                (0x1U)
#define RL_FRAMESTRT_SYNCIN_TRIGGER             (0x2U)

/*! \brief
* Supported Rx analog configurations
*/
#define RL_RXANA_COMPLEX                        (0U)
#define RL_RXANA_REAL                           (1U)
#define RL_RXANA_MODES_MAX                      (2U)

/*! \brief
* Supported Temperature Sensor Range in step of 10C
*/
#define RL_MAX_NUM_OF_TEMP10_RANGES             (19U)
/******************************************************************************
 * GLOBAL VARIABLES/DATA-TYPES DEFINITIONS
 ******************************************************************************
 */

/*! \brief
* Rx/Tx Channel Configuration
*/
typedef struct rlChanCfg
{
    /**
     * @ brief  RX Channel Bitmap \n
                b0 RX0 Channel Enable \n
                0   Disable RX Channel 0 \n
                1   Enable RX Channel 0 \n
                b1 RX1 Channel Enable \n
                0   Disable RX Channel 1 \n
                1   Enable RX Channel 1 \n
                b2 RX2 Channel Enable \n
                0   Disable RX Channel 2 \n
                1   Enable RX Channel 2 \n
                b3 RX3 Channel Enable \n
                0   Disable RX Channel 3 \n
                1   Enable RX Channel 3 \n
     */
    rlUInt16_t rxChannelEn;
    /**
     * @brief  TX Channel Bitmap \n
                b0 TX0 Channel Enable \n
                0   Disable TX Channel 0 \n
                1   Enable TX Channel 0\n
                b1 TX1 Channel Enable \n
                0   Disable TX Channel 1 \n
                1   Enable TX Channel 1 \n
                b2 TX2 Channel Enable \n
                0   Disable TX Channel 2 \n
                1   Enable TX Channel 2 \n
                @note : TX2 is supported only on some of the devices, Please refer device data \n
                        sheet. \n
     */
    rlUInt16_t txChannelEn;
    /**
     * @brief  Enable Cascading \n
                 0x0000 SINGLECHIP: Single mmWave sensor application\n
                 0x0001 MULTICHIP_MASTER: Multiple mmwave sensor application. This mmwave is \n
                 the master chip and generates LO and conveys to other mmwave sensor. \n
                 This is applicable only in AWR1243.\n
                 0x0002 MULTICHIP_SLAVE: Multiple mmwave sensor application. This mmwave is a \n
                 slave chip and uses LO conveyed to it by the master mmwave sensor. \n
                 This is applicable only in AWR1243 \n
                 @note : Please refer device data sheet for cascading capability and 20G SYNC
                         pins \n
     */
    rlUInt16_t cascading;
    /**
     * @brief  Cascading pinout config
     *         b0 - CLKOUT_MASTER_DIS
     *              0 - 20G FM_CW_CLKOUT from master is enabled
     *              1 - 20G FM_CW_CLKOUT from master is disabled
     *         b1 - SYNCOUT_MASTER_DIS
     *              0 - 20G FM_CW_SYNCOUT from master is enabled
     *              1 - 20G FM_CW_SYNCOUT from master is disabled
     *         b2 - CLKOUT_SLAVE_EN
     *              0 - 20G FM_CW_CLKOUT from slave is disabled
     *              1 - 20G FM_CW_CLKOUT from slave is enabled
     *         b3 - SYNCOUT_SLAVE_EN
     *              0 - 20G FM_CW_SYNCOUT from slave is disabled
     *              1 - 20G FM_CW_SYNCOUT from slave is enabled
     *         b4 - INTLO_MASTER_EN
     *              0 - Master uses looped back LO
     *              1 - Master uses internal LO
     *         b5 - OSCCLKOUT_MASTER_DIS
     *              0 - OSCCLKOUT from master is enabled
     *              1 - OSCCLKOUT from master is disabled
     *      b15:6 - RESERVED
     */
    rlUInt16_t cascadingPinoutCfg;
}rlChanCfg_t;

/*! \brief
* ADC Bit and ADC Output format Configuration
*/
#ifndef MMWL_BIG_ENDIAN
typedef struct rlAdcBitFormat
{
    /**
     * @brief  ADC out bits - 0(12 Bits), 1(14 Bits), 2(16 Bits)
     */
    rlUInt32_t b2AdcBits           :2;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t b6Reserved0        :6;
    /**
     * @brief Number of bits to reduce ADC full scale by
               Valid range: 0 to (16 - Number of ADC bits)
               For e.g. for 12 bit ADC output, this field can take values 0, 1, 2 or 3 \n
               For 14 bit ADC output, this field can take values 0, 1 or 2 \n
               For 16 bit ADC output, this field can take only value 0 \n
      */
    rlUInt32_t b8FullScaleReducFctr:8;
    /**
     * @brief  ADC out format- 0(Real), 1(Complex), 2(Complex with Image band), 3(Pseudo Real)
     */
    rlUInt32_t b2AdcOutFmt         :2;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t b14Reserved1        :14;
}rlAdcBitFormat_t;
#else
typedef struct rlAdcBitFormat
{
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t b14Reserved1        :14;
    /**
     * @brief  ADC out format- 0(Real), 1(Complex), 2(Complex with Image band), 3(Pseudo Real)
     */
    rlUInt32_t b2AdcOutFmt         :2;
    /**
     * @brief Number of bits to reduce ADC full scale by
               Valid range: 0 to (16 - Number of ADC bits)
               For e.g. for 12 bit ADC output, this field can take values 0, 1, 2 or 3 \n
               For 14 bit ADC output, this field can take values 0, 1 or 2 \n
               For 16 bit ADC output, this field can take only value 0 \n
      */
    rlUInt32_t b8FullScaleReducFctr:8;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t b6Reserved0        :6;
    /**
     * @brief  ADC out bits - 0(12 Bits), 1(14 Bits), 2(16 Bits)
     */
    rlUInt32_t b2AdcBits           :2;
}rlAdcBitFormat_t;
#endif

/*! \brief
* ADC format and payload justification Configuration
*/
typedef struct rlAdcOutCfg
{
    /**
     * @brief  ADC Data format
     */
    rlAdcBitFormat_t fmt;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
}rlAdcOutCfg_t;


/*! \brief
* Binary phase modulation mode configuration
*/
#ifndef MMWL_BIG_ENDIAN
typedef struct rlBpmModeCfg
{
    /**
     * @brief  BPM_SRC_SEL (select source of BPM pattern) \n
                   00 CHIRP_CONFIG_BPM (refer to rlBpmChirpCfg_t\n
                   01 RESERVED \n
                   10 RESERVED \n
                   11 RESERVED \n
     */
    rlUInt16_t b2SrcSel           :2;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t b1Reserved0        :1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t b13Reserved1       :13;
}rlBpmModeCfg_t;
#else
typedef struct rlBpmModeCfg
{
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t b13Reserved1       :13;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t b1Reserved0        :1;
    /**
     * @brief  BPM_SRC_SEL (select source of BPM pattern) \n
                   00 CHIRP_CONFIG_BPM (refer to rlBpmChirpCfg_t\n
                   01 RESERVED \n
                   10 RESERVED \n
                   11 RESERVED  \n
     */
    rlUInt16_t b2SrcSel           :2;
}rlBpmModeCfg_t;
#endif

/*! \brief
* Binary phase modulation KCounter configuration
*/
#ifndef MMWL_BIG_ENDIAN
typedef struct rlBpmKCounterSel
{
    /**
     * @brief  K Counter Start Select (Reserved for future)
     */
    rlUInt16_t b1BpmKStart        :1;
    /**
     * @brief  K Counter End Select (Reserved for future)
     */
    rlUInt16_t b1BpmKEnd          :1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t b14Reserved        :14;
}rlBpmKCounterSel_t;
#else
typedef struct rlBpmKCounterSel
{
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t b14Reserved        :14;
    /**
     * @brief  K Counter End Select (Reserved for future)
     */
    rlUInt16_t b1BpmKEnd          :1;
    /**
     * @brief  K Counter Start Select (Reserved for future)
     */
    rlUInt16_t b1BpmKStart        :1;
}rlBpmKCounterSel_t;
#endif

/*! \brief
* Binary phase modulation common configuration
*/
typedef struct rlBpmCommonCfg
{
    /**
     * @brief  BPM Mode configuration
     */
    rlBpmModeCfg_t mode;
    /**
     * @brief  Reserved for future, should set to zero.
     */
    rlUInt16_t reserved0;
    /**
     * @brief  Reserved for future, should set to zero.
     */
    rlUInt16_t reserved1;
    /**
     * @brief  Reserved for future, should set to zero.
     */
    rlUInt16_t reserved2;
    /**
     * @brief  Reserved for future, should set to zero.
     */
    rlUInt32_t reserved3;
    /**
     * @brief  Reserved for future, should set to zero.
     */
    rlUInt32_t reserved4;
}rlBpmCommonCfg_t;

/*! \brief
* Binary phase modulation common configuration
*/
typedef struct rlBpmChirpCfg
{
    /**
     * @brief  Chirp Start Index, Valid Range 0 -511
     */
    rlUInt16_t chirpStartIdx;
    /**
     * @brief  Chirp End Index, Valid Range from chirpStartIdx to 511
     */
    rlUInt16_t chirpEndIdx;
    /**
     * @brief  b0  CONST_BPM_VAL_TX0_TXOFF \n
                     Value of Binary Phase Shift value for TX0, when during idle time \n
                     b1  CONST_BPM_VAL_TX0_TXON \n
                     Value of Binary Phase Shift value for TX0, during chirp \n
                     b2  CONST_BPM_VAL_TX1_TXOFF \n
                     Value of Binary Phase Shift value for TX1, when during idle time \n
                     b3  CONST_BPM_VAL_TX1_TXON \n
                     Value of Binary Phase Shift value for TX1, during chirp \n
                     b4  CONST_BPM_VAL_TX2_TXOFF \n
                     Value of Binary Phase Shift value for TX2, when during idle time \n
                     b5  CONST_BPM_VAL_TX2_TXON \n
                     Value of Binary Phase Shift value for TX2, during chirp \n
                     b15:6 Reserved \n
     */
    rlUInt16_t constBpmVal;
    /**
     * @brief  Reserved for future
     */
    rlUInt16_t reserved;
}rlBpmChirpCfg_t;

/*! \brief
* Low Power mode configuration
*/
typedef struct rlLowPowerModeCfg
{
    /**
     * @brief  Reserved for future
     */
    rlUInt16_t reserved;
    /** ADC Mode \n
     * @brief  0x00 : Regular ADC mode \n
               0x01 : Low poer ADC mode \n
     */
    rlUInt16_t lpAdcMode;
}rlLowPowerModeCfg_t;

/*! \brief
* Profile config API parameters. A profile contains coarse parameters of FMCW chirp such as
* start frequency, chirp slope, ramp time, idle time etc. Fine dithering values need
* to be programmed in chirp configuration \ref rlChirpCfg_t
* \note Maximum of 4 profiles can be configured.
*/
typedef struct rlProfileCfg
{
    /**
     * @brief  Profile index (0-3)
     */
    rlUInt16_t profileId;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Bit Description  \n
                b0 FORCE_VCO_SEL \n
                 0 - Use internal VCO selection    \n
                 1 - Forced external VCO selection \n
                b1 VCO_SEL      \n
                 0 - VCO1 (77G:76 - 78 GHz or 60G:57 - 60.75 GHz)  \n
                 1 - VCO2 (77G:77 - 81 GHz or 60G:60.25 - 64 GHz)  \n
                 @note : There is an overlap region of 77-78 GHz and 60.25-60.75GHz in which \n
                 any of the VCOs can be used, for other regions use only the VCO which can work \n
                 in that region. For e.g. for 76-77 GHz use only VCO1 and for 78-81GHz use only \n
                 VCO2, for 77-78 GHz, any VCO can be used, similarly in 60G device \n
                 60.25-60.75GHz overlap region can be used by any VCO. Also note that users \n
                 should not inter-mix chirps from different VCOs within the same frame.\n
                b7:2 RESERVED            \n
     */
    rlUInt8_t pfVcoSelect;
    /**
     * @brief Bit Description       \n
               b0 RETAIN_TXCAL_LUT (Not supported in IWR6843 ES1.0) \n
                0 - Update TX calibration LUT           \n
                1 - Do not update TX calibration LUT    \n
               b1 RETAIN_RXCAL_LUT (Not supported in IWR6843 ES1.0) \n
                0 - Update RX calibration LUT and update RX IQMM correction \n
                1 - Do not update RX calibration LUT    \n
               b7:2 RESERVED                            \n
               If PF_TX_OUTPUT_POWER_BACKOFF is changed then set RETAIN_TXCAL_LUT to 0, \n
               else set it to 1 and if PF_RX_GAIN is changed, then set RETAIN_RXCAL_LUT to 0 \n
               else set them to 1.
     */
    rlUInt8_t pfCalLutUpdate;
#else
    /**
     * @brief Bit Description       \n
               b0 RETAIN_TXCAL_LUT (Not supported in IWR6843 ES1.0) \n
                0 - Update TX calibration LUT           \n
                1 - Do not update TX calibration LUT    \n
               b1 RETAIN_RXCAL_LUT (Not supported in IWR6843 ES1.0)  \n
                0 - Update RX calibration LUT           \n
                1 - Do not update TX calibration LUT    \n
               b7:2 RESERVED                            \n
               If PF_TX_OUTPUT_POWER_BACKOFF is changed then set RETAIN_TXCAL_LUT to 0, \n
               else set it to 1 and if PF_RX_GAIN is changed, then set RETAIN_RXCAL_LUT to 0 \n
               else set them to 1.
     */
    rlUInt8_t pfCalLutUpdate;
    /**
      * @brief  Bit Description  \n
               b0 FORCE_VCO_SEL \n
                0 - Use internal VCO selection    \n
                1 - Forced external VCO selection \n
               b1 VCO_SEL      \n
                0 - VCO1 (77G:76 - 78 GHz or 60G:57 - 60.75 GHz)  \n
                1 - VCO2 (77G:77 - 81 GHz or 60G:60.25 - 64 GHz)  \n
                @note : There is an overlap region of 77-78 GHz and 60.25-60.75GHz in which \n
                any of the VCOs can be used, for other regions use only the VCO which can work \n
                in that region. For e.g. for 76-77 GHz use only VCO1 and for 78-81GHz use only \n
                VCO2, for 77-78 GHz, any VCO can be used, similarly in 60G device \n
                60.25-60.75GHz overlap region can be used by any VCO. Also note that users \n
                should not inter-mix chirps from different VCOs within the same frame.\n
               b7:2 RESERVED            \n
     */
    rlUInt8_t pfVcoSelect;
#endif
    /**
     * @brief  Start frequency for each profile \n
                  For 77GHz devices (76 GHz - 81 GHz): \n
                      1 LSB = 3.6e9 / 2^26 Hz = 53.644 Hz  \n
                      Valid range: 0x5471C71B to 0x5A000000 \n
                  For 60GHz devices (57 GHz - 64 GHz): \n
                      1 LSB = 2.7e9 / 2^26 Hz = 40.233 Hz  \n
                      Valid range: 0x5471C71C to 0x5ED097B4 \n
     */
    rlUInt32_t startFreqConst;
    /**
     * @brief  Idle time\n
                  1 LSB = 10 ns \n
                  Valid range: 0 to 524287 \n
     */
    rlUInt32_t idleTimeConst;
    /**
     * @brief  Time of starting of ADC capture relative to the knee of the ramp\n
                  1 LSB = 10 ns \n
                  Valid range: 0 to 4095 \n
     */
    rlUInt32_t adcStartTimeConst;
    /**
     * @brief  End of ramp time relative to the knee of the ramp\n
                   1 LSB = 10 ns\n
                   Valid range: 0 to 500000 \n
                   Ensure that the total frequency sweep is either within these ranges: \n
                   77G : 76 - 78 GHz or 77 - 81 GHz \n
                   60G : 57 - 60.75 GHz or 60.25 - 64 GHz \n
     */
    rlUInt32_t rampEndTime;
    /**
     * @brief  Concatenated code for output power backoff for TX0, TX1, TX2\n
                   Bit    Description  \n
                   b7:0   TX0 output power back off \n
                   b15:8  TX1 output power back off \n
                   b23:16 TX2 output power back off \n
                   b31:24 Reserved \n
               This field defiens how much the transmit power should be reduced from the maximum \n
               1 LSB = 1 dB \n
               If TX power boot time calibration is disabled then only 0dB back off is \n
               supported. In IWR6843 ES1.0, only 0dB backoff is supported. \n
               @note : For best inter-TX channel matching performance, same chirp profile and \n
                       same TX backoff value should be used for all the TXs that are used in \n
                       beam-forming
     */
    rlUInt32_t txOutPowerBackoffCode;
    /**
     * @brief  Concatenated phase shift for TX0/1/2,\n
                   Bit    Description \n
                   b7:0   TX0 phase shift value \n
                   b15:8  TX1 phase shift value \n
                   b23:16 TX2 phase shift value \n
                   1 LSB = 360/2^6 = 5.625 degrees \n
                   b31:24 Reserved \n
               This field defines the phase shift to be introduced on each transmitter output. \n
               In IWR6843 ES1.0, only 0 degree phase is supported. \n
     */
    rlUInt32_t txPhaseShifter;
    /**
     * @brief  Ramp slope frequency, \n
                   For 77GHz devices (76GHz to 81GHz): \n
                       1 LSB = (3.6e6 * 900) / 2^26 = 48.279 kHz/uS \n
                       Valid range: -2072 to 2072 (Max 100MHz/uS) \n
                   For 60GHz devices (57GHz to 64GHz): \n
                       1 LSB = (2.7e6 * 900) / 2^26 = 36.21 kHz/uS for 60GHz devices \n
                       Valid range: -6905 to 6905 (Max 250 MHz/uS) \n
     */
    rlInt16_t freqSlopeConst;
    /**
     * @brief  Time of start of transmitter relative to the knee of the ramp \n
                   1 LSB = 10ns \n
                   Valid range: -4096 to 4095 \n
     */
    rlInt16_t txStartTime;
    /**
     * @brief  Number of ADC samples to capture in a chirp for  each RX \n
                   Valid range: 2 to MAX_NUM_SAMPLES\n
                   Where MAX_NUM_SAMPLES is such that all the enabled RX channels' data fits \n
                   into 16 kB memory memory in AWR1243/xWR1443 or 32 kB memory in xWR1642/ \n
                   xWR6843/xWR1843, with each sample consuming 2 bytes for real ADC output \n
                   case and 4 bytes for complex 1x and complex 2x ADC output cases \n
                   number of RX chains    ADC format    Maxinum Number of samples \n
                    4                      complex       1024 \n
                    4                      Real          2048 \n
                    2                      Complex       2048 \n
                    2                      Real          4096 \n
     */
    rlUInt16_t numAdcSamples;
    /**
     * @brief  ADC Sampling rate for each profile is encoded in \n
                   2 bytes (16 bit unsigned number)\n
                   1 LSB = 1 ksps \n
                   Valid range 2000 to 37500 \n
     */
    rlUInt16_t digOutSampleRate;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Code for HPF1 corner frequency\n
                   0x00 175 kHz \n
                   0x01 235 kHz \n
                   0x02 350 kHz \n
                   0x03 700 kHz \n
     */
    rlUInt8_t  hpfCornerFreq1;
    /**
     * @brief  Code for HPF2 corner frequency\n
                   0x00 350 kHz \n
                   0x01 700 kHz \n
                   0x02 1.4 MHz \n
                   0x03 2.8 MHz \n
     */
    rlUInt8_t  hpfCornerFreq2;
#else
    /**
     * @brief  Code for HPF2 corner frequency\n
                   0x00 350 kHz \n
                   0x01 700 kHz \n
                   0x02 1.4 MHz \n
                   0x03 2.8 MHz \n
     */
    rlUInt8_t  hpfCornerFreq2;
    /**
     * @brief  Code for HPF1 corner frequency\n
                   0x00 175 kHz \n
                   0x01 235 kHz \n
                   0x02 350 kHz \n
                   0x03 700 kHz \n
     */
    rlUInt8_t  hpfCornerFreq1;
#endif
    /**
     * @brief  Number of transmitters to turn on during TX power  \n
               calibration. During actual operation, if more than \n
               1 TXs are enabled during the chirp, then enabling  \n
               the same TXs during calibration will have better TX \n
               output power accuracy \n
                    b2:0 TX enabled during TX0 calibration \n
                         b0 - TX0, b1 - TX1, b2 - TX2 \n
                    b5:3 TX enabled during TX1 calibration \n
                         b3 - TX0, b4 - TX1, b5 - TX2 \n
                    b8:6 TX enabled during TX2 calibration \n
                         b6 - TX0, b7 - TX1, b8 - TX2 \n
                    b14:9 RESERVED \n
                    b15  Enable multi TX enable during TX power calibration. \n
                         Note : If this bit is not set, only 1 TX is enabled \n
                         during the TX power calibration. For e.g. during TX0 \n
                         calibration, only TX0 will be enabled; during TX1 \n
                         calibration, only TX1 will be enabled and so on. \n
               NOTE: This field is not applcicable for IWR6843 ES 1.0
     */
    rlUInt16_t txCalibEnCfg;
    /**
     * @brief
                b5:0  Code for Rx VGA gain\n
                      1 LSB = 1 dB\n
                      Valid values: all even values from 24 to 52 \n
                b7:6  Code for RF gain target (Not applicable for IWR6843 ES1.0, \n
                      RF gain is fixed to 34dB) \n
                      00 - 30 dB \n
                      01 - 34 dB \n
                      10 - RESERVED \n
                      11 - 26 dB \n
                b15:8 RESERVED \n
                In IWR6843 ES1.0 device, Rx Gain is not accurate and not calibrated. \n
                The RF gain is 34dB and total Rx gain can be varied from 28dB to 56dB \n
     */
    rlUInt16_t  rxGain;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
} rlProfileCfg_t;

/*! \brief
* Chirp config API parameters. This structure contains fine dithering to coarse profile
* defined in \ref rlProfileCfg_t. It also includes the selection of Transmitter and
* binary phase modulation for a chirp.\n
* \note One can define upto 512 unique chirps.These chirps need to be included in
*       frame configuration structure \ref rlFrameCfg_t to create FMCW frame
*/
typedef struct rlChirpCfg
{
    /**
     * @brief  Chirp start index (0-511)
     */
    rlUInt16_t chirpStartIdx;
    /**
     * @brief  Chirp end index (0-511)
     */
    rlUInt16_t chirpEndIdx;
    /**
     * @brief  Associated profile id (0-3)
     */
    rlUInt16_t profileId;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
    /**
     * @brief  Ramp start frequency, \n
               For 77GHz devices(76GHz to 81GHz): \n
                   1 LSB = 3.6e9/2^26 = 53.644 Hz \n
                   valid range = 0-8388607 \n
               For 60GHz devices(57GHz to 64GHz): \n
                   1 LSB = 2.7e9/2^26 = 40.233 Hz \n
                   valid range = 0-8388607 \n
     */
    rlUInt32_t startFreqVar;
    /**
     * @brief  Ramp slope\n
               For 77GHz devices(76GHz to 81GHz): \n
                   1 LSB = 3.6e6 * 900/2^26 = 48.279 KHz/us \n
                   valid range = 0-63 \n
               For 60GHz devices(57GHz to 64GHz): \n
                   1 LSB = 2.7e6 * 900/2^26 = 36.21 KHz/us \n
                   valid range = 0-63 \n
     */
    rlUInt16_t freqSlopeVar;
    /**
     * @brief  Idle time for each chirp\n
                   1 LSB = 10ns\n
                   valid range = 0-4096 \n
     */
    rlUInt16_t idleTimeVar;
    /**
     * @brief  Adc start time for each chirp \n
                   1 LSB = 10ns \n
                   valid range = 0-4096 \n
     */
    rlUInt16_t adcStartTimeVar;
    /**
     * @brief  Tx enable selection bit mask \n
                   b0 Enable TX0 \n
                   0 Tx0 Disable \n
                   1 Tx0 Enable \n
                   b1 Enable TX1 \n
                   0 Tx1 Disable \n
                   1 Tx1 Enable \n
                   b2 Enable TX2 \n
                   0 Tx2 Disable \n
                   1 Tx2 Enable  \n
                   Note: Maximum of only 2 TX can be turned in a chirp \n
     */
    rlUInt16_t txEnable;
}rlChirpCfg_t;

/*! \brief
* Chirp start, end Index parameters for rlGetChirpConfig
*/
typedef struct rlWordParam
{
    rlUInt16_t halfWordOne;
    rlUInt16_t halfWordTwo;
}rlWordParam_t;

/*! \brief
* Frame config API parameters
*/
typedef struct rlFrameCfg
{
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved0;
    /**
     * @brief  Start Index of Chirp Valid range = 0-511
     */
    rlUInt16_t chirpStartIdx;
    /**
     * @brief  End Index of Chirp Valid range = chirpStartIdx-511
     */
    rlUInt16_t chirpEndIdx;
    /**
     * @brief  Number of times to repeat from chirpStartIdx to chirpStartIdx in each frame, \n
                   valid range = 1 to 255 \n
     */
    rlUInt16_t numLoops;
    /**
     * @brief  Number of frame to transmit \n
                Valid Range 0 to 65535 (0 for infinite frames) \n
     */
    rlUInt16_t numFrames;
    /**
     * @brief  Number of ADC samples to capture This parameter is required only for AWR1243 and \n
                configures the size of ADC samples per chirp to be sent on LVDS/CSI2 \n
                interface.\n
                It should be configured as:
                For real/pseudo real ADC data - numADCSamples = rlProfileCfg_t.numAdcSamples \n
                For complex1x/complex2x ADC data -  \n
                numADCSamples = (rlProfileCfg_t.numAdcSamples ) * 2 \n
     */
    rlUInt16_t numAdcSamples;
    /**
     * @brief  Frame repitition period \n
                   1 LSB = 5 ns\n
                   Typical range 1 ms to 1000 ms \n
     */
    rlUInt32_t framePeriodicity;
    /**
     * @brief  Selects the mode for triggering start of transmission of frame \n
                   0x0001 SWTRIGGER (Software API based triggering): \n
                   Frame is triggered upon receiving rlSensorStart\n
                   There could be several tens of micro seconds uncertainty in triggering. \n
                   Note: This mode is not applicable if this mmwave device is configured as \n
                   MULTICHIP_SLAVE in rlChanCfg_t \n
                   0x0002 HWTRIGGER (Hardware SYNC_IN based triggering): \n
                   Each frame is triggered by rising edge of pulse in SYNC_IN pin, after
                   receiving rlSensorStart (this is to prevent spurious transmission).
                   W.r.t. the SYNC_IN pulse, the actual transmission has 5ns uncertainty in \n
                   SINGLECHIP and only a 300 ps uncertainty (due to tight inter-chip
                   synchronization needed) in MULTICHIP sensor applications as defined in
                   rlChanCfg_t. \n
     */
    rlUInt16_t triggerSelect;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
    /**
     * @brief  Optional time delay from sync_in trigger to the occurance of frame chirps \n
                Applicable only in SINGLECHIP sensor applications, as defined in rlChanCfg_t.\n
                It is recommended only for staggering the transmission of multiple mmwave \n
                sensors around the car for interference avoidance, if needed.\n
                1 lsb = 5 ns \n
                Typical range is 0 to few tens of micro seconds. \n
     */
    rlUInt32_t frameTriggerDelay;
}rlFrameCfg_t;

/*! \brief
 * Advance Frame config API Subframe configuration
 */
typedef struct rlSubFrameCfg
{
    /**
     * @brief  Force profile index. This is applicable only if FORCE_SINGLE_PROFILE is set to 1
     */
    rlUInt16_t forceProfileIdx;
    /**
     * @brief  Start Index of Chirp Valid range = 0-511
     */
    rlUInt16_t chirpStartIdx;
    /**
     * @brief  Num of unique Chirps per burst including start index Valid range = 1 - 512
     */
    rlUInt16_t numOfChirps;
    /**
     * @brief  No. of times to loop through the unique chirps in each burst, without gaps, \n
                   using HW.\n valid range = 1 to 255 \n
     */
    rlUInt16_t numLoops;
    /**
     * @brief  burstPeriodicity >= (numLoops)* (numOfChirps) + InterBurstBlankTime, \n
                where InterBurstBlankTime is primarily for sensor calibration / monitoring, \n
                thermal control, and some minimum time needed for triggering \n
                next burst (~10us).\n
                NOTE: Across bursts, if the value numOfChirps, is not a constant, then the \n
                actual available blank time can vary and needs to be accounted for\n
                1 LSB = 5 ns \n
     */
    rlUInt32_t burstPeriodicity;
    /**
     * @brief  Chirp Start address increament for next burst, \n
                   next_burst_chirp_start_idx = last_chirp_end_index + \n
                   h_ChirpStartIdxIncr 0 - 511, 0 = 2nd burst = 1st burst \n
     */
    rlUInt16_t chirpStartIdxOffset;
    /**
     * @brief  Num of bursts in the subframe. Valid Range: 1 - 512
     */
    rlUInt16_t numOfBurst;
    /**
     * @brief  Number of times to loop over the set of above defined bursts, in the sub frame.\n
                    Valid Range: 1 - 64 \n
     */
    rlUInt16_t numOfBurstLoops;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved0;
    /**
     * @brief  subFramePeriodicity >= Sum total time of all bursts + InterSubFrameBlankTime, \n
                 Where, Sum total time of all bursts = numOfBurstLoops * numOfBurst * \n
                 burstPeriodicity. \n
                 InterSubFrameBlankTime is primarily for sensor calibration / monitoring, \n
                 thermal control, transferring out any safety monitoring data if requested, \n
                 hardware reconfiguration for next sub frame, retriggering of next SF (~10us).\n
                 The hardware reconfiguration time, which is needed to transfer out the SF's \n
                 InterSubFrameBlankTime >= 100 us. \n
                 With loopback enabled InterSubFrameBlankTime >= 350 us. \n
                 Add 150 us to InterSubFrameBlankTime for test source confguration if test \n
                 source is enabled. \n
                 1 LSB = 5 ns \n
                 Valid range 100 us to 1.342 s. \n
     */
    rlUInt32_t subFramePeriodicity;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved2;
}rlSubFrameCfg_t;

/*! \brief
 * Advance Frame Sequence config API parameters rlAdvFrameCfg, 148 bytes
 */
typedef struct rlAdvFrameSeqCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Number of sub frames enabled in this frame Valid range: 1 to 4
     */
    rlUInt8_t          numOfSubFrames;
    /**
     * @brief  Force profile. \n
                0x0 The profile index set in rlSetChirpConfig API governs which profile is \n
                used when that chirp is transmitted \n
                0x1 The profile index indicated in rlSetChirpConfig API is ignored and all \n
                the chirps in each sub frame use a single profile as indicated by that sub \n
                frame's profile forceProfileIdx. \n
     */
    rlUInt8_t          forceProfile;
    /**
     * @brief Bit  Definition \n
              b0   LOOPBACK_CFG_EN \n
                    0 - Disable \n
                    1 - Enable  \n
              b2:1  SUB_FRAME_ID for which the loopback configuration applies \n
              b7:3  RESERVED \n
     */
    rlUInt8_t          loopBackCfg;
    /**
     * @brief  Sub frame trigger
     *              0 - Disabled
     *              1 - Enabled (Need to trigger each sub-frame either by SW in \n
     *                  software triggered mode or HW SYNC_IN line in hardware triggered mode)
     */
    rlUInt8_t          subFrameTrigger;
#else
    /**
     * @brief  Force profile.
                0x0 The profile index set in rlSetChirpConfig API governs which profile is \n
                used when that chirp is transmitted \n
                0x1 The profile index indicated in rlSetChirpConfig API is ignored and all \n
                the chirps in each sub frame use a single profile as indicated by that sub \n
                frame's profile forceProfileIdx. \n
     */
    rlUInt8_t          forceProfile;
    /**
     * @brief  Number of sub frames enabled in this frame Valid range: 1 to 4
     */
    rlUInt8_t          numOfSubFrames;
    /**
     * @brief  Sub frame trigger
     *              0 - Disabled
     *              1 - Enabled (Need to trigger each sub-frame either by SW in \n
     *                  software triggered mode or HW SYNC_IN line in hardware triggered mode)
     */
    rlUInt8_t          subFrameTrigger;
    /**
     * @brief Bit  Definition \n
              b0   LOOPBACK_CFG_EN \n
                    0 - Disable \n
                    1 - Enable  \n
              b2:1  SUB_FRAME_ID for which the loopback configuration applies \n
              b7:3  RESERVED \n
     */
    rlUInt8_t          loopBackCfg;
#endif
    /**
     * @brief  Subframe config for 4 sub frames
     */
    rlSubFrameCfg_t    subFrameCfg[RL_MAX_SUBFRAMES];
    /**
     * @brief  Number of frames to transmit (1 frame = all enabled sub frames). If set to 0, \n
                frames are transmitted endlessly till Frame Stop message is received.\n
                Valid range: 0 to 65535 \n
     */
    rlUInt16_t         numFrames;
    /**
     * @brief  Selects the mode for triggering start of transmission of frame \n
                 0x0001 SWTRIGGER (Software API based triggering): \n
                   Frame is triggered upon receiving rlSensorStart There could be several tens \n
                   of micro seconds uncertainty in triggering. \n
                   Note:This mode is not applicable if this mmwave device is configured as \n
                   MULTICHIP_SLAVE in rlChanCfg_t \n
                 0x0002 HWTRIGGER (Hardware SYNC_IN based triggering): \n
                   Each frame is triggered by rising edge of pulse in SYNC_IN pin, after \n
                   receiving rlSensorStart (this is to \n prevent spurious transmission). \n
                   W.r.t. the SYNC_IN pulse, the actual transmission has 5ns uncertainty in \n
                   SINGLECHIP and only a 300 ps uncertainty (due to tight inter-chip \n
                   synchronization needed) in MULTICHIP sensor applications as defined in \n
                   rlChanCfg_t. \n
     */
    rlUInt16_t         triggerSelect;
    /**
     * @brief  Optional time delay from sync_in trigger to the occurance of frame chirps \n
                Applicable only in SINGLECHIP sensor applications, as defined in rlChanCfg_t.\n
                It is recommended only for staggering the transmission of multiple mmwave \n
                sensors around the car for interference avoidance, if needed. \n
                1 lsb = 5 ns \n
                Typical range is 0 to few tens of micro seconds. \n
     */
    rlUInt32_t         frameTrigDelay;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t         reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t         reserved1;
}rlAdvFrameSeqCfg_t;


/*! \brief
* Frame config API parameters
*/
typedef struct rlFrameApplyCfg
{
    /**
     * @brief  Number of Chirps per Frame
     */
    rlUInt32_t numChirps;
    /**
     * @brief  Number of half words in ADC buffer per chirp \n
                Example 1:  In real mode, if number of ADC samples per chirp is 256 then this \n
                value will be 256 \n
                Example 2: In complex1x or complex2x modes,if number of ADC samples per chirp \n
                is 256 then this value will be 512 \n
     */
    rlUInt16_t numAdcSamples;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
}rlFrameApplyCfg_t;

/*! \brief
* Sub Frame data config API parameters
*/
typedef struct rlSubFrameDataCfg
{
    /**
     * @brief  Number of Chirps in Sub-Frame = numOfChirps * numLoops * numOfBurst * burstLoop
     */
    rlUInt32_t totalChirps;
    /**
     * @brief  Number of half words of ADC samples per data packet in sub frame 1 \n
                Example 1:  In real mode, if number of ADC samples per chirp in subframe1 is
                256 then this value will be 256 \n
                Example 2: In complex1x or complex2x modes, if number of ADC samples per
                chirp in subframe1 is 256 then this value will be 512 \n
                In AWR1243: Program this as number of ADC samples in each chirp of
                this sub frame (required to be the same)\n
                Exception: Can do number of chirps based ping-pong as in xWR1642 
                (see below), if CP/CQ are not needed. Useful for chirp stitching use case.\n
                In xWR1642: The ADC samples corresponding to one or more chirps can be
                grouped and sent to the DSP as a single packet. Program this as the number
                of half words of ADC samples per packet. Ensure that in one sub frame, there
                is integer number of such packets. \n
                Maximum size of a data packet: (16384 - 1) half words
     */
    rlUInt16_t numAdcSamples;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Number of Chirps Per Data Packet to process at a time in sub frame 1. \n
                In AWR1243/xWR1443: Program this as 1. \n
                Exception: Can be > 1 as in 16xx if CP/CQ is not needed. Useful for chirp
                stitching use case.\n
                In xWR1642/xWR1843: The ADC samples corresponding to one or more chirps can be
                grouped and sent to the DSP as a single packet. Program this as the
                corresponding number of chirps per packet. \n
                Maximum value = 8. \n
                Note on maximum size: 8 chirps for CP and BPM.
     */
    rlUInt8_t numChirpsInDataPacket;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
    /**
     * @brief  Number of Chirps Per Data Packet to process at a time in sub frame 1. \n
                In AWR1243/xWR1443: Program this as 1. \n
                Exception: Can be > 1 as in 16xx if CP/CQ is not needed. Useful for chirp
                stitching use case.\n
                In xWR1642/xWR1843: The ADC samples corresponding to one or more chirps can be
                grouped and sent to the DSP as a single packet. Program this as the
                corresponding number of chirps per packet. \n
                Maximum value = 8. \n
                Note on maximum size: 8 chirps for CP and BPM. \n
     */
    rlUInt8_t numChirpsInDataPacket;
#endif
}rlSubFrameDataCfg_t;

/*! \brief
* Advance Frame data config API parameters.
* This strcutre is only applicable when mmWaveLink instance is running on
* External Host and connected to AWR1243 device.
*/
typedef struct rlAdvFrameDataCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Number of Sub Frames, Valid Range (1 - 4)
     */
    rlUInt8_t numSubFrames;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved0;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved0;
    /**
     * @brief  Number of Sub Frames, Valid Range (1 - 4)
     */
    rlUInt8_t numSubFrames;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
    /**
     * @brief  Sub Frame data configuration array.
     */
    rlSubFrameDataCfg_t subframeDataCfg[RL_MAX_SUBFRAMES];
}rlAdvFrameDataCfg_t;

/*! \brief
 * Advance Frame Sequence config API parameters rlAdvFrameCfg, 148 bytes
 */
typedef struct rlAdvFrameCfg
{
    /**
     * @brief  Advance Frame sequence and Subframe configuration
     */
    rlAdvFrameSeqCfg_t frameSeq;
    /**
     * @brief  Advance Frame data configuration. Applicable with AWR1243 device only
     */
    rlAdvFrameDataCfg_t frameData;
}rlAdvFrameCfg_t;

/*! \brief
* Continous Mode config API parameters
*/
typedef struct rlContModeCfg
{
    /**
     * @brief  Start frequency \n
               For 77GHz devices (76 - 81 GHz): \n
                  1 LSB = 3.6e9 / 2^26 Hz = 53.644 Hz \n
                  Valid range: 0x5471C71B to 0x5A000000 \n
               For 60GHz devices (57 - 64 GHz): \n
                  1 LSB = 2.7e9 / 2^26 Hz = 40.233 Hz \n
                  Valid range: 0x5471C71C to 0x5ED097B4 \n
     */
    rlUInt32_t startFreqConst;
    /**
     * @brief  Concatenated code for output power backoff for TX0, TX1, TX2 \n
                b7:0 TX0 output power back off \n
                b15:8 TX1 output power back off \n
                b23:16 TX2 output power back off \n
                b31:24 Reserved \n
                This field defines how much the transmit power should be reduced from the \n
                maximum. \n
                1 LSB = 1 dB
                In IWR6843 ES1.0, only 0dB backoff is supported. \n
     */
    rlUInt32_t txOutPowerBackoffCode;
    /**
     * @brief  Concatenated phase shift for TX0/1/2, \n
                b7:0 TX0 phase shift value \n
                b15:8 TX1 phase shift value \n
                b23:16 TX2 phase shift value \n
                1 LSB = 360/2^6 = 5.625 degrees \n
                b31:24 Reserved \n
                This field defines the additional phase shift to be introduced on each \n
                transmitter output. \n
                In IWR6843 ES1.0, only 0 degree phase is supported. \n
     */
    rlUInt32_t txPhaseShifter;
    /**
     * @brief  ADC Sampling rate for each profile is encoded in \n
                2 bytes (16 bit unsigned number) \n
                1 LSB = 1 ksps \n
                Valid range 2000 to 37500 \n
     */
    rlUInt16_t digOutSampleRate;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Code for HPF1 corner frequency \n
                0x00 175 kHz \n
                0x01 235 kHz \n
                0x02 350 kHz \n
                0x03 700 kHz \n
     */
    rlUInt8_t  hpfCornerFreq1;
    /**
     * @brief  Code for HPF2 corner frequency \n
                0x00 350 kHz \n
                0x01 700 kHz \n
                0x02 1.4 MHz \n
                0x03 2.8 MHz \n
     */
    rlUInt8_t  hpfCornerFreq2;
    /**
     * @brief  This field defines RX gain for continuous streaming mode.
                Bit Definition
                [5:0] RX_GAIN
                    This field defines RX gain for each profile. 1 LSB = 1 dB
                    Valid values: all even values from 24 to 52
                [7:6] RF_GAIN_TARGET (Not applicable for IWR6843 ES1.0, In IWR6843 ES1.0 \n
                    RF gain is fixed to 36 dB) \n
                    Value   RF gain target
                    00      30 dB
                    01      34 dB
                    10      RESERVED
                    11      26 dB
     */
    rlUInt8_t  rxGain;
    /**
     * @brief Bit   Description
                b0  FORCE_VCO_SEL
                    0 - Use internal VCO selection
                    1 - Forced external VCO selection
                b1  VCO_SEL
                    0 - VCO1 (77G:76 - 78 GHz or 60G:57 - 60.75 GHz)
                    1 - VCO2 (77G:77 - 81 GHz or 60G:60.25 - 64 GHz)
                b7:2    RESERVED
     */
    rlUInt8_t vcoSelect;
#else
    /**
     * @brief  Code for HPF2 corner frequency \n
                0x00 350 kHz \n
                0x01 700 kHz \n
                0x02 1.4 MHz \n
                0x03 2.8 MHz \n
     */
    rlUInt8_t  hpfCornerFreq2;
    /**
     * @brief  Code for HPF1 corner frequency \n
                0x00 175 kHz \n
                0x01 235 kHz \n
                0x02 350 kHz \n
                0x03 700 kHz \n
     */
    rlUInt8_t  hpfCornerFreq1;
    /**
     * @brief Bit   Description
                b0  FORCE_VCO_SEL
                    0 - Use internal VCO selection
                    1 - Forced external VCO selection
                b1  VCO_SEL
                    0 - VCO1 (77G:76 - 78 GHz or 60G:57 - 60.75 GHz)
                    1 - VCO2 (77G:77 - 81 GHz or 60G:60.25 - 64 GHz)
                b7:2    RESERVED
     */
    rlUInt8_t vcoSelect;
    /**
    * @brief  This field defines RX gain for continuous streaming mode.
               Bit Definition
               [5:0] RX_GAIN
                  This field defines RX gain for each profile. 1 LSB = 1 dB
                  Valid values: all even values from 24 to 52
               [7:6] RF_GAIN_TARGET (Not applicable for IWR6843 ES1.0, In IWR6843 ES1.0 \n
                  RF gain is fixed to 36 dB) \n
                  Value   RF gain target
                  00      30 dB
                  01      34 dB
                  10      RESERVED
                  11      26 dB
    */
    rlUInt8_t  rxGain;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
}rlContModeCfg_t;

/*! \brief
* Continous Mode Enable API parameters
*/
typedef struct rlContModeEn
{
    /**
     * @brief  Enable continuous steaming mode \n
                0x00 Disable continuous streaming mode \n
                0x01 Enable continuous streaming mode \n
     */
    rlUInt16_t contModeEn;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
}rlContModeEn_t;

/*! \brief
* Frame Trigger API parameters RL_RF_FRAMESTARTSTOP_CONF_SB
*/
typedef struct rlFrameTrigger
{
     /**
      * @brief  Start/Stop Frame \n
                 0x0000 - Stop the transmission of frames after the current frame is over \n
                 0x0001 - Trigger a frame in software triggered mode. In hardware SYNC_IN \n
                          triggered mode, this command allows subsequent SYNC_IN trigger to \n
                          be honored \n
     */
    rlUInt16_t startStop;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
}rlFrameTrigger_t;


/*! \brief
* The Object position and signal strength parameter structure
*/
typedef struct rlTestSourceObject
{
    /**
     * @brief  Relative position in Cartesian coordinate from sensor to objects \n
                X position of object 1lsb = 1cm, -32768cm to 32767cm \n
     */
    rlInt16_t posX;
    /**
     * @brief  Relative position in Cartesian coordinate from sensor to objects \n
                Y position of object 1lsb = 1cm, 0 -32767 cm \n
     */
    rlInt16_t posY;
    /**
     * @brief  Relative position in Cartesian coordinate from sensor to objects \n
                Z position of object 1lsb = 1cm, -32768cm to 32767cm \n
     */
    rlInt16_t posZ;
    /**
     * @brief  Relative velocity in Cartesian coordinate \n
                X velocity of object 1lsb = 1 cm/s, Valid Range -5000 to +5000 \n
     */
    rlInt16_t velX;
    /**
     * @brief  Relative velocity in Cartesian coordinate \n
                Y velocity of object 1lsb = 1cm/s, Valid Range -5000 to +5000 \n
     */
    rlInt16_t velY;
    /**
     * @brief  Relative velocity in Cartesian coordinate \n
                Z velocity of object 1lsb = 1cm/s, Valid Range -5000 to +5000 \n
     */
    rlInt16_t velZ;
    /**
     * @brief  Reflecting obj' sig level at ADC o/p, relative to ADC Full Scale \n
                1 LSB = -0.1 dBFS, Valid Range 0 to 950 \n
     */
    rlUInt16_t sigLvl;
    /**
     * @brief  Boundary min limit, Obj location resets to posX if cross boundary \n
                X position of min boundary 1lsb = 1cm, -32768cm to 32767cm \n
     */
    rlInt16_t posXMin;
    /**
     * @brief  Boundary min limit, Obj location resets to posY if cross boundary \n
                Y position of min boundary 1lsb = 1cm, 0 to 32767cm \n
     */
    rlInt16_t posYMin;
    /**
     * @brief  Boundary min limit, Obj location resets to posZ if cross boundary \n
                Z position of min boundary 1lsb = 1cm, -32768cm to 32767cm \n
     */
    rlInt16_t posZMin;
    /**
     * @brief  Boundary max limit, Obj location resets to posX if cross boundary \n
                X position of max boundary 1lsb = 1cm, -32768cm to 32767cm \n
     */
    rlInt16_t posXMax;
    /**
     * @brief  Boundary max limit, Obj location resets to posX if cross boundary \n
                Y position of max boundary 1lsb = 1cm, 0 to 32767cm \n
     */
    rlInt16_t posYMax;
    /**
     * @brief  Boundary max limit, Obj location resets to posX if cross boundary \n
                Z position of max boundary 1lsb = 1cm, -32768cm to 32767cm \n
     */
    rlInt16_t posZMax;
}rlTestSourceObject_t;

/*! \brief
* The Antenna position parameter structure
*/
typedef struct rlTestSourceAntPos
{
    /**
     * @brief  Antenna position X 1lsb=wavelength/8 Valid range = +/-15 wave lengths
     */
    rlInt8_t  antPosX;
    /**
     * @brief  Antenna position Z 1lsb=wavelength/8 Valid range = +/-15 wave lengths
     */
    rlInt8_t  antPosZ;
}rlTestSourceAntPos_t;

/*! \brief
* Test source config API parameters E_API_AR_TEST_SOURCE_CONF_SB
*/
typedef struct rlTestSource
{
    /**
     * @brief  Arary of test Objects
     */
    rlTestSourceObject_t   testObj[RL_MAX_TST_SRC_OBJECTS];
    /**
     * @brief  Simulated Position of Rx Antennas
     */
    rlTestSourceAntPos_t   rxAntPos[RL_RX_CNT];
    /**
     * @brief  Simulated Position of Tx Antennas
     */
    rlTestSourceAntPos_t   txAntPos[RL_TX_CNT];
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t             reserved;
}rlTestSource_t;

/*! \brief
* Test source Enable API parameters RL_RF_TEST_SOURCE_ENABLE_SB
*/
typedef struct rlTestSourceEn
{
    /**
     * @brief  Test source Enable - 1, Disable - 0
     */
    rlUInt16_t  tsEnable;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t  reserved;
}rlTestSourceEnable_t;

/*! \brief
* The DFE Statistics for Rx Channel for particular profile
*/
typedef struct rlDfeRxdStatReport
{
    /**
     * @brief  Average DC value in I chain for profile x, RX channel x
     */
    rlInt16_t   iAvgDC;
    /**
     * @brief  Average DC value in Q chain for profile x, RX channel x
     */
    rlInt16_t   qAvgDC;
    /**
     * @brief  Average power in I chain for profile x, RX channel x
     */
    rlUInt16_t  iAvgPwr;
    /**
     * @brief  Average power in Q chain for profile x, RX channel x
     */
    rlUInt16_t  qAvgPwr;
    /**
     * @brief  Average cross correlation between I and Q chains for profile x, RX channel x
     */
    rlInt32_t   iqAvgCroCorrel;
} rlDfeRxStatReport_t;

/*! \brief
* The DFE Statistics Report Contents
*/
typedef struct rlDfeStatReport
{
    /**
     * @brief Contain DFE statistic report for all profile and receiver
     */
    rlDfeRxStatReport_t dfeStatRepo[RL_MAX_PROFILES_CNT][RL_RX_CNT];
}rlDfeStatReport_t;

/*! \brief
* Dynamic power saving API parameters
*/
typedef struct rlDynPwrSave
{
    /**
     * @brief  Enable dynamic power saving during inter-chirp IDLE times by \n
     *          turning off various circuits e.g. TX, RX, LO. 3 LSB is vaild \n
     *          b0 Enable power save by switching off TX  during inter-chirp IDLE period \n
     *             0    Disable \n
     *             1    Enable \n
     *          b1 Enable power save by switching off RX  during inter-chirp IDLE period \n
     *             0    Disable \n
     *             1    Enable \n
     *          b2 Enable power save by switching off LO distribution  during inter-chirp IDLE\n
     *          period \n
     *             0    Disable \n
     *             1    Enable \n
     */
    rlUInt16_t blkCfg;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
} rlDynPwrSave_t;

/*! \brief
* API RF device Config SBC M_API_AR_RF_DEV_CONF_SBC
*/
typedef struct rlRfDevCfg
{
    /**
     * @brief Bit Definition \n
     *        b1:0 Global Async event direction \n
     *             00 - radarSS to MSS   01 - radarSS to HOST\n
     *             10 - radarSS to DSS   11 - RESERVED   \n
     *             The ASYNC_EVENT_DIR controls the direction for following ASYNC_EVENTS \n
     *             [1.] CPU_FAULT [2.] ESM_FAULT [3.] ANALOG_FAULT \n
     *             All other ASYNC_EVENTs are sent to the subsystem which issues the API \n
     *        b3:2 Monitoring Async Event direction
     *             00 - radarSS to MSS   01 - radarSS to HOST\n
     *             10 - radarSS to DSS   11 - RESERVED   \n
     *        b31:4 Reserved
     */
    rlUInt32_t aeDirection;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief Bit Definition \n
     *       b0: FRAME_START_ASYNC_EVENT_DIS        \n
     *           0 Frame Start async event enable   \n
     *           1 Frame Start async event disable  \n
     *       b1: FRAME_STOP_ASYNC_EVENT_DIS         \n
     *           0 Frame Stop async event enable    \n
     *           1 Frame Stop async event disable   \n
     *       b7:2 Reserved
     */
    rlUInt8_t       aeControl;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t       reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t       reserved1;
    /**
     * @brief Bit Definition \n
     *       b0: Watchdog enable/disable        \n
     *           0 Keep watchdog disabled   \n
     *           1 Enable watch dog  \n
     *       b7:1: Reserved \n
     */
    rlUInt8_t       bssDigCtrl;
    /**
     * @brief CRC Config for Asynchornous event message \n
     *          Value  Description \n
     *           0     16 bit CRC for radarSS async events \n
     *           1     32 bit CRC for radarSS async events \n
     *           2     64 bit CRC for radarSS async events \n
     *
     */
    rlUInt8_t aeCrcConfig;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t       reserved2;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t       reserved0;
    /**
     * @brief Bit Definition \n
     *       b0: FRAME_START_ASYNC_EVENT_DIS        \n
     *           0 Frame Start async event enable   \n
     *           1 Frame Start async event disable  \n
     *       b1: FRAME_STOP_ASYNC_EVENT_DIS         \n
     *           0 Frame Stop async event enable    \n
     *           1 Frame Stop async event disable
     */
     rlUInt8_t       aeControl;
    /**
     * @brief Bit Definition \n
     *       b0: Watchdog enable/disable        \n
     *           0 Keep watchdog disabled   \n
     *           1 Enable watch dog  \n
     *       b7:1: Reserved \n
     */
    rlUInt8_t       bssDigCtrl;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t       reserved1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t       reserved2;
    /**
     * @brief CRC Config for Asynchornous event message \n
     *          Value  Description \n
     *           0     16 bit CRC for radarSS async events \n
     *           1     32 bit CRC for radarSS async events \n
     *           2     64 bit CRC for radarSS async events \n
     *
     */
    rlUInt8_t aeCrcConfig;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t       reserved3;
} rlRfDevCfg_t;

/*! \brief
*  Num of samples to collect for API GPADC sensors
*  sampleCnt    : Number of samples to collect @625KHz
*/
typedef struct rlGpAdcSamples
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Number of samples to collect
     */
    rlUInt8_t sampleCnt;
    /**
     * @brief  Number of samples to skip before collecting the data
     *         1 LSB = 0.8 us, Valid range: 0 to 12 us
     */
    rlUInt8_t settlingTime;
#else
    /**
     * @brief  Number of samples to skip before collecting the data
     *         1 LSB = 0.8 us, Valid range: 0 to 12 us
     */
    rlUInt8_t settlingTime;
    /**
     * @brief  Number of samples to collect
     */
    rlUInt8_t sampleCnt;
#endif
}rlGpAdcSamples_t;

/*! \brief
* API radarSS GPADC API MEAS SET SBC M_API_AR_RF_GPADC_API_SET_SB
*/
typedef struct rlGpAdcCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Enable different sensors \n
                [b0] 1: ANATEST1 Enable,  0: ANATEST1 Disable \n
                [b1] 1: ANATEST2 Enable,  0: ANATEST2 Disable \n
                [b2] 1: ANATEST3 Enable,  0: ANATEST3 Disable \n
                [b3] 1: ANATEST4 Enable,  0: ANATEST4 Disable \n
                [b4] 1: ANAMUX   Enable,  0: ANAMUX   Disable \n
                [b5] 1: VSENSE   Enable,  0: VSENSE   Disable \n
                [b7:6]   Reserved \n
     */
    rlUInt8_t        enable;
    /**
     * @brief  Enable buffer for each input \n
                [b0] 1: ANATEST1 buffer enable,  0: ANATEST1 buffer disable \n
                [b1] 1: ANATEST2 buffer enable,  0: ANATEST2 buffer disable \n
                [b2] 1: ANATEST3 buffer enable,  0: ANATEST3 buffer disable \n
                [b3] 1: ANATEST4 buffer enable,  0: ANATEST4 buffer disable \n
                [b4] 1: ANAMUX   buffer enable,  0: ANAMUX   buffer disable \n
                [b7:5]   Reserved \n
    */
    rlUInt8_t        bufferEnable;
#else
    /**
     * @brief  Enable buffer for each input \n
                [b0] 1: ANATEST1 buffer enable,  0: ANATEST1 buffer disable \n
                [b1] 1: ANATEST2 buffer enable,  0: ANATEST2 buffer disable \n
                [b2] 1: ANATEST3 buffer enable,  0: ANATEST3 buffer disable \n
                [b3] 1: ANATEST4 buffer enable,  0: ANATEST4 buffer disable \n
                [b4] 1: ANAMUX   buffer enable,  0: ANAMUX   buffer disable \n
                [b7:5]   Reserved \n
    */
    rlUInt8_t        bufferEnable;
    /**
     * @brief  Enable different sensors \n
                [b0] 1: ANATEST1 Enable,  0: ANATEST1 Disable \n
                [b1] 1: ANATEST2 Enable,  0: ANATEST2 Disable \n
                [b2] 1: ANATEST3 Enable,  0: ANATEST3 Disable \n
                [b3] 1: ANATEST4 Enable,  0: ANATEST4 Disable \n
                [b4] 1: ANAMUX   Enable,  0: ANAMUX   Disable \n
                [b5] 1: VSENSE   Enable,  0: VSENSE   Disable \n
                [b7:6]   Reserved \n
     */
    rlUInt8_t        enable;
#endif
    /**
     * @brief  Configure number of sample to be \n
                collected for each sensor This array of numOfSamples is for the sensors \n
                which are enabled in above parameter 'enable' \n
     */
    rlGpAdcSamples_t  numOfSamples[RL_MAX_GPADC_SENSORS];
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t        reserved;
} rlGpAdcCfg_t;

/*! \brief
* Radar RF LDO bypass enable/disable configuration
*/
typedef struct rlRfLdoBypassCfg
{
    /**
     * @brief  Enable LDO bypass \n
                [b0] 1: RF LDO bypassed, Should be used only when 1.0V RF supply is provided
                     0: RF LDO not bypassed(default), Should be used only when 1.3V RF supply
                     is provided \n
                [b1] 0: PA LDO input is enabled\n
                     1: PA LDO input is disabled (3 TX use case).
                        (To be used only when VIN_RF2 is shorted to VOUT_PA on board and VIN_RF2 is
                         1.0V) \n
                [b15:2] Reserved \n
                usecase                                            LDO bypass    PA LDO disable \n
                1.3V RF supply 1 and 1.3V RF supply 2                 0               0
                1.0V RF supply 1 and 1.0V RF supply 2                 1               0
                1.0V RF supply 1 and 1.0V RF supply 2                 1               1
                     and RF supply 1 shorted to Vout PA               
                
     */
    rlUInt16_t ldoBypassEnable;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  IR drop is the voltage drop from the PMIC output to the device pin. The user
               should program the voltage drop in percentage units which will be used for
               measuring the external supplies.  \n
                Value  Description   \n
                0      IR drop of 0% \n
                1      IR drop of 3% \n
                2      IR drop of 6% \n
                3      IR drop of 9% \n
     */
    rlUInt8_t supplyMonIrDrop;
    /**
     * @brief  IO supply indicator. This is used to indicate the IO supply to the MMIC device
     *         for setting the correct voltage monitor thresholds
     *         Value   Description \n
     *          0      3.3 V IO supply \n
     *          1      1.8 V IO supply \n
     */
    rlUInt8_t ioSupplyIndicator;
#else
    /**
     * @brief  IO supply indicator. This is used to indicate the IO supply to the MMIC device
     *         for setting the correct voltage monitor thresholds
     *         Value   Description \n
     *          0      3.3 V IO supply \n
     *          1      1.8 V IO supply \n
     */
    rlUInt8_t ioSupplyIndicator;
    /**
     * @brief  IR drop is the voltage drop from the PMIC output to the device pin. The user
               should program the voltage drop in percentage units which will be used for
               measuring the external supplies.  \n
                Value  Description   \n
                0      IR drop of 0% \n
                1      IR drop of 3% \n
                2      IR drop of 6% \n
                3      IR drop of 9% \n
     */
    rlUInt8_t supplyMonIrDrop;
#endif
}rlRfLdoBypassCfg_t;


/*! \brief
* Radar RF Phase Shift enable/disable configuration
*/
typedef struct rlRfPhaseShiftCfg
{
    /**
     * @brief  Chirp Start Index, Valid Range 0 -511
     */
    rlUInt16_t chirpStartIdx;
    /**
     * @brief  Chirp End Index, Valid Range from chirpStartIdx to 511
     */
    rlUInt16_t chirpEndIdx;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  TX0 phase shift definition \n
                [b1:0] reserved (set it to 0b00) \n
                [b7:2] TX0 phase shift value \n
                1 LSB = 360/2^6 = 5.625 degrees\n
                Valid range: 0 to 63 \n
     */
    rlUInt8_t tx0PhaseShift;
    /**
     * @brief  TX1 phase shift definition \n
                [b1:0] reserved (set it to 0b00) \n
                [b7:2] TX1 phase shift value \n
                1 LSB = 360/2^6 = 5.625 degrees\n
                Valid range: 0 to 63 \n
     */
    rlUInt8_t tx1PhaseShift;
    /**
     * @brief  TX2 phase shift definition \n
                [b1:0] reserved (set it to 0b00) \n
                [b7:2] TX2 phase shift value \n
                1 LSB = 360/2^6 = 5.625 degrees\n
                Valid range: 0 to 63 \n
     */
    rlUInt8_t tx2PhaseShift;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
#else
    /**
     * @brief  TX1 phase shift definition \n
                [b1:0] reserved (set it to 0b00) \n
                [b7:2] TX1 phase shift value \n
                1 LSB = 360/2^6 = 5.625 degrees\n
                Valid range: 0 to 63 \n
     */
    rlUInt8_t tx1PhaseShift;
    /**
     * @brief   TX0 phase shift definition \n
                 [b1:0] reserved (set it to 0b00) \n
                 [b7:2] TX0 phase shift value \n
                 1 LSB = 360/2^6 = 5.625 degrees\n
                 Valid range: 0 to 63 \n
     */
    rlUInt8_t tx0PhaseShift;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
    /**
     * @brief  TX2 phase shift definition \n
                [b1:0] reserved (set it to 0b00) \n
                [b7:2] TX2 phase shift value \n
                1 LSB = 360/2^6 = 5.625 degrees\n
                Valid range: 0 to 63 \n
     */
    rlUInt8_t tx2PhaseShift;
#endif
}rlRfPhaseShiftCfg_t;

/*! \brief
* Radar RF PA loopback configuration
*/
typedef struct rlRfPALoopbackCfg
{
    /**
     * @brief  value is a 100MHz divider which sets the loopback frequency \n
                For e.g. for a 1 MHz frequency, set this to 10 \n
                For a 2 MHz frequency, set this to 50 \n
                Note: To ensure no leakage of signal power, user has to ensure that\n
                100MHz/LOOPBACK_FREQ is an integer multiple of bin width For e.g. if user \n
                choses 25Msps sampling rate and 2048 samples/chirp, then \n
                LOOPBACK_FREQ of 64 (=1.5625MHz) will ensure no leakage \n
     */
    rlUInt16_t paLoopbackFreq;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Enable/Disable PA loopback \n
                1: PA loopback Enable,  0: PA loopback Disable \n
     */
    rlUInt8_t  paLoopbackEn;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;

    /**
     * @brief  Enable/Disable PA loopback \n
                1: PA loopback Enable,  0: PA loopback Disable \n
     */
    rlUInt8_t  paLoopbackEn;
#endif
}rlRfPALoopbackCfg_t;

/*! \brief
* Radar RF Phase shift loopback configuration
*/
typedef struct rlRfPSLoopbackCfg
{
    /**
     * @brief  Loop back frequency in kHz, 1 LSB = 1kHz
     */
    rlUInt16_t psLoopbackFreq;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved0;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Enable/Disable PA loopback \n
                   1: PS loopback Enable,  0: PS loopback Disable \n
     */
    rlUInt8_t  psLoopbackEn;
    /**
     * @brief  Tx used for loopback \n
     *          [b0] 1: Tx0 is used for loopback \n
     *          [b1] 1: Tx1 is used for loopback \n
     *          [b7:2] : reserved \n
     */
    rlUInt8_t psLoopbackTxId;
    /**
     * @brief  PGA gain value \n
     *           0 : PGA is OFF  \n
     *           1 : -22 dB      \n
     *           2 : -16 dB      \n
     *           3 : -15 dB      \n
     *           4 : -14 dB      \n
     *           5 : -13 dB       \n
     *           6 : -12 dB       \n
     *           7 : -11 dB       \n
     *           8 : -10 dB       \n
     *           9 : -9 dB       \n
     *           10: -8 dB       \n
     *           11: -7 dB       \n
     *           12: -6 dB       \n
     *           13: -5 dB       \n
     *           14: -4 dB       \n
     *           15: -3 dB       \n
     *           16: -2 dB       \n
     *           17: -1 dB       \n
     *           18:  0 dB       \n
     *           19:  1 dB       \n
     *           20:  2 dB       \n
     *           21:  3 dB       \n
     *           22:  4 dB       \n
     *           23:  5 dB       \n
     *           24:  6 dB       \n
     *           25:  7 dB       \n
     *           26:  8 dB       \n
     *           27:  9 dB       \n
     *           255-28:RESERVED \n
     */
    rlUInt8_t pgaGainIndex;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved1;
#else
    /**
     * @brief  Tx used for loopback \n
                [b0] 1: Tx0 is used for loopback \n
                [b1] 1: Tx1 is used for loopback \n
                [b7:2] : reserved \n
     */
    rlUInt8_t psLoopbackTxId;
    /**
     * @brief  Enable/Disable PA loopback \n
                   1: PS loopback Enable,  0: PS loopback Disable \n
     */
    rlUInt8_t  psLoopbackEn;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved1;
    /**
     * @brief  PGA gain value \n
     *           0 : PGA is OFF  \n
     *           1 : -22 dB      \n
     *           2 : -16 dB      \n
     *           3 : -15 dB      \n
     *           4 : -14 dB      \n
     *           5 : -13 dB       \n
     *           6 : -12 dB       \n
     *           7 : -11 dB       \n
     *           8 : -10 dB       \n
     *           9 : -9 dB       \n
     *           10: -8 dB       \n
     *           11: -7 dB       \n
     *           12: -6 dB       \n
     *           13: -5 dB       \n
     *           14: -4 dB       \n
     *           15: -3 dB       \n
     *           16: -2 dB       \n
     *           17: -1 dB       \n
     *           18:  0 dB       \n
     *           19:  1 dB       \n
     *           20:  2 dB       \n
     *           21:  3 dB       \n
     *           22:  4 dB       \n
     *           23:  5 dB       \n
     *           24:  6 dB       \n
     *           25:  7 dB       \n
     *           26:  8 dB       \n
     *           27:  9 dB       \n
     *           255-28:RESERVED \n
     */
    rlUInt8_t pgaGainIndex;
#endif
}rlRfPSLoopbackCfg_t;

/*! \brief
* Radar RF IF loopback configuration.
*/
typedef struct rlRfIFLoopbackCfg
{
    /**
     * @brief  IF loopback frequency value \n
     *           0: 180 kHz    \n
     *           1 : 240 kHz   \n
     *           2 : 360 kiHz  \n
     *           3 : 720 kHz   \n
     *           4 : 1 MHz     \n
     *           5 : 2 MHz     \n
     *           6 : 2.5 MHz   \n
     *           7 : 3 MHz     \n
     *           8 : 4.017857 MHz \n
     *           9 : 5 MHz     \n
     *           10 : 6 MHz     \n
     *           11: 8.035714 MHz  \n
     *           12: 9 MHz     \n
     *           13: 10 MHz    \n
     *           65535-14:RESERVED \n
     */
    rlUInt16_t ifLoopbackFreq;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Enable/Disable IF loopback \n
     *          [b7:0] 1: IF loopback Enable,  0: IF loopback Disable \n
     */
    rlUInt8_t ifLoopbackEn;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t reserved;
    /**
     * @brief  Enable/Disable IF loopback \n
                [b7:0] 1: IF loopback Enable,  0: IF loopback Disable \n
     */
    rlUInt8_t ifLoopbackEn;
#endif
}rlRfIFLoopbackCfg_t;

/*! \brief
* Array of coefficients for the RF programmable filter
*/
typedef struct rlRfProgFiltCoeff
{
    /**
     * @brief  The array of coefficients for the programmable filter, across all profiles, to
                be stored in the coefficient RAM. Each tap is a 16-bit signed number. The
                exact set of taps to be used for a given profile can be specified through
                rlRfProgFiltConf. \n
                For each profile Maximum of 26 taps can be configured. If multiple profiles
                are used, all the filter taps across profiles are to be provided in one shot. \n
                There is a HW constraint that each profile's filter taps should start at
                an even address. \n

                For e.g If b[i,j] is filter coefficient For Profile i(0,1,2,3) and tap j(0...25),
                if numProfile = 4 and below is configured in rlRfProgFiltConf \n
                rlRfProgFiltConf[profileId = 0]. progFiltLen = 26 \n
                rlRfProgFiltConf[profileId = 1]. progFiltLen = 26, \n
                rlRfProgFiltConf[profileId = 2]. progFiltLen = 26, \n
                rlRfProgFiltConf[profileId = 3]. progFiltLen = 26, \n

                rlRfProgFiltConf[profileId = 0]. coeffStartIdx = 0 \n
                rlRfProgFiltConf[profileId = 1]. coeffStartIdx = 26 \n
                rlRfProgFiltConf[profileId = 2]. coeffStartIdx = 52 \n
                rlRfProgFiltConf[profileId = 3]. coeffStartIdx = 78 \n
                one need to define this array as following:\n
                coeffArray[0:103] = b[0,0], b[0,1]....b[0,25],b[1,0],b[1,1]....
                b[1,25],b[2,0],b[2,1]....b[2,25],b[3,0],b[3,1]....b[3,25]\n

                if numProfile = 1 and below is configured in rlRfProgFiltConf \n
                rlRfProgFiltConf[profileId = 0]. coeffStartIdx = 0 \n
                rlRfProgFiltConf[profileId = 0]. progFiltLen = 10, \n
                then one need to define this array as following: \n
                coeffArray[0:103] = b[0,0], b[0,1]....b[0,9],0,0,0,.....0 \n

                if numProfile = 2 and below is configured in rlRfProgFiltConf \n
                rlRfProgFiltConf[profileId = 0]. progFiltLen = 10, \n
                rlRfProgFiltConf[profileId = 1]. progFiltLen = 20, \n
                rlRfProgFiltConf[profileId = 1]. coeffStartIdx = 10 \n
                then one need to define this array as following: \n
                coeffArray[0:103] = b[0,0], b[0,1]....b[0,9], b[1,0],b[1,1]....b[1,29],0,0,0...0 \n
                @note : All the filter taps across profiles are to be provided in one shot. \n
                        There is a HW constraint that each profiles filter taps should start \n
                        at four 32-bit word aligned address (i.e., the coefficients corresp- \n
                        onding to any profile should start at array index which is a multiple \n
                        of 8). \n
     */
    rlInt16_t coeffArray[104];
}rlRfProgFiltCoeff_t;

/*! \brief
* Radar RF programmable filter configuration
*/
typedef struct rlRfProgFiltConf
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Profile Index for which this configuration applies.
     */
    rlUInt8_t profileId;
    /**
     * @brief  The index of the first coefficient of the programmable filter taps corresponding
                to this profile in the coefficient RAM programmed using rlRfProgFiltCoeff
                @note 1: This has to be an even number. For odd-length filters, a 0 (zero) tap
                         needs to be appended at the end to make the length even. This is a HW
                         constraint.
                @note 2: The profiles filter tap start index shall be 8 tap aligned (four 32-bit
                         word aligned address).
     */
    rlUInt8_t coeffStartIdx;
    /**
     * @brief  The length (number of taps) of the filter corresponding  to this profile. Together
               with the previous field, this determines the set of coefficients picked up from the
               coefficient RAM to form the filter taps for this profile.
               @note :  This has to be an even number. For odd-length filters, a 0 (zero) tap
                        needs to be appended at the end to make the length even. This is a HW
                        constraint.
     */
    rlUInt8_t progFiltLen;
    /**
     * @brief  Determines the magnitude of the frequency shift do be done before filtering using
               the real-coefficient programmable filter.
               1 LSB = 0.01*Fs shift, where Fs is the output sampling rate,
               specified as rlProfileCfg_t.digOutSampleRate
               Note: Applicable only on the Complex 1x output mode
     */
    rlUInt8_t progFiltFreqShift;
#else
    /**
     * @brief  The index of the first coefficient of the programmable filter taps corresponding
                to this profile in the coefficient RAM programmed using rlRfProgFiltCoeff
                @note 1: This has to be an even number. For odd-length filters, a 0 (zero) tap
                         needs to be appended at the end to make the length even. This is a HW
                         constraint.
                @note 2: The profiles filter tap start index shall be 8 tap aligned (four 32-bit
                         word aligned address).
     */
    rlUInt8_t coeffStartIdx;
    /**
     * @brief  Profile Index for which this configuration applies.
     */
    rlUInt8_t profileId;
    /**
     * @brief  Determines the magnitude of the frequency shift do be done before filtering using
               the real-coefficient programmable filter.
               1 LSB = 0.01*Fs shift, where Fs is the output sampling rate,
               specified as rlProfileCfg_t.digOutSampleRate
               Note: Applicable only on the Complex 1x output mode
     */
    rlUInt8_t progFiltFreqShift;
    /**
     * @brief  The length (number of taps) of the filter corresponding  to this profile. Together
               with the previous field, this determines the set of coefficients picked up from the
               coefficient RAM to form the filter taps for this profile.
               @note :  This has to be an even number. For odd-length filters, a 0 (zero) tap
                        needs to be appended at the end to make the length even. This is a HW
                        constraint.
     */
    rlUInt8_t progFiltLen;
#endif
}rlRfProgFiltConf_t;

/*! \brief
* Radar RF Miscconfiguration
*/
typedef struct rlRfMiscConf
{
    /**
     * @brief  b0 PERCHIRP_PHASESHIFTER_EN \n
     *          0 Per chirp phase shifter is disabled \n
     *          1 Per chirp phase shifter is enabled \n
     *          This control is applicable only in devices which support phase shifter. \n
     *          For other devices, this is a RESERVED bit and should be set to 0.
     */
    rlUInt32_t miscCtl;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved;
}rlRfMiscConf_t;

/*! \brief
* Radar RF Calibration monitoring time unit configuration
*/
typedef struct rlRfCalMonTimeUntConf
{
    /**
     * @brief  Defines the basic time unit, in terms of which calibration and/or monitoring \n
                periodicities are to be defined. \n
                If any monitoring functions are desired and enabled, the monitoring infrastructure
                automatically inherits this time unit as the period over which the various monitors
                are cyclically executed; so this should be set to the desired FTTI.\n
                For calibrations, a separate rlRunTimeCalibConf.calibPeriodicity can be specified,
                as a multiple of this time unit, in rlRfRunTimeCalibConfig. \n
                1 LSB = Duration of one frame. \n
        @note   Even though calibrations many not be desired every time unit, every time unit shall
                be made long enough to include active chirping time, time required for all enabled
                calibrations and monitoring functions.
     */
    rlUInt16_t calibMonTimeUnit;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Applicable only only in cascaded mode, default value = 1
     */
    rlUInt8_t  numOfCascadeDev;
    /**
     * @brief  Applicable only only in cascaded mode, default value = 0
     */
    rlUInt8_t  devId;
#else
    /**
     * @brief  Applicable only only in cascaded mode, default value = 0
     */
    rlUInt8_t  devId;
    /**
     * @brief  Applicable only only in cascaded mode, default value = 1
     */
    rlUInt8_t  numOfCascadeDev;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved;
}rlRfCalMonTimeUntConf_t;

/*! \brief
* Radar RF Calibration monitoring Frequency Limit configuration
*/
typedef struct rlRfCalMonFreqLimitConf
{
    /**
     * @brief  The sensor's lower frequency limit for calibrations and monitoring is encoded \n
     *          in 2 bytes (16 bit unsigned number) \n
     *          1 LSB = 100 MHz \n
     *          For 77GHz devices(76GHz to 81GHz) \n
     *              Valid range: 760 to 810
     *              Default value : 760 (If API is not issued)
     *          For 60GHz devices(57GHz to 64GHz) \n
     *              Valid range: 570 to 640
     *              Default value : 570 (If API is not issued)
     */
    rlUInt16_t freqLimitLow;
    /**
     * @brief  The sensor's higher frequency limit for calibrations and monitoring is encoded \n
     *          in 2 bytes (16 bit unsigned number) \n
     *          1 LSB = 100 MHz \n
     *          For 77GHz devices(76GHz to 81GHz) \n
     *              Valid range: 760 to 810
     *              Default value : 810 (If API is not issued)
     *          For 60GHz devices(57GHz to 64GHz) \n
     *              Valid range: 570 to 640
     *              Default value : 640 (If API is not issued)
     *          NOTE: FREQ_LIMIT_HIGH should be strictly greater than FREQ_LIMIT_LOW \n
     */
    rlUInt16_t freqLimitHigh;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved1;
}rlRfCalMonFreqLimitConf_t;

/*! \brief
* Radar RF Init Calibration configuration
*/
typedef struct rlRfInitCalConf
{
    /**
     * @brief  Allowed values = 0x000 or 0xFFF Normally, upon receiving RF INIT message, the \n
     *         radarSS performs all relevant initial calibrations. This step can be disabled \n
     *         by the host by setting this field to 0x00. If disabled, the host needs to send \n
     *         the INJECT CALIB DATA message so that the radarSS can operate using the \n
     *         calibration data thus injected. Each of these calibrations can be selectively \n
     *         disabled by issuing this message before RF INIT message. \n
     *
     *         Bit Calibration \n
     *         0   [Reserved] \n
     *         1   [Reserved] \n
     *         2   [Reserved] \n
     *         3   [Reserved] \n
     *         4   Enable LODIST calibration \n
     *         5   Enable RX ADC DC offset calibration \n
     *         6   Enable HPF cutoff calibration \n
     *         7   Enable LPF cutoff calibration \n
     *         8   Enable Peak detector calibration \n
     *         9   Enable TX Power calibration \n
     *         10  Enable RX gain calibration \n
     *         11  Enable TX phase calibration (Device dependent feature, please refer data
     *             sheet) \n
     *         12  Enable RX IQMM calibration \n
     *         31:13   [Reserved] \n
     *         Note1: If TX power calibration is disabled, then backoff other than 0 dB \n 
     *                is not supported \n
     *         Note2: In IWR6843 ES 1.0, only internal calibrations (APLL & SYNTH) and LODIST \n
     *                calibrations are supported. \n
     */
    rlUInt32_t calibEnMask;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved1;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved2;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved3;
}rlRfInitCalConf_t;

/*! \brief
* Radar RF Run time calibration configuration
*/
typedef struct rlRunTimeCalibConf
{
    /**
     * @brief   Upon receiving this trigger message, one time calibration of various RF/analog \n
     *          aspects are triggered if the corresponding bits in this field are set to 1. The \n
     *          response is in the form of an asynchronous event sent to the host. The \n
     *          calibrations, if enabled, are performed after the completion of any ongoing \n
     *          calibration cycle, and the calibration results take event from the frame that \n
     *          begins after the asynchronous event response is sent from the BSS. \n
     *          APLL and SYNTH calibrations are done always internally irrespective of bits are \n
     *          enabled or not, the time required for these calibrations must be allocated. \n
     *          Bit: Calibration \n
     *            0:[Reserved]  \n
     *            1:[Reserved]  \n
     *            2:[Reserved]  \n
     *            3:[Reserved]  \n
     *            4: Enable LODIST calibration  \n
     *            5: [Reserved]  \n
     *            6: [Reserved]  \n
     *            7: [Reserved]  \n
     *            8: Enable PD_CALIBRATION_EN \n
     *            9: Enable TX Power calibration \n
     *            10:Enable RX gain calibration  \n
     *            11:[Reserved]  \n
     *            12:[Reserved]  \n
     *            31:13:[Reserved] \n
     *          NOTE: In IWR6843 ES 1.0, only internal calibrations (APLL & SYNTH) and LODIST \n
     *                 calibrations are supported. \n
     */
    rlUInt32_t oneTimeCalibEnMask;
    /**
     * @brief  Automatic periodic triggering of calibrations of various RF/analog aspects. \n
               It has same bit definition as above \n
     */
    rlUInt32_t periodicCalibEnMask;
    /**
     * @brief  This field is applicable only for those calibrations which are enabled to be \n
     *         done periodically in the periodicCalibEnMask field. This field indicates the \n
     *         desired periodicity of calibrations. If this field is set to N, the results of \n
     *         the first calibration (based on oneTimeCalibEnMask) are applicable for the first \n
     *         N calibMonTimeUnits. The results of the next calibration are applicable for \n
     *         the next N calibMonTimeUnits, and so on.
     *         Recommendation: Set calibPeriodicity such that frequency of calibrations is \n
     *         greater than or equal to 1 second. 1 LSB = 1 calibMonTimeUnit, as specified \n
     *         in rlRfSetCalMonTimeUnitConfig. If the user does not wish to receive \n
     *         calibration reports when periodic calibrations are not enabled, then the user \n
     *         should set calibPeriodicity to 0.
     *         Default value: 0
     */
    rlUInt32_t calibPeriodicity;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Calibration Report Enable Configuration \n
                [b0]  Enable Calibration Reports Bitmap \n
                       0 -  Disable Calibration Reports \n
                       1 -  Enable Calibration Reports \n
                [b7:1] Reserved \n
                NOTE1: If calibration reports are enabled, the reports will be sent every 1 \n
                       second whenever internal    calibrations (APLL and SYNTH) are triggered \n
                       and at every CALIBRATION PERIODICITY when the user enabled calibrations \n
                       are triggered. \n
                NOTE2: If user has not enabled any one time    calibrations, but if calibration \n
                       report is enabled, then after issuing this API, the firmware will attempt \n
                       to run the APLL and SYNTH calibrations and the calibration report will \n
                       be immediately sent out. \n
     */
    rlUInt8_t  reportEn;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
    * @brief  TX Power Calibration Mode
              [b0]  Enable Calibration Reports Bitmap (Not valid for IWR6843 ES1.0) \n
                    0 - Update TX gain setting from LUT and do a closed loop calibration \n
                        (OLPC + CLPC) \n
                    1 - Update TX gain settings from LUT only (OLPC only) \n
                        OLPC: Open Loop Power Control. In this mode the TX stage codes are set \n
                        based on a coarse measurement and a LUT generated for every temperature \n
                        and the stage codes are picked from the LUT CLPC: Closed Loop Power \n
                        Control. In this mode the TX stage codes are picked from the coarse LUT \n
                        as generated in OLPC step. Later the TX power is measured and the TX \n
                        stage codes are corrected to achieve the desired TX power accuracy. \n
                        Default value: 0 \n
              [b7:1] Reserved \n
    */
    rlUInt8_t txPowerCalMode;
    /**
    * @brief  Reserved for Future use
    */
    rlUInt8_t reserved1;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  Calibration Report Enable Configuration \n
                   [b0]  Enable Calibration Reports Bitmap \n
                         0 - Disable Calibration Reports \n
                         1 - Enable Calibration Reports \n
                   [b7:1] Reserved \n
     */
    rlUInt8_t  reportEn;
    /**
    * @brief  Reserved for Future use
    */
    rlUInt8_t reserved1;
    /**
     * @brief  TX Power Calibration Mode
             [b0]  Enable Calibration Reports Bitmap (Not valid for IWR6843 ES1.0) \n
                   0 - Update TX gain setting from LUT and do a closed loop calibration \n
                       (OLPC + CLPC) \n
                   1 - Update TX gain settings from LUT only (OLPC only) \n
                       OLPC: Open Loop Power Control. In this mode the TX stage codes are set \n
                       based on a coarse measurement and a LUT generated for every temperature \n
                       and the stage codes are picked from the LUT CLPC: Closed Loop Power \n
                       Control. In this mode the TX stage codes are picked from the coarse LUT \n
                       as generated in OLPC step. Later the TX power is measured and the TX \n
                       stage codes are corrected to achieve the desired TX power accuracy. \n
                       Default value: 0 \n
             [b7:1] Reserved \n

     */
     rlUInt8_t txPowerCalMode;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved2;
}rlRunTimeCalibConf_t;

/*! \brief
* RX gain temperature LUT read
*/
typedef struct rlRxGainTempLutReadReq
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
} rlRxGainTempLutReadReq_t;

/*! \brief
* TX gain temperature LUT read
*/
typedef struct rlTxGainTempLutReadReq
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
} rlTxGainTempLutReadReq_t;

/*! \brief
* RX gain temperature LUT inject
*/
typedef struct rlRxGainTempLutData
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  Byte0: RX gain code for temperature < -30 deg C \n
     *         Byte1: RX gain code for temperature [-30, -20) deg C \n
     *         Byte2: RX gain code for temperature [-20, -10) deg C \n
     *         Byte3: RX gain code for temperature [-10, 0) deg C \n
     *         Byte4: RX gain code for temperature [0, 10) deg C \n
     *         Byte5: RX gain code for temperature [10, 20) deg C \n
     *         Byte6: RX gain code for temperature [20, 30) deg C \n
     *         Byte7: RX gain code for temperature [30, 40) deg C \n
     *         Byte8: RX gain code for temperature [40, 50) deg C \n
     *         Byte9: RX gain code for temperature [50, 60) deg C \n
     *         Byte10: RX gain code for temperature [60, 70) deg C \n
     *         Byte11: RX gain code for temperature [70, 80) deg C \n
     *         Byte12: RX gain code for temperature [80, 90) deg C \n
     *         Byte13: RX gain code for temperature [90, 100) deg C \n
     *         Byte14: RX gain code for temperature [100, 110) deg C \n
     *         Byte15: RX gain code for temperature [110, 120) deg C \n
     *         Byte16: RX gain code for temperature [120, 130) deg C \n
     *         Byte17: RX gain code for temperature [130, 140) deg C \n
     *         Byte18: RX gain code for temperature >= 140 deg C \n
     *         Byte19: RESERVED. Set it to 0x00 \n
     *         Each byte is encoded as follows \n
     *         Bits Definition\n
     *             [4:0]   IF_GAIN_CODE \n
     *                     IF gain is IF_GAIN_CODE * 2 - 6 dB \n
     *                     Valid values: 0 to 17 \n
     *                     1 LSB = 2 dB \n
     *             [7:5]   RF_GAIN_CODE \n
     *                     Value    RF Gain \n
     *                     0     Maximum RF gain \n
     *                     1     Maximum RF gain - 2dB \n
     *                     2     Maximum RF gain - 4dB \n
     *                     3     Maximum RF gain - 6dB \n
     *                     4     Maximum RF gain - 8dB \n
     */
    rlUInt8_t  rxGainTempLut[RL_MAX_NUM_OF_TEMP10_RANGES + 1U];
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  This field indicates the profile Index for which this configuration applies
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  Gain code for Rx0/1/2/3 \n
     *          Byte0: RX gain code for temperature [-30, -20) deg C \n
     *          Byte1: RX gain code for temperature < -30 deg C \n
     *          Byte2: RX gain code for temperature [-10, 0) deg C \n
     *          Byte3: RX gain code for temperature [-20, -10) deg C \n
     *          Byte4: RX gain code for temperature [10, 20) deg C \n
     *          Byte5: RX gain code for temperature [0, 10) deg C \n
     *          Byte6: RX gain code for temperature [30, 40) deg C \n
     *          Byte7: RX gain code for temperature [20, 30) deg C \n
     *          Byte8: RX gain code for temperature [50, 60) deg C \n
     *          Byte9: RX gain code for temperature [40, 50) deg C \n
     *          Byte10: RX gain code for temperature [70, 80) deg C \n
     *          Byte11: RX gain code for temperature [60, 70) deg C \n
     *          Byte12: RX gain code for temperature [90, 100) deg C \n
     *          Byte13: RX gain code for temperature [80, 90) deg C \n
     *          Byte14: RX gain code for temperature [110, 120) deg C \n
     *          Byte15: RX gain code for temperature [100, 110) deg C \n
     *          Byte16: RX gain code for temperature [130, 140) deg C \n
     *          Byte17: RX gain code for temperature [120, 130) deg C \n
     *          Byte18: RESERVED. Set it to 0x00 \n
     *          Byte19: RX gain code for temperature >= 140 deg C \n
     *          Each byte is encoded as follows \n
     *          Bits Definition \n
     *             [4:0]   IF_GAIN_CODE \n
     *                     IF gain is IF_GAIN_CODE * 2 - 6 dB \n
     *                     Valid values: 0 to 17 \n
     *                     1 LSB = 2 dB \n
     *             [7:5]   RF_GAIN_CODE \n
     *                     Value    RF Gain \n
     *                     0     Maximum RF gain \n
     *                     1     Maximum RF gain - 2dB \n
     *                     2     Maximum RF gain - 4dB \n
     *                     3     Maximum RF gain - 6dB \n
     *                     4     Maximum RF gain - 8dB \n
     */
    rlUInt8_t  rxGainTempLut[RL_MAX_NUM_OF_TEMP10_RANGES + 1U];
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t  reserved1;
} rlRxGainTempLutData_t;

/*! \brief
* TX gain temperature LUT inject
*/
typedef struct rlTxGainTempLutData
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  Gain code for Tx0/1/2 \n
     *          Byte0: TX gain code for temperature < -30 deg C \n
     *          Byte1: TX gain code for temperature [-30, -20) deg C \n
     *          Byte2: TX gain code for temperature [-20, -10) deg C \n
     *          Byte3: TX gain code for temperature [-10, 0) deg C \n
     *          Byte4: TX gain code for temperature [0, 10) deg C \n
     *          Byte5: TX gain code for temperature [10, 20) deg C \n
     *          Byte6: TX gain code for temperature [20, 30) deg C \n
     *          Byte7: TX gain code for temperature [30, 40) deg C \n
     *          Byte8: TX gain code for temperature [40, 50) deg C \n
     *          Byte9: TX gain code for temperature [50, 60) deg C \n
     *          Byte10: TX gain code for temperature [60, 70) deg C \n
     *          Byte11: TX gain code for temperature [70, 80) deg C \n
     *          Byte12: TX gain code for temperature [80, 90) deg C \n
     *          Byte13: TX gain code for temperature [90, 100) deg C \n
     *          Byte14: TX gain code for temperature [100, 110) deg C \n
     *          Byte15: TX gain code for temperature [110, 120) deg C \n
     *          Byte16: TX gain code for temperature [120, 130) deg C \n
     *          Byte17: TX gain code for temperature [130, 140) deg C \n
     *          Byte18: TX gain code for temperature >= 140 deg C \n
     *          Byte19: RESERVED. Set it to 0x00 \n
     *         Each byte is encoded as follows \n
     *         Bits Definition \n
     *         [5:0]  STG_CODE \n
     *                Higher values for higher gain \n
     *         [7:6]  RESERVED \n
     */
    rlUInt8_t  txGainTempLut[RL_TX_CNT][RL_MAX_NUM_OF_TEMP10_RANGES + 1U];
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief    This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  Gain code for Tx0/1/2 \n
     *          Byte0: TX gain code for temperature [-30, -20) deg C \n
     *          Byte1: TX gain code for temperature < -30 deg C \n
     *          Byte2: TX gain code for temperature [-10, 0) deg C \n
     *          Byte3: TX gain code for temperature [-20, -10) deg C \n
     *          Byte4: TX gain code for temperature [10, 20) deg C \n
     *          Byte5: TX gain code for temperature [0, 10) deg C \n
     *          Byte6: TX gain code for temperature [30, 40) deg C \n
     *          Byte7: TX gain code for temperature [20, 30) deg C \n
     *          Byte8: TX gain code for temperature [50, 60) deg C \n
     *          Byte9: TX gain code for temperature [40, 50) deg C \n
     *          Byte10: TX gain code for temperature [70, 80) deg C \n
     *          Byte11: TX gain code for temperature [60, 70) deg C \n
     *          Byte12: TX gain code for temperature [90, 100) deg C \n
     *          Byte13: TX gain code for temperature [80, 90) deg C \n
     *          Byte14: TX gain code for temperature [110, 120) deg C \n
     *          Byte15: TX gain code for temperature [100, 110) deg C \n
     *          Byte16: TX gain code for temperature [130, 140) deg C \n
     *          Byte17: TX gain code for temperature [120, 130) deg C \n
     *          Byte18: RESERVED. Set it to 0x00 \n
     *          Byte19: TX gain code for temperature >= 140 deg C \n
     *         Each byte is encoded as follows \n
     *         Bits Definition \n
     *         [5:0]  STG_CODE \n
     *                Higher values for higher gain \n
     *         [7:6]  RESERVED \n
     */
    rlUInt8_t  txGainTempLut[RL_TX_CNT][RL_MAX_NUM_OF_TEMP10_RANGES + 1U];
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t  reserved1;
} rlTxGainTempLutData_t;

/*! \brief
* Tx freq and power limit configuration
*/
typedef struct rlRfTxFreqPwrLimitMonConf
{
    /**
     * @ brief  The sensor's lower frequency limit for calibrations and monitoring for TX0 is \n
                encoded in 2 bytes (16 bit unsigned number) \n
                 1 LSB = 10 MHz \n
                 For 77GHz devices(76GHz to 81GHz) \n
                     Valid range: 7600 to 8100
                     Default value : 7600 (If API is not issued)
                 For 60GHz devices(57GHz to 64GHz) \n
                     Valid range: 5700 to 6400
                     Default value : 5700 (If API is not issued)
     */
    rlUInt16_t freqLimitLowTx0;
    /**
     * @ brief  The sensor's lower frequency limit for calibrations and monitoring for TX1 is \n
                encoded in 2 bytes (16 bit unsigned number) \n
                 1 LSB = 10 MHz \n
                 For 77GHz devices(76GHz to 81GHz) \n
                     Valid range: 7600 to 8100
                     Default value : 7600 (If API is not issued)
                 For 60GHz devices(57GHz to 64GHz) \n
                     Valid range: 5700 to 6400
                     Default value : 5700 (If API is not issued)
     */
    rlUInt16_t freqLimitLowTx1;
    /**
     * @ brief  The sensor's lower frequency limit for calibrations and monitoring for TX2 is \n
                encoded in 2 bytes (16 bit unsigned number) \n
                 1 LSB = 10 MHz \n
                 For 77GHz devices(76GHz to 81GHz) \n
                     Valid range: 7600 to 8100
                     Default value : 7600 (If API is not issued)
                 For 60GHz devices(57GHz to 64GHz) \n
                     Valid range: 5700 to 6400
                     Default value : 5700 (If API is not issued)
     */
    rlUInt16_t freqLimitLowTx2;
    /**
     * @brief  The sensor's higher frequency limit for calibrations and monitoring for TX0 is \n
               encoded in 2 bytes (16 bit unsigned number) \n
                 1 LSB = 10 MHz \n
                 For 77GHz devices(76GHz to 81GHz) \n
                     Valid range: 7600 to 8100
                     Default value : 8100 (If API is not issued)
                 For 60GHz devices(57GHz to 64GHz) \n
                     Valid range: 5700 to 6400
                     Default value : 6400 (If API is not issued)
               NOTE: FREQ_LIMIT_HIGH_TXn should be strictly greater than FREQ_LIMIT_LOW_TXn \n
     */
    rlUInt16_t freqLimitHighTx0;
    /**
     * @brief  The sensor's higher frequency limit for calibrations and monitoring for TX1 is \n
               encoded in 2 bytes (16 bit unsigned number) \n
                 1 LSB = 10 MHz \n
                 For 77GHz devices(76GHz to 81GHz) \n
                     Valid range: 7600 to 8100
                     Default value : 8100 (If API is not issued)
                 For 60GHz devices(57GHz to 64GHz) \n
                     Valid range: 5700 to 6400
                     Default value : 6400 (If API is not issued)
               NOTE: FREQ_LIMIT_HIGH_TXn should be strictly greater than FREQ_LIMIT_LOW_TXn \n
     */
    rlUInt16_t freqLimitHighTx1;
    /**
     * @brief  The sensor's higher frequency limit for calibrations and monitoring for TX2 is \n
               encoded in 2 bytes (16 bit unsigned number) \n
                 1 LSB = 10 MHz \n
                 For 77GHz devices(76GHz to 81GHz) \n
                     Valid range: 7600 to 8100
                     Default value : 8100 (If API is not issued)
                 For 60GHz devices(57GHz to 64GHz) \n
                     Valid range: 5700 to 6400
                     Default value : 6400 (If API is not issued)
               NOTE: FREQ_LIMIT_HIGH_TXn should be strictly greater than FREQ_LIMIT_LOW_TXn \n
     */
    rlUInt16_t freqLimitHighTx2;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  TX0 output power back off \n
                 1LSB = 1dB
                 Valid Value: 0, 3, 6, 9
     */
    rlUInt8_t tx0PwrBackOff;
    /**
     * @brief  TX1 output power back off \n
                 1LSB = 1dB
                 Valid Value: 0, 3, 6, 9
       */
    rlUInt8_t tx1PwrBackOff;
    /**
     * @brief  TX2 output power back off \n
                 1LSB = 1dB
                 Valid Value: 0, 3, 6, 9
     */
    rlUInt8_t tx2PwrBackOff;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
#else
    /**
     * @brief  TX1 output power back off \n
                 1LSB = 1dB
                 Valid Value: 0, 3, 6, 9
     */
    rlUInt8_t tx1PwrBackOff;
    /**
     * @brief  TX0 output power back off \n
                 1LSB = 1dB
                 Valid Value: 0, 3, 6, 9
     */
    rlUInt8_t tx0PwrBackOff;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  TX2 output power back off \n
                 1LSB = 1dB
                 Valid Value: 0, 3, 6, 9
     */
    rlUInt8_t tx2PwrBackOff;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved2;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved3;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved4;
}rlRfTxFreqPwrLimitMonConf_t;

/*! \brief
* Loopback burst set configuration
*/
typedef struct rlLoopbackBurst
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief Loopback selection  \n
     *          Value Definition  \n
     *          0     No loopback \n
     *          1     IF loopback \n
     *          2     PS loopback \n
     *          3     PA loopback \n
     *          Others RESERVED   \n
     */
    rlUInt8_t  loopbackSel;
    /**
     * @brief Base profile used for loopback chirps \n
     *         Valid values 0 to 3 \n
     */
    rlUInt8_t  baseProfileIndx;
    /**
     * @brief Indicates the index of the burst in the loopback sub-frame for which \n
     *          this configuration applies \n
     *          Valid values 0 to 15       \n
     */
    rlUInt8_t  burstIndx;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
#else
    /**
     * @brief Base profile used for loopback chirps \n
     *         Valid values 0 to 3 \n
     */
    rlUInt8_t  baseProfileIndx;
    /**
     * @brief Loopback selection  \n
     *          Value Definition  \n
     *          0     No loopback \n
     *          1     IF loopback \n
     *          2     PS loopback \n
     *          3     PA loopback \n
     *          Others RESERVED   \n
     */
    rlUInt8_t  loopbackSel;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief Indicates the index of the burst in the loopback sub-frame for which \n
     *          this configuration applies \n
     *          Valid values 0 to 15       \n
     */
    rlUInt8_t  burstIndx;
#endif
    /**
     * @brief  Start frequency for loopback \n
     *           For 77GHz devices (76 GHz to 81 GHz): \n
     *               1 LSB = 3.6e9 / 2^26 Hz = 53.644 Hz \n
     *               Valid range: 0x5471C71B to 0x5A000000 \n
     *           For 60GHz devices (57 GHz to 64 GHz): \n
     *               1 LSB = 2.7e9 / 2^26 Hz = 40.233 Hz \n
     *               Valid range: 0x5471C71C to 0x5ED097B4 \n
     */
    rlUInt32_t freqConst;
    /**
     * @brief  Ramp slope for loopback burst \n
     *           For 77GHz devices (76 GHz to 81 GHz): \n
     *               1 LSB = (3.6e6 * 900) / 2^26 = 48.279 kHz/uS \n
     *               Valid range: -2072 to 2072 (Max 100MHz/uS) \n
     *           For 60GHz devices (57 GHz to 64 GHz): \n
     *               1 LSB = (2.7e6 * 900) / 2^26 = 36.21 kHz/uS \n
     *               Valid range: -6905 to 6905 (Max 250 MHz/uS) \n
     */
    rlInt16_t  slopeConst;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
    /**
     * @brief  Concatenated code for output power backoff for TX0, TX1, TX2\n
                   b7:0 TX0 output power back off \n
                   b15:8 TX1 output power back off \n
                   b23:16 TX2 output power back off \n
                   b31:24 Reserved \n
     */
    rlUInt32_t txBackoff;
    /**
     * @brief  Bit Definition \n
     *         5:0 Rx gain    \n
     *             This field defined RX gain for each profile \n
     *             1 LSB = 1 dB \n
     *             Valid values: all even values from 24 to 52 \n
     *         7:6 RF Gain Target        \n
     *             Value  RF gain target \n
     *             00     30 dB          \n
     *             01     34 dB          \n
     *             10     Reserved       \n
     *             11     26 dB          \n
     *        15:8 Reserved              \n
     */
    rlUInt16_t rxGain;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Tx enable selection bit mask \n
     *          b0 Enable TX0  \n
     *           0 Tx0 Disable \n
     *           1 Tx0 Enable  \n
     *          b1 Enable TX1  \n
     *           0 Tx1 Disable \n
     *           1 Tx1 Enable  \n
     *          b2 Enable TX2  \n
     *           0 Tx2 Disable \n
     *           1 Tx2 Enable  \n
     */
    rlUInt8_t  txEn;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved2;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved2;
    /**
     * @brief  Tx enable selection bit mask \n
     *          b0 Enable TX0  \n
     *           0 Tx0 Disable \n
     *           1 Tx0 Enable  \n
     *          b1 Enable TX1  \n
     *           0 Tx1 Disable \n
     *           1 Tx1 Enable  \n
     *          b2 Enable TX2  \n
     *           0 Tx2 Disable \n
     *           1 Tx2 Enable  \n
     */
    rlUInt8_t  txEn;
#endif
    /**
     * @brief   Bit Definition              \n
     *          b0  CONST_BPM_VAL_TX0_OFF   \n
     *               Value of Binary Phase Shift value for TX0, during idle time  \n
     *          b1  CONST_BPM_VAL_TX0_ON    \n
     *               Value of Binary Phase Shift value for TX0, during chirp      \n
     *          b2  CONST_BPM_VAL_TX1_OFF   \n
     *               Value of Binary Phase Shift value for TX1, during idle time  \n
     *          b3  CONST_BPM_VAL_TX1_ON    \n
     *               Value of Binary Phase Shift value for TX1, during chirp      \n
     *          b4  CONST_BPM_VAL_TX2_OFF   \n
     *               Value of Binary Phase Shift value for TX2, during idle time  \n
     *          b5  CONST_BPM_VAL_TX2_ON    \n
     *               Value of Binary Phase Shift value for TX2, during chirp      \n
     *       b15:6  RESERVED                \n
     */
    rlUInt16_t bpmConfig;
    /**
     * @brief  Bits  Digital corrections      \n
                 b0  IQMM correction disable  \n
                      0 - Enable, 1- Disable  \n
                 b1  RX Gain and Phase correction disable \n
                      0 - Enable, 1- Disable  \n
              b15:2  RESERVED \n
     */
    rlUInt16_t digCorrDis;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief   Value   IF Loopback frequency value \n
     *          0       180 kHz   \n
     *          1       240 kHz   \n
     *          2       360 kHz   \n
     *          3       720 kHz   \n
     *          4       1 MHz     \n
     *          5       2 MHz     \n
     *          6       2.5 MHz   \n
     *          7       3 MHz     \n
     *          8       4.02 MHz  \n
     *          9       5 MHz     \n
     *          10      6 MHz     \n
     *          11      8.03 MHz  \n
     *          12      9 MHz     \n
     *          13      10 MHz    \n
     *          255-14  RESERVED  \n
     */
    rlUInt8_t  ifLbFreq;
    /**
     * @brief   1 LSB = 10 mV
                Valid range: 1 to 63
     */
    rlUInt8_t  ifLbMag;
    /**
     * @brief Value PGA gain value \n
     *          0   PGA is OFF     \n
     *          1   -22 dB         \n
     *          2   -16 dB         \n
     *          3   -15 dB         \n
     *          4   -14 dB         \n
     *          5   -13 dB         \n
     *          6   -12 dB         \n
     *          7   -11 dB         \n
     *          8   -10 dB         \n
     *          9    -9 dB         \n
     *          10   -8 dB         \n
     *          11   -7 dB         \n
     *          12   -6 dB         \n
     *          13   -5 dB         \n
     *          14   -4 dB         \n
     *          15   -3 dB         \n
     *          16   -2 dB         \n
     *          17   -1 dB         \n
     *          18    0 dB         \n
     *          19    1 dB         \n
     *          20    2 dB         \n
     *          21    3 dB         \n
     *          22    4 dB         \n
     *          23    5 dB         \n
     *          24    6 dB         \n
     *          25    7 dB         \n
     *          26    8 dB         \n
     *          27    9 dB         \n
     *          255-28   RESERVED  \n
     */
    rlUInt8_t  ps1PgaIndx;
    /**
     * @brief Same as above definition
     */
    rlUInt8_t  ps2PgaIndx;
#else
    /**
     * @brief   1 LSB = 10 mV
                Valid range: 1 to 63
     */
    rlUInt8_t  ifLbMag;
    /**
     * @brief   Value   IF Loopback frequency value \n
     *          0       180 kHz   \n
     *          1       240 kHz   \n
     *          2       360 kHz   \n
     *          3       720 kHz   \n
     *          4       1 MHz     \n
     *          5       2 MHz     \n
     *          6       2.5 MHz   \n
     *          7       3 MHz     \n
     *          8       4.02 MHz  \n
     *          9       5 MHz     \n
     *          10      6 MHz     \n
     *          11      8.03 MHz  \n
     *          12      9 MHz     \n
     *          13      10 MHz    \n
     *          255-14  RESERVED  \n
     */
    rlUInt8_t  ifLbFreq;
    /**
     * @brief Same as above definition
     */
    rlUInt8_t  ps2PgaIndx;
    /**
     * @brief Value PGA gain value \n
     *         0   PGA is OFF     \n
     *         1   -22 dB         \n
     *         2   -16 dB         \n
     *         3   -15 dB         \n
     *         4   -14 dB         \n
     *         5   -13 dB         \n
     *         6   -12 dB         \n
     *         7   -11 dB         \n
     *         8   -10 dB         \n
     *         9    -9 dB         \n
     *         10   -8 dB         \n
     *         11   -7 dB         \n
     *         12   -6 dB         \n
     *         13   -5 dB         \n
     *         14   -4 dB         \n
     *         15   -3 dB         \n
     *         16   -2 dB         \n
     *         17   -1 dB         \n
     *         18    0 dB         \n
     *         19    1 dB         \n
     *         20    2 dB         \n
     *         21    3 dB         \n
     *         22    4 dB         \n
     *         23    5 dB         \n
     *         24    6 dB         \n
     *         25    7 dB         \n
     *         26    8 dB         \n
     *         27    9 dB         \n
     *         255-28   RESERVED  \n
     */
    rlUInt8_t  ps1PgaIndx;
#endif
    /**
     * @brief Phase shifter loop back frequency in kHz\n
                1 LSB = 1 kHz                         \n
                Bits    Definition                    \n
                b15:0   TX0 Loopback Frequency        \n
                b31:16  TX1 Loopback Frequency        \n
     */
    rlUInt32_t psLbFreq;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved3;
    /**
     * @brief This value is a 100MHz divider which sets the loopback frequency \n
               For e.g. for a 1 MHz frequency, set this to 100 \n
                        for a 2 MHz frequency, set this to 50  \n
               Note: To ensure no leakage of signal power, user has to ensure that \n
               100MHz/LOOPBACK_FREQ is an integer multiple of bin width. \n
               For e.g. if user choses 25Msps sampling rate and 2048 samples/chirp, \n
               then LOOPBACK_FREQ of 64 (=1.5625MHz) will ensure no leakage.
     */
    rlUInt16_t paLbFreq;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved4[3U];
} rlLoopbackBurst_t;

/*! \brief
* Chirp row configuration, radarSS stores each chirp config in memory in 3 rows.
*/
typedef struct rlChirpRow
{
    /**
     * @brief Nth Chirp config Row 1
                 Bits Definition
                  3:0 PROFILE_INDX
                       Valid range 0 to 3
                  7:4 RESERVED
                  13:8 FREQ_SLOPE_VAR
                       For 77GHz Devices (76GHz to 81GHz):
                           1 LSB = 3.6e9*900 /2^26  ~48.279kHz
                           Valid range: 0 to 63
                       For 60GHz Devices (57GHz to 64GHz):
                           1 LSB = 2.7e9*900 /2^26  ~36.21kHz
                           Valid range: 0 to 63
                  15:14 RESERVED
                  18:16 TX_ENABLE
                         Bit Definition
                          b0 TX0 Enable
                          b1 TX1 Enable
                          b2 TX2 Enable
                  23:19 RESERVED
                  29:24 BPM_CONSTANT_BITS
                          Bit Definition
                           b0 CONST_BPM_VAL_TX0_OFF
                               Value of Binary Phase Shift value for TX0, when during idle time
                           b1 CONST_BPM_VAL_TX0_ON
                               Value of Binary Phase Shift value for TX0, during chirp
                           b2 CONST_BPM_VAL_TX1_OFF
                               For TX1
                           b3 CONST_BPM_VAL_TX1_ON
                               For TX1
                           b4 CONST_BPM_VAL_TX2_OFF
                               For TX2
                           b5 CONST_BPM_VAL_TX2_ON
                               For TX2
                  31:30 RESERVED
     */
    rlUInt32_t chirpNR1;
    /**
     * @brief Nth Chirp config Row 2
                 Bits Definition
                 b22:0 FREQ_START_VAR
                   1 LSB = 3.6e9/2^26  ~53.644kHz
                    Valid range: 0 to 8388607
                 b31:23 RESERVED
    */
    rlUInt32_t chirpNR2;
    /**
     * @brief Nth Chirp config Row 3
                 Bits Definition
                 b11:0 IDLE_TIME_VAR
                        1 LSB = 10 ns
                        Valid range: 0 to 4095
                 b15:12 RESERVED
                 b27:16 ADC_START_TIME_VAR
                        1 LSB = 10 ns
                        Valid range: 0 to 4095
                 b31:28 RESERVED
    */
    rlUInt32_t chirpNR3;
} rlChirpRow_t;

/*! \brief
* Dynamic chirp configuration for 16 chirp configurations.
*/
typedef struct rlDynChirpCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Reserved for Future use
               Bits   Definition
               b3:0   Reserved
               b7:4   If user does not wish to reconfigure all 3 chirp rows, then the following \n
                      mode can be used to configure only one row per chirp which enables the \n
                      user to configure 48 chirps in one API, efectively saving on the \n
                      reconfiguration time. If chirpRowSelect[b7:4] is non-zero, then the API \n
                      parameters chirp_xR1, chirp_xR2 and chirp_xR3 for 1 <= x <= 16 in this \n
                      API would mean CHIRP(3x - 2)Ry, CHIRP(3x - 1) Ry and CHIRP(3x)Ry where y \n
                      is as per the below table \n
                      Value         Definition \n
                      0b0000        Enables all 3 chirp rows to be reconfigured \n
                      0b0001        Enables only chirp row 1 to be reconfigured \n
                      0b0010        Enables only chirp row 2 to be reconfigured \n
                      0b0011        Enables only chirp row 3 to be reconfigured \n
                      Others        Reserved \n
                      @note : Value(1 - 3) is not applcicable in IWR6843.
     */
    rlUInt8_t    chirpRowSelect;
    /**
     * @brief Indicates the segment of the chirp RAM that the 16 chirps definitions in this sub \n
     *         block map to any of one segment out of 32 segments of SW chirp RAM.
     *         Valid range 0 to 31.
     */
    rlUInt8_t    chirpSegSel;
#else
    /**
     * @brief Indicates the segment of the chirp RAM that the 16 chirps definitions in this sub \n
     *         block map to any of one segment out of 32 segments of SW chirp RAM.
     *         Valid range 0 to 31.
     */
    rlUInt8_t    chirpSegSel;
    /**
     * @brief  Reserved for Future use
               Bits   Definition
               b3:0   Reserved
               b7:4   If user does not wish to reconfigure all 3 chirp rows, then the following \n
                      mode can be used to configure only one row per chirp which enables the \n
                      user to configure 48 chirps in one API, efectively saving on the \n
                      reconfiguration time. If chirpRowSelect[b7:4] is non-zero, then the API \n
                      parameters chirp_xR1, chirp_xR2 and chirp_xR3 for 1 <= x <= 16 in this \n
                      API would mean CHIRP(3x - 2)Ry, CHIRP(3x - 1) Ry and CHIRP(3x)Ry where y \n
                      is as per the below table (Not supported in IWR6843 ES1.0, Value shall \n
                      be 0) \n
                      Value         Definition \n
                      0b0000        Enables all 3 chirp rows to be reconfigured \n
                      0b0001        Enables only chirp row 1 to be reconfigured \n
                      0b0010        Enables only chirp row 2 to be reconfigured \n
                      0b0011        Enables only chirp row 3 to be reconfigured \n
                      Others        Reserved \n
     */
    rlUInt8_t    chirpRowSelect;
#endif
    /**
     * @brief  Indicates when the configuration needs to be applied \n
     *         Bit    Definition \n
     *          0     Program the new configuration when rlSetDynChirpEn API is issued \n
     *          1     Program the new configuration immediately \n
     *                NOTE: User has to ensure that the chirps which are being reconfigured are
     *                not the ones which are currently in use for chirping
     */
    rlUInt16_t   programMode;
    /**
     * @brief Chirp row configurations for 16 chirps.
     */
    rlChirpRow_t chirpRow[16U];
} rlDynChirpCfg_t;

/*! \brief
* Dynamic chirp enable configuration
*/
typedef struct rlDynChirpEnCfg
{
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved;
}rlDynChirpEnCfg_t;

/*! \brief
* Dynamic per chirp phase shifter configuration for each TX
*/
typedef struct rlChirpPhShiftPerTx
{
    /**
     * @brief Nth Chirp TX0 phase shift value
                Bits TX0 phase shift definition
                b1:0 RESERVED (set it to 0b00)
                b7:2 TX0 phase shift value
                    1 LSB = 360/2^6 = 5.625 (degree)
                    Valid range: 0 to 63
    */
    rlUInt8_t   chirpNTx0PhaseShifter;
    /**
     * @brief Nth Chirp TX1 phase shift value
                Bits TX1 phase shift definition
                b1:0 RESERVED (set it to 0b00)
                b7:2 TX1 phase shift value
                    1 LSB = 360/2^6 = 5.625 (degree)
                    Valid range: 0 to 63
    */
    rlUInt8_t   chirpNTx1PhaseShifter;
    /**
     * @brief Nth Chirp TX2 phase shift value   \n
                Bits TX2 phase shift definition \n
                b1:0 RESERVED (set it to 0b00)  \n
                b7:2 TX2 phase shift value
                    1 LSB = 360/2^6 = 5.625 (degree)
                    Valid range: 0 to 63
    */
    rlUInt8_t   chirpNTx2PhaseShifter;
} rlChirpPhShiftPerTx_t;

/*! \brief
* Dynamic per chirp phase shifter configuration
*/
typedef struct rlDynPerChirpPhShftCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t    reserved;
    /**
     * @brief Indicates the segment of the chirp RAM that the 16 chirps definitions in this sub \n
     *         block map to any of one segment out of 32 segments of SW chirp RAM. \n
     *         Valid range 0 to 31.
     */
    rlUInt8_t    chirpSegSel;
#else
    /**
     * @brief Indicates the segment of the chirp RAM that the 16 chirps definitions in this sub \n
     *         block map to any of one segment out of 32 segments of SW chirp RAM. \n
     *         Valid range 0 to 31.
     */
    rlUInt8_t    chirpSegSel;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t    reserved;
#endif
    /**
     * @brief Tx phase shifter configurations for 16 chirps.
              Note : User need to take care of data for endianess.
     */
    rlChirpPhShiftPerTx_t phShiftPerTx[16U];
    /**
     * @brief  Indicates when the configuration needs to be applied \n
     *         Bit    Definition \n
     *          0     Program the new configuration when rlSetDynChirpEn API is issued \n
     *          1     Program the new configuration immediately \n
     *                NOTE: User has to ensure that the chirps which are being reconfigured are
     *                not the ones which are currently in use for chirping
     */
    rlUInt16_t   programMode;
} rlDynPerChirpPhShftCfg_t;

/*! \brief
* Get calibration data configuration structure
*/
typedef struct rlCalDataGetCfg
{
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved;
    /**
     * @brief Get Calibration Data Chunk Id
     */
    rlUInt16_t chunkId;
}rlCalDataGetCfg_t;

/*! \brief
* Calibration data which application will receive from radarSS and will feed in to the Device
* in next power up to avoid calibration.
*/
typedef struct rlCalDataStore
{
    /**
     * @brief Number of calibration data chunks Available in device
     */
    rlUInt16_t numOfChunk;
    /**
     * @brief Current Calibration Data Chunk Id. Valid range 0-2
     */
    rlUInt16_t chunkId;
    /**
     * @brief Calibration chunk Data
     */
    rlUInt8_t  calData[224U];
} rlCalDataStore_t;

/*! \brief
* Structure to store all Calibration data chunks which device provides in response of
* rlRfCalibDataStore API. Applcation needs to provide same structure to rlRfCalibDataRestore API
* to restore calibration data to the device.
*/
typedef struct rlCalibrationData
{
     rlCalDataStore_t calibChunk[RL_MAX_CALIB_DATA_CHUNK];
}rlCalibrationData_t;

/*! \brief
* Inter-Rx gain and phase offset configuration
*/
typedef struct rlInterRxGainPhConf
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
#else
    /**
     * @brief  Reserved for Future use
     */
    rlUInt8_t  reserved0;
    /**
     * @brief  This field indicates the profile Index for which this configuration applies.
     */
    rlUInt8_t  profileIndx;
#endif
    /**
     * @brief  Reserved for Future use
     */
    rlUInt16_t reserved1;
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  One byte per RX (8-bit signed number) \n
                 Byte    Assignment \n
                 0       RX0 digital gain \n
                 1       RX1 digital gain \n
                 2       RX2 digital gain \n
                 3       RX3 digital gain \n
                 1 LSB = 0.1 dB \n
                 Valid Range: -120 to 119 \n
     */
    rlInt8_t   digRxGain[RL_RX_CNT];
#else
    /**
     * @brief  One byte per RX (8-bit signed number) \n
                 Byte    Assignment \n
                 0       RX1 digital gain \n
                 1       RX0 digital gain \n
                 2       RX3 digital gain \n
                 3       RX2 digital gain \n
                 1 LSB = 0.1 dB \n
                 Valid Range: -120 to 119 \n
     */
    rlInt8_t   digRxGain[RL_RX_CNT];
#endif
    /**
     * @brief  Two bytes per RX \n
                 Bits         Assignment \n
                 b15:0        RX0 digital phase shift \n
                 b31:16       RX1 digital phase shift \n
                 b47:32       RX2 digital phase shift \n
                 b63:48       RX3 digital phase shift \n
                 1 LSB = 360 degree / 2^16  ~ 0.0055 (degree) \n
                 Valid Range: 0 to 65535 \n
                 NOTE: This field is NOT applicable when ADC_OUT_FMT is 00 (real output) \n
     */
    rlUInt16_t digRxPhShift[RL_RX_CNT];
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t  reserved2;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t  reserved3;
} rlInterRxGainPhConf_t;

/*! \brief
 * BSS Bootup status data structure
 */
typedef struct rlRfBootStatusCfg
{
    /**
     * @brief radarSS bootup status
                Bit     definition [1: pass, 0: fail]
                0       image CRC validation
                1       CPU and VIM self-test status
                2       Reserved
                3       VIM test
                4       STC self-test
                5       CR4 STC
                6       CRC test
                7       Pampgen ECC
                8       DFE Parity
                9       DFE ECC
                10      Rampgen Lockstep
                11      FRC lockstep
                12      DFE PBIST
                13      Rampgen lockstep
                14      PBIST test
                15      WDT test
                16      ESM test
                17      DFE STC
                18      FRC test
                19      TCM ECC
                20      TCM parity
                21      DCC test
                22      SOCC test
                23      GPADC test
                24      FFT test
                25      RTI test
                26      PCR test
                31:27   reserved
     */
    rlUInt32_t bssSysStatus;
    /**
     * @brief RF BIST SS power up time \n
                1 LSB = 5ns
     */
    rlUInt32_t bssBootUpTime;
        /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlUInt32_t reserved1;
}rlRfBootStatusCfg_t;

/*! \brief
* Inter Chirp block control configuration
*/
typedef struct rlInterChirpBlkCtrlCfg
{
    /**
     * @brief Time to wait after ramp end before turning off RX0 and RX2 RF stages. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx02RfTurnOffTime;
    /**
     * @brief Time to wait after ramp end before turning off RX1 and RX3 RF stages. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx13RfTurnOffTime;
    /**
     * @brief Time to wait after ramp end before turning off RX0 and RX2 baseband stages. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx02BbTurnOffTime;
    /**
     * @brief Time to wait after ramp end before turning off RX1 and RX3 baseband stages. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx12BbTurnOffTime;
    /**
     * @brief Time before TX Start Time when RX0 and RX2 RF stages are to be put in
                fast-charge state.          \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx02RfPreEnTime;
    /**
     * @brief Time before TX Start Time when RX1 and RX3 RF stages are to be put in
                fast-charge state.          \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx13RfPreEnTime;
    /**
     * @brief Time before TX Start Time when RX0 and RX2 baseband stages are to be put in
                fast-charge state.          \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx02BbPreEnTime;
    /**
     * @brief Time before TX Start Time when RX1 and RX3 baseband stages are to be put in
                fast-charge state.          \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx13BbPreEnTime;
    /**
     * @brief Time before TX Start Time when RX0 and RX2 RF stages are to be enabled. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
    */
    rlInt16_t rx02RfTurnOnTime;
    /**
     * @brief Time before TX Start Time when RX1 and RX3 RF stages are to be enabled. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
    */
    rlInt16_t rx13RfTurnOnTime;
    /**
     * @brief Time before TX Start Time when RX0 and RX2 baseband stages are to be enabled. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx02BbTurnOnTime;
    /**
     * @brief Time before TX Start Time when RX1 and RX3 baseband stages are to be enabled. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rx13BbTurnOnTime;
    /**
     * @brief Time to wait after ramp end before turning off RX LO chain. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rxLoChainTurnOffTime;
    /**
     * @brief Time to wait after ramp end before turning off TX LO chain. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t txLoChainTurnOffTime;
    /**
     * @brief Time to wait after ramp end before turning on RX LO chain. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t rxLoChainTurnOnTime;
    /**
     * @brief Time to wait after ramp end before turning on TX LO chain. \n
                1 LSB = 10 ns               \n
                Valid range: -1024 to 1023  \n
     */
    rlInt16_t txLoChainTurnOnTime;
    /**
     * @brief  Reserved for Future use
     */
    rlInt32_t reserved0;
    /**
     * @brief  Reserved for Future use
     */
    rlInt32_t reserved1;
} rlInterChirpBlkCtrlCfg_t;

/*! \brief
* Sub-frame trigger API
*/
typedef struct rlSubFrameStartCfg
{
    /**
     * @brief Command for sub-frame trigger     \n
              Value 0 = No effect               \n
              Value 1 = Trigger next sub-frame  \n
     */
    rlUInt16_t startCmd;
    /**
     * @brief Reserved for future use
     */
    rlUInt16_t reserved;
} rlSubFrameStartCfg_t;

/*! \brief
* Get phase shift calibration data configuration structure
*/
typedef struct rlPhShiftCalDataGetCfg
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Index of the transmitter channel for which the phase shift is desired \n
               Valid range: 0 to (Number of Tx channels enabled at rlSetChannelConfig) - 1 \n
               e.g: 0 to 1 (For xWR1642), 0 to 2 (For xWR1843, xWR1443 & xWR1243). \n
     */
    rlUInt8_t txIndex;
    /**
     * @brief Reserved for future use
     */
    rlUInt8_t reserved0;
#else
    /**
     * @brief Reserved for future use
     */
    rlUInt8_t reserved0;
    /**
     * @brief  Index of the transmitter channel for which the phase shift is desired \n
               Valid range: 0 to (Number of Tx channels enabled at rlSetChannelConfig) - 1 \n
               e.g: 0 to 1 (For xWR1642), 0 to 2 (For xWR1843, xWR1443, xWR1243). \n
     */
    rlUInt8_t txIndex;
#endif    
    /**
     * @brief Reserved for future use
     */
    rlUInt16_t reserved1;
}rlPhShiftCalDataGetCfg_t;

/*! \brief
* Phase shift calibration data which application will receive from radarSS and will feed in to the
* Device in next power up to avoid calibration.
*/
typedef struct rlPhShiftCalibrationStore
{
#ifndef MMWL_BIG_ENDIAN
    /**
     * @brief  Index of the transmitter channel for which the phase shift is desired \n
               Valid range: 0 to (Number of Tx channels enabled at rlSetChannelConfig) - 1 \n
                       e.g: 0 to 1 (For xWR1642), 0 to 2 (For xWR1843, xWR1443 & xWR1243). \n
     */
    rlUInt8_t txIndex;
    /**
     * @brief Set this to 1 after injecting calibration data for all Txs to enable the firmware \n
*             calibration. \n
     */
    rlUInt8_t calibApply;
#else
    /**
    * @brief Set this to 1 after injecting calibration data for all Txs to enable the firmware \n
             calibration. \n
    */
    rlUInt8_t calibApply;
    /**
     * @brief  Index of the transmitter channel for which the phase shift is desired \n
               Valid range: 0 to (Number of Tx channels enabled at rlSetChannelConfig) - 1 \n
               e.g: 0 to 1 (For xWR1642), 0 to 2 (For xWR1843, xWR1443 & xWR1243). \n
     */
    rlUInt8_t txIndex;
#endif
    /**
     * @brief Observed phase shift corresponding to each desired phase shift. Index n \n
              corresponds to desired phase shift of n * 5.625 degree. \n
                 n     Desired phase shift   Observed phase shift is read in the following bytes \n
                 0     0.000 degree                  byte[1], byte[0] \n
                 1     5.625 degree                  byte[3], byte[2] \n
                 2     11.250 degree                 byte[5], byte[4] \n
                 3     16.875 degree                 byte[7], byte[6] \n
                 :          :                                :        \n
                 :          :                                :        \n
                 63    354.375 degree                byte[127], byte[126] \n
              1 LSB = (360 degree)/pow(2,10). \n
     */
    rlUInt8_t  observedPhShiftData[128U];
    /**
     * @brief Reserved for future use
     */
    rlUInt16_t reserved;
} rlPhShiftCalibrationStore_t;

/*! \brief
* Structure to store all Phase shifter calibration data chunks which device provides in response of
* rlRfPhShiftCalibDataStore API. Applcation needs to provide same structure to 
* rlRfPhShiftCalibDataRestore API to restore calibration data to the device.
*/
typedef struct rlPhShiftCalibrationData
{
     rlPhShiftCalibrationStore_t PhShiftcalibChunk[RL_TX_CNT];
}rlPhShiftCalibrationData_t;

/*! \brief
* Die ID data structure
*/
typedef struct rlRfDieIdCfg
{
    /**
    * @brief Lot number
    */
    rlUInt32_t lotNo;
    /**
    * @brief Wafer number
    */
    rlUInt32_t waferNo;
    /**
    * @brief X cordinate of the die in the wafer
    */
    rlUInt32_t devX;
    /**
    * @brief Y cordinate of the die in the wafer
    */
    rlUInt32_t devY;
    /**
    * @brief Reserved for future use
    */
    rlUInt32_t reserved0;
    /**
    * @brief Reserved for future use
    */
    rlUInt32_t reserved1;
    /**
    * @brief Reserved for future use
    */
    rlUInt32_t reserved2;
    /**
    * @brief Reserved for future use
    */
    rlUInt32_t reserved3;
}rlRfDieIdCfg_t;

/******************************************************************************
 * FUNCTION PROTOTYPES
 ******************************************************************************
 */

 /**
 *  @defgroup Sensor Sensor
 *  @brief mmwave radar RF/Sensor Configuration Module
 *
 *  @image html mmwave_frontend.png
 *
 *  The RF/Sensor Configuration module controls the different HW blocks inside mmWave Front end.
 *  mmWave Front End has below key blocks
 *  -# Chirp sequencer (Radar Timing Engine) - This block is responsible for constructing
 *  the sequence of FMCW chirps or frames and programming the timing engine
 *  -# Rx/Tx Channel - This defines how many Rx and Tx channel needs to be enabled. Also it
 *  defines how to configure the mmWave front end in cascade mode for Imaging Radar
 *  -# Rx Analog Chain - This defines how the received signal is mixed and how different filters
 *  in the chain can be configured
 *  -# ADC and Digital Front End Configuration - This defines how the IF data is digitized and how
 *  it is sampled for further processing in the DSP or Hardware Accelerator. Same ADC data can be
 *  sent over LVDS/CSI2 interface to an extenal processor

 *  The Sensor Control APIs needs to be called by application in below sequence
 *  ## Initial/Static Configuration #
 *  Application should first configure the mmWave Front end or Radar SS with below Static
 *  configurations
 *  - Channel Configuration - \ref rlSetChannelConfig
 *  - ADC output Configuration - \ref rlSetAdcOutConfig
 *  - Low power mode Configuration  - \ref rlSetLowPowerModeConfig
 *
 *  ## Initialization and Calibration #
 *  After initial static configurations, application should initialize RF
 *  and shall wait for calibration complete Asynchornous event
 *  RL_RF_AE_INITCALIBSTATUS_SB
 *  - \ref rlRfInit
 *
 *  ## FMCW chirp Configuration #
 *  After RF initilization, Application can configure chirps and frame using
 *  below APIs
 *  - Profile Configuration - \ref rlSetProfileConfig
 *  - Chirp Configuraiton - \ref rlSetChirpConfig
 *  - Frame Configuration - \ref rlSetFrameConfig or rlSetAdvFrameConfig
 *    Note about HW SYNC_IN pulse in hardware triggered mode
 *
 *    a. The SYNC_IN pulse must not arrive before the frame end boundary
 *    b. If frame trigger delay is used with hardware triggered mode, then external SYNC_IN pulse
 *    periodicity should take care of the configured frame trigger delay and frame periodicity.
 *    The external pulse should be issued only after the sum total of frame trigger delay and
 *    frame periodicity. See figure below
 *    @image html mmwave_hwsyncincareabout.png
 *    c. The inter frame blank time should be at least 250 uS(100 uS for frame preparation and 150
 *    uS for any calibration updates to hardware). Add 150 uS to inter-frame blank time for test
 *    source configuration if test source is enabled.
 *
 *  ## Frame Trigger #
 *  After All the configuration, Application can use Sensor Start API
 *  to start Frame and shall wait for Frame Ready Asynchronous event
 *  RL_RF_AE_FRAME_TRIGGER_RDY_SB
  *  - \ref rlSensorStart
 *
 *  ## Below is the list of advance features in mmWave Front end #
 *  ## Advance Frame #
 * Legacy frame config API \ref rlSetFrameConfig supports looping of the same FMCW frame.
 * In order to configure multiple FMCW frames with different chirp profiles, user needs
 * to use \ref rlSetAdvFrameConfig API. Advance Frame consists of one or upto 4 Sub-Frames
 * Each Sub-Frame consists of multiple bursts. Each burst consists of multiple chirps as
 * shown in diagram below.\n
 * To enable Advance Frame, Application needs to follow below
 * sequence
 *  - Profile Configuration - \ref rlSetProfileConfig
 *  - Chirp Configuraiton - \ref rlSetChirpConfig
 *  - Advance Frame Configuration - \ref rlSetAdvFrameConfig
 *
 *  @image html adv_frame_seq.png
 *
 *  ## Dynamic Chirp Configuration #
 *  Using Legacy chirp configuration API \ref rlSetChirpConfig, chirps can't be re-configure
 *  without stopping the ongoing FMCW frame using \ref rlSensorStop API. \n
 *  If user needs to re-configure chirp during the frame, it needs to use Dynamic chirp
 *  config APIs. Once the API is received by mmWave Front end, it would re-configure the
 *  chirps for next FMCW frame. Dynamic Chirps can be defined using below APIs
 *  - Dynamic Chirp Configuration - \ref rlSetDynChirpCfg
 *  - Enable Dynamic Chirps - \ref rlSetDynChirpEn
 *
 *  Diagram below shows the Dynamic Chirp behaviour. Note that since dynamic chirps are
 *  configured at run time, there is not error checks done on the input data. If input data
 *  is out of range or invalid, device might misbehave.
 *
 *  @image html dyn_chip_seq.png
 *
 * ## Calibration #
 * TI mmWave Front end includes built-in processor that is programmed by TI to handle RF
   calibrations and functional safety monitoring.  The RF calibrations ensure that the
   performance of the device is maintained across temperature and process corners

  -# Some of the calibrations are just temperature and process based look-up-tables, which are
     used to update the RF/Analog components
  -# Built-in temperature sensors enable the device to monitor the temperature every few seconds
     and update the relevant components accordingly

* Below is the list of calibrations and corresponding duration in microseconds \n
* Boot Time Calibration
<table>
<caption id="multi_row_1">Calibration Duration</caption>
<tr><th>Calibration                      <th>Duration(us)
<tr><td>APLL<td>330
<tr><td>Synth VCO<td>1300
<tr><td>LO DIST<td>12
<tr><td>ADC DC <td>600
<tr><td>HPF cutoff <td>3500
<tr><td>LPF cut off <td>3200
<tr><td>Peak detector<td>4200
<tr><td>TX power (assumes 2 TX use-case)<td>6000
<tr><td>RX gain <td>2300
<tr><td>TX phase (not enabled in firmware)<td>150
<tr><td>RX IQMM (Not applcicable for Real ADC mode)<td>32000
</table>

* Run Time Calibration
<table>
<caption id="multi_row_2">Calibration Duration</caption>
<tr><th>Calibration                      <th>Duration(us)
<tr><td>APLL<td>150
<tr><td>Synth VCO<td>300
<tr><td>LO DIST<td>30
<tr><td>Peak detector<td>500
<tr><td>TX power (assumes 2 TX use-case)<td>800
<tr><td>RX gain <td>30
<tr><td>Application of calibration to hardware (This needs to be included always) <td>150
</table>
*
*    Related Files
*   - rl_sensor.c
 *  @addtogroup Sensor
 *  @{
 */

/* RF/Sensor Configuration Functions */

/*Rx and Tx Channel Configuration */
MMWL_EXPORT rlReturnVal_t rlSetChannelConfig(rlUInt8_t deviceMap, rlChanCfg_t* data);

/*ADC Out Configuration */
MMWL_EXPORT rlReturnVal_t rlSetAdcOutConfig(rlUInt8_t deviceMap, rlAdcOutCfg_t* data);

/*Low Power Mode */
MMWL_EXPORT rlReturnVal_t rlSetLowPowerModeConfig(rlUInt8_t deviceMap,
                                                  rlLowPowerModeCfg_t* data);

/*RF Init */
MMWL_EXPORT rlReturnVal_t rlRfInit(rlUInt8_t deviceMap);

/*Profile Configuration */
MMWL_EXPORT rlReturnVal_t rlGetProfileConfig(rlUInt8_t deviceMap,
                                             rlUInt16_t profileId,
                                             rlProfileCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetProfileConfig(rlUInt8_t deviceMap,
                                             rlUInt16_t cnt,
                                             rlProfileCfg_t* data);

/*Chirp Configuration */
MMWL_EXPORT rlReturnVal_t rlGetChirpConfig(rlUInt8_t deviceMap, rlUInt16_t chirpStartIdx,
                                           rlUInt16_t chirpEndIdx, rlChirpCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetChirpConfig(rlUInt8_t deviceMap,
                                           rlUInt16_t cnt,
                                           rlChirpCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetMultiChirpCfg(rlUInt8_t deviceMap, rlUInt16_t cnt,
                                             rlChirpCfg_t **data);

/*Frame Configuration */
MMWL_EXPORT rlReturnVal_t rlGetFrameConfig(rlUInt8_t deviceMap, rlFrameCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetFrameConfig(rlUInt8_t deviceMap, rlFrameCfg_t* data);

/*Sensor Trigger */
MMWL_EXPORT rlReturnVal_t rlSensorStart(rlUInt8_t deviceMap);
MMWL_EXPORT rlReturnVal_t rlSensorStop(rlUInt8_t deviceMap);

/*Advance Frame Configuration */
MMWL_EXPORT rlReturnVal_t rlGetAdvFrameConfig(rlUInt8_t deviceMap,
                                              rlAdvFrameCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetAdvFrameConfig(rlUInt8_t deviceMap,
                                              rlAdvFrameCfg_t* data);

/*Continous mode Configuration */
MMWL_EXPORT rlReturnVal_t rlSetContModeConfig(rlUInt8_t deviceMap,
                                              rlContModeCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlEnableContMode(rlUInt8_t deviceMap, rlContModeEn_t* data);

/*BPM Configuration */
MMWL_EXPORT rlReturnVal_t rlSetBpmCommonConfig(rlUInt8_t deviceMap,
                                               rlBpmCommonCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetBpmChirpConfig(rlUInt8_t deviceMap,
                                              rlBpmChirpCfg_t* data);
MMWL_EXPORT rlReturnVal_t rlSetMultiBpmChirpConfig(rlUInt8_t deviceMap,
                                                   rlUInt16_t cnt, rlBpmChirpCfg_t** data);

/*Test Source Configuration */
MMWL_EXPORT rlReturnVal_t rlSetTestSourceConfig(rlUInt8_t deviceMap,
                                                rlTestSource_t* data);
MMWL_EXPORT rlReturnVal_t rlTestSourceEnable(rlUInt8_t deviceMap,
                                             rlTestSourceEnable_t* data);

/*Get RF Characterization Time and Temperature information */
MMWL_EXPORT rlReturnVal_t rlRfGetTemperatureReport(rlUInt8_t deviceMap,
                                                   rlRfTempData_t* data);

/*Get RF Digital Front End Statistics */
MMWL_EXPORT rlReturnVal_t rlRfDfeRxStatisticsReport(rlUInt8_t deviceMap,
                                                    rlDfeStatReport_t* data);

/*Dynamic Power save Configuration */
MMWL_EXPORT rlReturnVal_t rlRfDynamicPowerSave(rlUInt8_t deviceMap,
                                               rlDynPwrSave_t* data);

/*RadarSS Device configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetDeviceCfg(rlUInt8_t deviceMap, rlRfDevCfg_t* data);

/*GPADC Read(From external Input) configuration */
MMWL_EXPORT rlReturnVal_t rlSetGpAdcConfig(rlUInt8_t deviceMap, rlGpAdcCfg_t* data);

/* LDO bypass Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetLdoBypassConfig(rlUInt8_t deviceMap,
                                                 rlRfLdoBypassCfg_t* data);

/*Per Chirp Phase Shifter Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetPhaseShiftConfig(rlUInt8_t deviceMap, rlUInt16_t cnt,
                                                  rlRfPhaseShiftCfg_t* data);

/* PA loopback Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetPALoopbackConfig(rlUInt8_t deviceMap,
                                                  rlRfPALoopbackCfg_t* data);

/* Phase Shift Loopback Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetPSLoopbackConfig(rlUInt8_t deviceMap,
                                                  rlRfPSLoopbackCfg_t* data);

/* IF loopback Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetIFLoopbackConfig(rlUInt8_t deviceMap,
                                                  rlRfIFLoopbackCfg_t* data);

/* Programmable Filter RAM coefficients */
MMWL_EXPORT rlReturnVal_t rlRfSetProgFiltCoeffRam(rlUInt8_t deviceMap,
                                                  rlRfProgFiltCoeff_t* data);

/* programmable Filter Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetProgFiltConfig(rlUInt8_t deviceMap,
                                                rlRfProgFiltConf_t* data);

/*Radar Misc Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetMiscConfig(rlUInt8_t deviceMap,
                                            rlRfMiscConf_t* data);

/*Calibration/monitoring Time Unit Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetCalMonTimeUnitConfig(rlUInt8_t deviceMap,
                                                      rlRfCalMonTimeUntConf_t* data);

/*Calibration/monitoring Freq Limit Configuration */
MMWL_EXPORT rlReturnVal_t rlRfSetCalMonFreqLimitConfig(rlUInt8_t deviceMap,
                                                       rlRfCalMonFreqLimitConf_t* data);

/*Init time calibration Configuration */
MMWL_EXPORT rlReturnVal_t rlRfInitCalibConfig(rlUInt8_t deviceMap,
                                              rlRfInitCalConf_t* data);

/*Run time calibration Configuration */
MMWL_EXPORT rlReturnVal_t rlRfRunTimeCalibConfig(rlUInt8_t deviceMap,
                                                 rlRunTimeCalibConf_t* data);

/*Rx Gain Look up Table (LUT) Update APIs */
MMWL_EXPORT rlReturnVal_t rlRxGainTempLutSet(rlUInt8_t deviceMap,
                                             rlRxGainTempLutData_t *data);
MMWL_EXPORT rlReturnVal_t rlRxGainTempLutGet(rlUInt8_t deviceMap,
                                             rlRxGainTempLutReadReq_t *inData,
                                             rlRxGainTempLutData_t *outData);

/*Tx Gain Look up Table (LUT) Update APIs */
MMWL_EXPORT rlReturnVal_t rlTxGainTempLutSet(rlUInt8_t deviceMap,
                                             rlTxGainTempLutData_t *data);
MMWL_EXPORT rlReturnVal_t rlTxGainTempLutGet(rlUInt8_t deviceMap,
                                             rlTxGainTempLutReadReq_t *inData,
                                             rlTxGainTempLutData_t *outData);

/*TX freq and power limits monitoring configuration */
MMWL_EXPORT rlReturnVal_t rlRfTxFreqPwrLimitConfig(rlUInt8_t deviceMap,
                                                   rlRfTxFreqPwrLimitMonConf_t* data);

/*Looback chirp configuration API */
MMWL_EXPORT rlReturnVal_t rlSetLoopBckBurstCfg(rlUInt8_t deviceMap,
                                               rlLoopbackBurst_t *data);

/*Dynamic chirp configuration API */
MMWL_EXPORT rlReturnVal_t rlSetDynChirpCfg(rlUInt8_t deviceMap,
                                           rlUInt16_t segCnt,
                                           rlDynChirpCfg_t **data);
MMWL_EXPORT rlReturnVal_t rlSetDynChirpEn(rlUInt8_t deviceMap,
                                          rlDynChirpEnCfg_t *data);

/*Dynamic per-chirp phase shifter configuration API(AWR1243P) */
MMWL_EXPORT rlReturnVal_t rlSetDynPerChirpPhShifterCfg(rlUInt8_t deviceMap,
                                                       rlUInt16_t segCnt,
                                                       rlDynPerChirpPhShftCfg_t **data);
/*Calibration data store/restore configuration */
MMWL_EXPORT rlReturnVal_t rlRfCalibDataStore(rlUInt8_t deviceMap,
                                             rlCalibrationData_t *data);
MMWL_EXPORT rlReturnVal_t rlRfCalibDataRestore(rlUInt8_t deviceMap,
                                               rlCalibrationData_t *data);

/*Update Inter Rx Gain/Phase offsets for Inter-RX mismatch compensation */
MMWL_EXPORT rlReturnVal_t rlRfInterRxGainPhaseConfig(rlUInt8_t deviceMap,
                                                     rlInterRxGainPhConf_t* data);

/*Get RadarSS/BSS bootup(Boot time monitoring tests) status */
MMWL_EXPORT rlReturnVal_t rlGetRfBootupStatus(rlUInt8_t deviceMap,
                                              rlRfBootStatusCfg_t *data);

/*Update Inter Rx Gain/Phase offsets for Inter-RX mismatch compensation */
MMWL_EXPORT rlReturnVal_t rlSetInterChirpBlkCtrl(rlUInt8_t deviceMap,
                                                 rlInterChirpBlkCtrlCfg_t *data);
/*Sub frame trigger API */
MMWL_EXPORT rlReturnVal_t rlSetSubFrameStart(rlUInt8_t deviceMap,
                                             rlSubFrameStartCfg_t *data);
/*Phase shifter calibration data store/restore configuration*/
MMWL_EXPORT rlReturnVal_t rlRfPhShiftCalibDataStore(rlUInt8_t deviceMap,
                                                    rlPhShiftCalibrationData_t *data);
MMWL_EXPORT rlReturnVal_t rlRfPhShiftCalibDataRestore(rlUInt8_t deviceMap,
                                                      rlPhShiftCalibrationData_t *data);
/*Get device die ID status*/
MMWL_EXPORT rlReturnVal_t rlGetRfDieId(rlUInt8_t deviceMap, rlRfDieIdCfg_t *data);
/*!
 Close the Doxygen group.
 @}
 */



#ifdef __cplusplus
}
#endif

#endif
/*
 * END OF RL_SENSOR_H FILE
 */
