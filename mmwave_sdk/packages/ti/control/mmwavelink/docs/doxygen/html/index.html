<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mmWaveLink Framework</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">mmWaveLink Framework </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p>TI Automotive and Industrial mmWave Radar products are highly-integrated 77GHz CMOS millimeter wave devices.The devices integrate all of the RF and Analog functionality, including VCO, PLL, PA, LNA, Mixer and ADC for multiple TX/RX channels into a single chip.<br />
</p><ol type="1">
<li>The AWR1243 is an RF transceiver device and it includes 4 receiver channels and 3 transmit channels in a single chip. AWR1243 also support multi-chip cascading. <br />
</li>
<li>The AWR1443/IWR1443 is a mmwave radar-on-a-chip device, which includes 4 receive channels and 3 transmit channels and additionally an Cortex R4F and hardware FFT accelerator.<br />
</li>
<li>AWR1642 and IWR1642 are mmwave radar-on-a-chip device, which includes 4 receive channels and 2 transmit channels and additionally an Cortex R4F and C674x DSP for signal processing</li>
</ol>
<p>TI mmWave radar devices include a mmwave front end or BIST (Built-in Self-Test) processor, which is responsible to configure the RF/Analog and digital front-end in real-time, as well as to periodically schedule calibration and functional safety monitoring.This enables the mmwave front-end(BIST processor) to be self-contained and capable of adapting itself to handle temperature and ageing effects, and to enable significant ease-of-use from an external host perspective.</p>
<p>TI mmwave front end is a closed subsystem whose internal blocks are configurable using messages coming over mailbox.<br />
 TI mmWaveLink provides APIs generates these message and sends it to mmwave front end over mailbox. It also includes acknowledement and CRC for each message to provide a reliable communication</p>
<p>TI mmWaveLink Framework:</p><ul>
<li>Is a link between application and mmwave front end.</li>
<li>Provides low level APIs to configure the front end and handles the communication with the front end.</li>
<li>Is platform and OS independent which means it can be ported into any processor which provides communication interface such as SPI and basic OS routines. The mmWaveLink framework can also run in single threaded environment</li>
<li><p class="startli">Is integrated into mmWave SDK and can run on R4F or DSP and communicates with mmwave front end over Mailbox interface</p>
<div class="image">
<img src="mmwl_block_diagram.png" alt="mmwl_block_diagram.png"/>
</div>
</li>
</ul>
<h1><a class="anchor" id="modules_sec"></a>
Modules</h1>
<p>To make it simple, TI's mmWaveLink framework capabilities are divided into modules.<br />
 These capabilities include device control, RF/Analog configuration, ADC configuration, Data path(LVDS/CSI2) cofiguration, FMCW chirp configuration and more.<br />
 Listed below are the various modules in the mmWaveLink framework:</p><ol type="1">
<li><a class="el" href="group___device.html">Device</a> - Controls mmwave radar device which include: <pre class="fragment"> Initialization, such as: mmwave device power On/Off, Firmware Patch download
 Cascade device configuration such as Add/Connect multiple mmWave devices
</pre></li>
<li><p class="startli"><a class="el" href="group___sensor.html">Sensor</a> - The RF/Sensor Configuration module controls the different HW blocks inside mmWave Front end.</p>
<div class="image">
<img src="mmwave_frontend.png" alt="mmwave_frontend.png"/>
</div>
<p class="startli">mmWave Front End has below key blocks</p><ol type="a">
<li>Chirp sequencer (Radar Timing Engine) - This block is responsible for constructing the sequence of FMCW chirps or frames and programming the timing engine</li>
<li>Rx/Tx Channel - This defines how many Rx and Tx channel needs to be enabled. Also it defines how to configure the mmWave front end in cascade mode for Imaging Radar</li>
<li>Rx Analog Chain - This defines how the received signal is mixed and how different filters in the chain can be configured</li>
<li>ADC and Digital Front End Configuration - This defines how the IF data is digitized and how it is sampled for further processing in the DSP or Hardware Accelerator. Same ADC data can be sent over LVDS/CSI2 interface to an extenal processor</li>
</ol>
<p class="startli">The configuration APIs can further be categorized as.<br />
</p><ol type="a">
<li>mmwave static configuration, such as: Tx and Rx channel, ADC configuration etc</li>
<li>mmwave dynamic configuration, such as FMCW Chirp configuration, profile configuration</li>
<li>mmwave advance configuration such as Binary phase modulation, Dynamic power save etc</li>
<li>mmwave sensor control, such as: Frame start/stop</li>
</ol>
</li>
<li><p class="startli"><a class="el" href="group___data___path.html">Data Path</a> - The Data path Configuration module controls the high speed interface in mmWave device.</p>
<div class="image">
<img src="data_path.png" alt="data_path.png"/>
</div>
<p class="startli">The configuration APIs include.<br />
</p><ol type="a">
<li>High Speed interface(LVDS/CSI2) selection</li>
<li>Data format and rate configuration</li>
<li>ADC, Chirp Profile(CP), Chirp Quality(CQ) data transfer sequence</li>
<li>Lane configurations</li>
<li>LVDS/CSI2 specific configuration</li>
</ol>
</li>
<li><p class="startli"><a class="el" href="group___monitoring.html">Monitoring</a> - The Monitoring/Calibration module configures the calibration and functional safety monitoring in mmWave device</p>
<p class="startli">TI mmWave Front end includes built-in processor that is programmed by TI to handle RF calibrations and functional safety monitoring. The RF calibrations ensure that the performance of the device is maintained across temperature and process corners</p>
</li>
<li><a class="el" href="group___communication___protocol.html">Communication Protocol</a> - The mmWave communication protocol ensures reliable communication between host(internal or external) and mmWave Front end.<ol type="a">
<li>It is a simple stop and wait protocol. Each message needs to be acknowledged by receiver before next message can be sent.</li>
<li>Messages are classifieds as "Command", "Response" and "Asynchronous Event"</li>
<li><p class="startli">If Command can not be processed immediately, ACK response is sent immediately (If requested). "Asynchronous Event" is sent upon completion of the command execution.</p>
<div class="image">
<img src="comm_prot.png" alt="comm_prot.png"/>
</div>
</li>
</ol>
</li>
</ol>
<h1><a class="anchor" id="proting_sec"></a>
Porting Guide</h1>
<p>The porting of the mmWaveLink driver to any new platform is based on few simple steps. This guide takes you through this process step by step. Please follow the instructions carefully to avoid any problems during this process and to enable efficient and proper work with the device. Please notice that all modifications and porting adjustments of the driver should be made in the application only and driver should not be modified. Changes in the application file will ensure smoothly transaction to new versions of the driver at the future!</p>
<h2><a class="anchor" id="porting_step1"></a>
Step 1 - Define mmWaveLink client callback structure</h2>
<p>The mmWaveLink framework is ported to different platforms using mmWaveLink client callbacks. These callbacks are grouped as different structures such as OS callbacks, Communication Interface callbacks and others. Application needs to define these callbacks and initialize the mmWaveLink framework with the structure.</p>
<div class="fragment"><div class="line"><a class="code" href="structrl_client_cbs__t.html">rlClientCbs_t</a> clientCtx = { 0 };</div><div class="line">rlReturnVal_t retVal;</div><div class="line">rlUInt32_t deviceMap = RL_DEVICE_MAP_CASCADED_1;</div></div><!-- fragment --><p>Refer to <a class="el" href="structrl_client_cbs__t.html">rlClientCbs_t</a> for more details</p>
<h2><a class="anchor" id="porting_step2"></a>
Step 2 - Implement Communication Interface Callbacks</h2>
<p>The mmWaveLink device support several standard communication protocol among SPI and MailBox Depending on device variant, one need to choose the communication channel. For e.g xWR1443/xWR1642/xWR1843 requires Mailbox interface and AWR1243 supports SPI interface. The interface for this communication channel should include 4 simple access functions:</p><ol type="1">
<li>rlComIfOpen</li>
<li>rlComIfClose</li>
<li>rlComIfRead</li>
<li>rlComIfWrite</li>
</ol>
<div class="fragment"><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a3ae82df16e9fa40b1f779b5cf9c6c7c5">comIfCb</a>.<a class="code" href="structrl_com_if_cbs__t.html#ad6c2654153471d5730d9610c8df1abbb">rlComIfOpen</a> = Host_spiOpen;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a3ae82df16e9fa40b1f779b5cf9c6c7c5">comIfCb</a>.<a class="code" href="structrl_com_if_cbs__t.html#a9bd418a848a07c14d1550de16e7cf285">rlComIfClose</a> = Host_spiClose;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a3ae82df16e9fa40b1f779b5cf9c6c7c5">comIfCb</a>.<a class="code" href="structrl_com_if_cbs__t.html#a12950b749ee769443d205bc40a0a1e65">rlComIfRead</a> = Host_spiRead;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a3ae82df16e9fa40b1f779b5cf9c6c7c5">comIfCb</a>.<a class="code" href="structrl_com_if_cbs__t.html#ac76b33ac3590508be4d0c921a3a71697">rlComIfWrite</a> = Host_spiWrite;</div></div><!-- fragment --><p>Refer to <a class="el" href="structrl_com_if_cbs__t.html">rlComIfCbs_t</a> for interface details</p>
<h2><a class="anchor" id="porting_step3"></a>
Step 3 - Implement Device Control Interface</h2>
<p>The mmWaveLink driver internally powers on/off the mmWave radar device. The exact implementation of these interface is platform dependent, hence you need to implement below functions:</p><ol type="1">
<li>rlDeviceEnable</li>
<li>rlDeviceDisable</li>
<li>rlRegisterInterruptHandler</li>
</ol>
<div class="fragment"><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#ae65dab926e053dc24079e79b3b9c8e60">devCtrlCb</a>.<a class="code" href="structrl_device_ctrl_cbs__t.html#a7fe515d0d9caed4aa836b28296ad0315">rlDeviceDisable</a> = Host_disableDevice;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#ae65dab926e053dc24079e79b3b9c8e60">devCtrlCb</a>.<a class="code" href="structrl_device_ctrl_cbs__t.html#a48bed7c1b206da47f7216a7f6040c76e">rlDeviceEnable</a> = Host_enableDevice;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#ae65dab926e053dc24079e79b3b9c8e60">devCtrlCb</a>.<a class="code" href="structrl_device_ctrl_cbs__t.html#a87119a4423c63b88a5bdbe0f1300b52d">rlDeviceMaskHostIrq</a> = Host_spiIRQMask;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#ae65dab926e053dc24079e79b3b9c8e60">devCtrlCb</a>.<a class="code" href="structrl_device_ctrl_cbs__t.html#a83930307501d0d592d0d1e3e177e4d9d">rlDeviceUnMaskHostIrq</a> = Host_spiIRQUnMask;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#ae65dab926e053dc24079e79b3b9c8e60">devCtrlCb</a>.<a class="code" href="structrl_device_ctrl_cbs__t.html#a844ca3ed84483a6e13aed8839c9306a2">rlRegisterInterruptHandler</a> = Host_registerInterruptHandler;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#ae65dab926e053dc24079e79b3b9c8e60">devCtrlCb</a>.<a class="code" href="structrl_device_ctrl_cbs__t.html#ad8e04cee50fe254a502bf23bcb732a9c">rlDeviceWaitIrqStatus</a> = Host_deviceWaitIrqStatus;</div></div><!-- fragment --><p>Refer to <a class="el" href="structrl_device_ctrl_cbs__t.html">rlDeviceCtrlCbs_t</a> for interface details</p>
<h2><a class="anchor" id="porting_step4"></a>
Step 4 - Implement Event Handlers</h2>
<p>The mmWaveLink driver reports asynchronous event indicating mmwave radar device status, exceptions etc. Application can register this callback to receive these notification and take appropriate actions</p>
<div class="fragment"><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a535669ce9b42bcb41b42de8ae28b4302">eventCb</a>.<a class="code" href="structrl_event_cbs__t.html#a94b8aad8e982719bb18be979028f8a2d">rlAsyncEvent</a> = Host_asyncEventHandler;</div></div><!-- fragment --><p>Refer to <a class="el" href="structrl_event_cbs__t.html">rlEventCbs_t</a> for interface details</p>
<h2><a class="anchor" id="porting_step5"></a>
Step 5 - Implement OS Interface</h2>
<p>The mmWaveLink driver can work in both OS and NonOS environment. If Application prefers to use operating system, it needs to implement basic OS routines such as tasks, mutex and Semaphore</p>
<div class="fragment"><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a37b4773b6f9df6b29055a818972bf696">osiCb</a>.<a class="code" href="structrl_osi_cbs__t.html#aa8c795417abdb50216cce182e213fcf8">mutex</a>.<a class="code" href="structrl_osi_mutex_cbs__t.html#aacea5f4ad495797c8205cd40f02724e0">rlOsiMutexCreate</a> = Host_osiLockObjCreate;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a37b4773b6f9df6b29055a818972bf696">osiCb</a>.<a class="code" href="structrl_osi_cbs__t.html#aa8c795417abdb50216cce182e213fcf8">mutex</a>.<a class="code" href="structrl_osi_mutex_cbs__t.html#a4651c2a73bbdfe9d2ff1ac95730d2d3d">rlOsiMutexLock</a> = Host_osiLockObjLock;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a37b4773b6f9df6b29055a818972bf696">osiCb</a>.<a class="code" href="structrl_osi_cbs__t.html#aa8c795417abdb50216cce182e213fcf8">mutex</a>.<a class="code" href="structrl_osi_mutex_cbs__t.html#a88386d426935fd48b4d1132ec9e16116">rlOsiMutexUnLock</a> = Host_osiLockObjUnlock;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a37b4773b6f9df6b29055a818972bf696">osiCb</a>.<a class="code" href="structrl_osi_cbs__t.html#aa8c795417abdb50216cce182e213fcf8">mutex</a>.<a class="code" href="structrl_osi_mutex_cbs__t.html#a78f7aea4da6d4abd86227c3cb00b8443">rlOsiMutexDelete</a> = Host_osiLockObjDelete;</div><div class="line"></div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a37b4773b6f9df6b29055a818972bf696">osiCb</a>.<a class="code" href="structrl_osi_cbs__t.html#a7f35532a7096659bc79f74db3e791e0e">sem</a>.<a class="code" href="structrl_osi_sem_cbs__t.html#a733c561afbc3723344e45ba7d4ace975">rlOsiSemCreate</a> = Host_osiSyncObjCreate;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a37b4773b6f9df6b29055a818972bf696">osiCb</a>.<a class="code" href="structrl_osi_cbs__t.html#a7f35532a7096659bc79f74db3e791e0e">sem</a>.<a class="code" href="structrl_osi_sem_cbs__t.html#a932b845dfd383f189d9adbad43a14a50">rlOsiSemWait</a> = Host_osiSyncObjWait;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a37b4773b6f9df6b29055a818972bf696">osiCb</a>.<a class="code" href="structrl_osi_cbs__t.html#a7f35532a7096659bc79f74db3e791e0e">sem</a>.<a class="code" href="structrl_osi_sem_cbs__t.html#a7d97a6c765154dfe39031494daf6b279">rlOsiSemSignal</a> = Host_osiSyncObjSignal;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a37b4773b6f9df6b29055a818972bf696">osiCb</a>.<a class="code" href="structrl_osi_cbs__t.html#a7f35532a7096659bc79f74db3e791e0e">sem</a>.<a class="code" href="structrl_osi_sem_cbs__t.html#ad55bde9265a94bd2948e03e5a58a5f8f">rlOsiSemDelete</a> = Host_osiSyncObjDelete;</div><div class="line"></div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a37b4773b6f9df6b29055a818972bf696">osiCb</a>.<a class="code" href="structrl_osi_cbs__t.html#a4a8b740d3597e3e5daae542fa4b00f68">queue</a>.<a class="code" href="structrl_osi_msg_q_cbs__t.html#a341fd52e3bf2b0dd1877f0c31af4f17a">rlOsiSpawn</a> = Host_osiSpawn;</div><div class="line"></div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a6e79e0eb4e4358a258a8789080c91f4a">timerCb</a>.rlDelay = Host_osiSleep;</div></div><!-- fragment --><p>Refer to <a class="el" href="structrl_osi_cbs__t.html">rlOsiCbs_t</a> for interface details</p>
<h2><a class="anchor" id="porting_step6"></a>
Step 6 - Implement CRC Interface</h2>
<p>The mmWaveLink driver uses CRC for message integrity. If Application prefers to use CRC, it needs to implement CRC routine.</p>
<div class="fragment"><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a80aba1fcd510da1085e06674e52cc9a1">crcCb</a>.<a class="code" href="structrl_crc_cbs__t.html#a49a83745a3697d3ca3f125d7751458e1">rlComputeCRC</a> = Host_computeCRC;</div></div><!-- fragment --><p>Refer to <a class="el" href="structrl_crc_cbs__t.html">rlCrcCbs_t</a> for interface details</p>
<h2><a class="anchor" id="porting_step7"></a>
Step 7 - Implement Debug Interface</h2>
<p>The mmWaveLink driver can print the debug message. If Application prefers to enable debug messages, it needs to implement debug callback.</p>
<p>Refer to <a class="el" href="structrl_dbg_cb__t.html">rlDbgCb_t</a> for interface details</p>
<h2><a class="anchor" id="porting_final"></a>
Final Step - Initializing mmWaveLink Driver</h2>
<p>Once all the above Interfaces are implemented, Application need to fill these callbacks in <a class="el" href="structrl_client_cbs__t.html">rlClientCbs_t</a> and Initialize mmWaveLink by passing the client callbacks. Application also need to define where the mmWaveLink driver is running, for e.g, External Host in case of AWR1243 or MSS/DSS in case of xWR1642/xWR1843.</p>
<div class="fragment"><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a6a853581c4d17962776644e8d0eb5fbe">platform</a> = RL_PLATFORM_HOST;</div><div class="line">clientCtx.<a class="code" href="structrl_client_cbs__t.html#a1fc7fcab555a2a271d6bd8d6a68ba148">arDevType</a> = RL_AR_DEVICETYPE_12XX;</div><div class="line"></div><div class="line">retVal = <a class="code" href="group___device.html#ga0446f27557835061e73240244273a94d">rlDevicePowerOn</a>(deviceMap, clientCtx);</div></div><!-- fragment --><h2><a class="anchor" id="porting_be"></a>
Big Endian Support</h2>
<p>The mmWaveLink driver by default is enabled for Little Endian host. Support for Big Endian is provided as compile time option using a Pre-processor Macro MMWL_BIG_ENDIAN.<br />
 For memory optimizations, mmWaveLink doesn't swap the data elements in structure buffer. It is the responsibility of the application to swap multi byte data elements before passing the structure buffer to mmWaveLink API. Since SPI word-size is 16bit, Swap of 32 bit fields such as integer needs to be done at 16bit boundary. </p>
</div></div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
