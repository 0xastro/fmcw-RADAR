<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Sensor</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sensor</div>  </div>
</div><!--header-->
<div class="contents">

<p>mmwave radar RF/Sensor Configuration Module  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga71a59b160bf9b7a688bad4ed24fdc1f6"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga71a59b160bf9b7a688bad4ed24fdc1f6">rlSetChannelConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_chan_cfg__t.html">rlChanCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga71a59b160bf9b7a688bad4ed24fdc1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Rx and Tx Channel Configuration.  <a href="#ga71a59b160bf9b7a688bad4ed24fdc1f6">More...</a><br /></td></tr>
<tr class="separator:ga71a59b160bf9b7a688bad4ed24fdc1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf97bc35cf7acd9035b0fcadb00f3ad3"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gadf97bc35cf7acd9035b0fcadb00f3ad3">rlSetAdcOutConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_adc_out_cfg__t.html">rlAdcOutCfg_t</a> *data)</td></tr>
<tr class="memdesc:gadf97bc35cf7acd9035b0fcadb00f3ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets ADC Output Configuration.  <a href="#gadf97bc35cf7acd9035b0fcadb00f3ad3">More...</a><br /></td></tr>
<tr class="separator:gadf97bc35cf7acd9035b0fcadb00f3ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce12087a177926f8423b5bbc03b5254"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga0ce12087a177926f8423b5bbc03b5254">rlSetLowPowerModeConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_low_power_mode_cfg__t.html">rlLowPowerModeCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga0ce12087a177926f8423b5bbc03b5254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Low Power Mode Configuration.  <a href="#ga0ce12087a177926f8423b5bbc03b5254">More...</a><br /></td></tr>
<tr class="separator:ga0ce12087a177926f8423b5bbc03b5254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga958481166a629f374684c680904d5146"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga958481166a629f374684c680904d5146">rlRfInit</a> (rlUInt8_t deviceMap)</td></tr>
<tr class="memdesc:ga958481166a629f374684c680904d5146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the RF/Analog Subsystem.  <a href="#ga958481166a629f374684c680904d5146">More...</a><br /></td></tr>
<tr class="separator:ga958481166a629f374684c680904d5146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52dfab9a128a66d75e51bf4d741a424b"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga52dfab9a128a66d75e51bf4d741a424b">rlGetProfileConfig</a> (rlUInt8_t deviceMap, rlUInt16_t profileId, <a class="el" href="structrl_profile_cfg__t.html">rlProfileCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga52dfab9a128a66d75e51bf4d741a424b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Chirp profile Configuration.  <a href="#ga52dfab9a128a66d75e51bf4d741a424b">More...</a><br /></td></tr>
<tr class="separator:ga52dfab9a128a66d75e51bf4d741a424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd84f565083150a4c09b28f77cf4294"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaadd84f565083150a4c09b28f77cf4294">rlSetProfileConfig</a> (rlUInt8_t deviceMap, rlUInt16_t cnt, <a class="el" href="structrl_profile_cfg__t.html">rlProfileCfg_t</a> *data)</td></tr>
<tr class="memdesc:gaadd84f565083150a4c09b28f77cf4294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Chirp profile Configuration.  <a href="#gaadd84f565083150a4c09b28f77cf4294">More...</a><br /></td></tr>
<tr class="separator:gaadd84f565083150a4c09b28f77cf4294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf441aded0e05ef3139df6b1fe2a607ed"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaf441aded0e05ef3139df6b1fe2a607ed">rlGetChirpConfig</a> (rlUInt8_t deviceMap, rlUInt16_t chirpStartIdx, rlUInt16_t chirpEndIdx, <a class="el" href="structrl_chirp_cfg__t.html">rlChirpCfg_t</a> *data)</td></tr>
<tr class="memdesc:gaf441aded0e05ef3139df6b1fe2a607ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Chirp Configuration.  <a href="#gaf441aded0e05ef3139df6b1fe2a607ed">More...</a><br /></td></tr>
<tr class="separator:gaf441aded0e05ef3139df6b1fe2a607ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02aca718122731c4376e25eeefe6ed5e"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga02aca718122731c4376e25eeefe6ed5e">rlSetChirpConfig</a> (rlUInt8_t deviceMap, rlUInt16_t cnt, <a class="el" href="structrl_chirp_cfg__t.html">rlChirpCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga02aca718122731c4376e25eeefe6ed5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Chirp Configuration.  <a href="#ga02aca718122731c4376e25eeefe6ed5e">More...</a><br /></td></tr>
<tr class="separator:ga02aca718122731c4376e25eeefe6ed5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabedb7c157bd33891293ad2f99bad138"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaabedb7c157bd33891293ad2f99bad138">rlSetMultiChirpCfg</a> (rlUInt8_t deviceMap, rlUInt16_t cnt, <a class="el" href="structrl_chirp_cfg__t.html">rlChirpCfg_t</a> **data)</td></tr>
<tr class="memdesc:gaabedb7c157bd33891293ad2f99bad138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects chirp configuration to be programmed dynamically.  <a href="#gaabedb7c157bd33891293ad2f99bad138">More...</a><br /></td></tr>
<tr class="separator:gaabedb7c157bd33891293ad2f99bad138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7619b9244bcee4f602cf3f4f995394c8"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga7619b9244bcee4f602cf3f4f995394c8">rlGetFrameConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_frame_cfg__t.html">rlFrameCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga7619b9244bcee4f602cf3f4f995394c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Frame Configuration.  <a href="#ga7619b9244bcee4f602cf3f4f995394c8">More...</a><br /></td></tr>
<tr class="separator:ga7619b9244bcee4f602cf3f4f995394c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e5cbc25891714db321da3bfa0d2014"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaf1e5cbc25891714db321da3bfa0d2014">rlSetFrameConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_frame_cfg__t.html">rlFrameCfg_t</a> *data)</td></tr>
<tr class="memdesc:gaf1e5cbc25891714db321da3bfa0d2014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Frame Configuration.  <a href="#gaf1e5cbc25891714db321da3bfa0d2014">More...</a><br /></td></tr>
<tr class="separator:gaf1e5cbc25891714db321da3bfa0d2014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ce3a292815faac84048977ad29658cd"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga4ce3a292815faac84048977ad29658cd">rlSensorStart</a> (rlUInt8_t deviceMap)</td></tr>
<tr class="memdesc:ga4ce3a292815faac84048977ad29658cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers Transmission of Frames.  <a href="#ga4ce3a292815faac84048977ad29658cd">More...</a><br /></td></tr>
<tr class="separator:ga4ce3a292815faac84048977ad29658cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ed5478211ce88b74498e7978e200986"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga3ed5478211ce88b74498e7978e200986">rlSensorStop</a> (rlUInt8_t deviceMap)</td></tr>
<tr class="memdesc:ga3ed5478211ce88b74498e7978e200986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops Transmission of Frames.  <a href="#ga3ed5478211ce88b74498e7978e200986">More...</a><br /></td></tr>
<tr class="separator:ga3ed5478211ce88b74498e7978e200986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12e48d543221c5e1312a6bb73d209ffe"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga12e48d543221c5e1312a6bb73d209ffe">rlGetAdvFrameConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_adv_frame_cfg__t.html">rlAdvFrameCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga12e48d543221c5e1312a6bb73d209ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Advance Frame Configuration.  <a href="#ga12e48d543221c5e1312a6bb73d209ffe">More...</a><br /></td></tr>
<tr class="separator:ga12e48d543221c5e1312a6bb73d209ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga260d9e27b7b75c3cd33266a16f197ce7"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga260d9e27b7b75c3cd33266a16f197ce7">rlSetAdvFrameConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_adv_frame_cfg__t.html">rlAdvFrameCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga260d9e27b7b75c3cd33266a16f197ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Advance Frame Configuration.  <a href="#ga260d9e27b7b75c3cd33266a16f197ce7">More...</a><br /></td></tr>
<tr class="separator:ga260d9e27b7b75c3cd33266a16f197ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7436761acc24664420be7cc4561e3757"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga7436761acc24664420be7cc4561e3757">rlSetContModeConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_cont_mode_cfg__t.html">rlContModeCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga7436761acc24664420be7cc4561e3757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Continous mode Configuration.  <a href="#ga7436761acc24664420be7cc4561e3757">More...</a><br /></td></tr>
<tr class="separator:ga7436761acc24664420be7cc4561e3757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ff62ce5e024634fdc18df53dedf502"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga65ff62ce5e024634fdc18df53dedf502">rlEnableContMode</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_cont_mode_en__t.html">rlContModeEn_t</a> *data)</td></tr>
<tr class="memdesc:ga65ff62ce5e024634fdc18df53dedf502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable Continous mode.  <a href="#ga65ff62ce5e024634fdc18df53dedf502">More...</a><br /></td></tr>
<tr class="separator:ga65ff62ce5e024634fdc18df53dedf502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e0e3e2b0cf4ba51b6f14b42f3ae173"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gab1e0e3e2b0cf4ba51b6f14b42f3ae173">rlSetBpmCommonConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_bpm_common_cfg__t.html">rlBpmCommonCfg_t</a> *data)</td></tr>
<tr class="memdesc:gab1e0e3e2b0cf4ba51b6f14b42f3ae173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Binary Phase Modulation Common Configuration.  <a href="#gab1e0e3e2b0cf4ba51b6f14b42f3ae173">More...</a><br /></td></tr>
<tr class="separator:gab1e0e3e2b0cf4ba51b6f14b42f3ae173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ed1335fefa3bf89690418cfe6a379bd"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga8ed1335fefa3bf89690418cfe6a379bd">rlSetBpmChirpConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_bpm_chirp_cfg__t.html">rlBpmChirpCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga8ed1335fefa3bf89690418cfe6a379bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Binary Phase Modulation Chirp Configuration.  <a href="#ga8ed1335fefa3bf89690418cfe6a379bd">More...</a><br /></td></tr>
<tr class="separator:ga8ed1335fefa3bf89690418cfe6a379bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9588a836954d95b432b5755dad11243d"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga9588a836954d95b432b5755dad11243d">rlSetMultiBpmChirpConfig</a> (rlUInt8_t deviceMap, rlUInt16_t cnt, <a class="el" href="structrl_bpm_chirp_cfg__t.html">rlBpmChirpCfg_t</a> **data)</td></tr>
<tr class="memdesc:ga9588a836954d95b432b5755dad11243d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Binary Phase Modulation configuration for multiple Chirp.  <a href="#ga9588a836954d95b432b5755dad11243d">More...</a><br /></td></tr>
<tr class="separator:ga9588a836954d95b432b5755dad11243d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d3076ae4314c75470c5f4c0339ea8b"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gae5d3076ae4314c75470c5f4c0339ea8b">rlSetTestSourceConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_test_source__t.html">rlTestSource_t</a> *data)</td></tr>
<tr class="memdesc:gae5d3076ae4314c75470c5f4c0339ea8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the Test Source.  <a href="#gae5d3076ae4314c75470c5f4c0339ea8b">More...</a><br /></td></tr>
<tr class="separator:gae5d3076ae4314c75470c5f4c0339ea8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf47018653eb8cbd49adfccf0fc6ef9"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga0cf47018653eb8cbd49adfccf0fc6ef9">rlTestSourceEnable</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_test_source_enable__t.html">rlTestSourceEnable_t</a> *data)</td></tr>
<tr class="memdesc:ga0cf47018653eb8cbd49adfccf0fc6ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the Test Source.  <a href="#ga0cf47018653eb8cbd49adfccf0fc6ef9">More...</a><br /></td></tr>
<tr class="separator:ga0cf47018653eb8cbd49adfccf0fc6ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga335113f6e1e6c260dcd03e03a0932a1b"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga335113f6e1e6c260dcd03e03a0932a1b">rlRfGetTemperatureReport</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_temp_data__t.html">rlRfTempData_t</a> *data)</td></tr>
<tr class="memdesc:ga335113f6e1e6c260dcd03e03a0932a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Time and Temperature information report.  <a href="#ga335113f6e1e6c260dcd03e03a0932a1b">More...</a><br /></td></tr>
<tr class="separator:ga335113f6e1e6c260dcd03e03a0932a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39cf05329fbbf5783f53d8f80644e3ff"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga39cf05329fbbf5783f53d8f80644e3ff">rlRfDfeRxStatisticsReport</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_dfe_stat_report__t.html">rlDfeStatReport_t</a> *data)</td></tr>
<tr class="memdesc:ga39cf05329fbbf5783f53d8f80644e3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets Digital Front end statistics such as Residual DC, RMS power in I and Q chains for different Receive channels for different selected profiles. It also includes Cross correlation between I and Q chains.  <a href="#ga39cf05329fbbf5783f53d8f80644e3ff">More...</a><br /></td></tr>
<tr class="separator:ga39cf05329fbbf5783f53d8f80644e3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fa427b370b330f4c559793d2df92691"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga6fa427b370b330f4c559793d2df92691">rlRfDynamicPowerSave</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_dyn_pwr_save__t.html">rlDynPwrSave_t</a> *data)</td></tr>
<tr class="memdesc:ga6fa427b370b330f4c559793d2df92691"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Configure dynamic power saving feature.  <a href="#ga6fa427b370b330f4c559793d2df92691">More...</a><br /></td></tr>
<tr class="separator:ga6fa427b370b330f4c559793d2df92691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25ff76b7e26d26a184fd1c778cb4bf2f"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga25ff76b7e26d26a184fd1c778cb4bf2f">rlRfSetDeviceCfg</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_dev_cfg__t.html">rlRfDevCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga25ff76b7e26d26a184fd1c778cb4bf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Set different RadarSS device configurations  <a href="#ga25ff76b7e26d26a184fd1c778cb4bf2f">More...</a><br /></td></tr>
<tr class="separator:ga25ff76b7e26d26a184fd1c778cb4bf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed3f172d9edbee35db9520b87485f525"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaed3f172d9edbee35db9520b87485f525">rlSetGpAdcConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_gp_adc_cfg__t.html">rlGpAdcCfg_t</a> *data)</td></tr>
<tr class="memdesc:gaed3f172d9edbee35db9520b87485f525"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Configure GP ADC data parameters  <a href="#gaed3f172d9edbee35db9520b87485f525">More...</a><br /></td></tr>
<tr class="separator:gaed3f172d9edbee35db9520b87485f525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9450d508e0fa2857f8f9cb6b5004ecc"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaf9450d508e0fa2857f8f9cb6b5004ecc">rlRfSetPhaseShiftConfig</a> (rlUInt8_t deviceMap, rlUInt16_t cnt, <a class="el" href="structrl_rf_phase_shift_cfg__t.html">rlRfPhaseShiftCfg_t</a> *data)</td></tr>
<tr class="memdesc:gaf9450d508e0fa2857f8f9cb6b5004ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable phase shift configurations per chirp in each of the TXs.  <a href="#gaf9450d508e0fa2857f8f9cb6b5004ecc">More...</a><br /></td></tr>
<tr class="separator:gaf9450d508e0fa2857f8f9cb6b5004ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e53c805ac1b08ec8939dfe3205fe359"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga9e53c805ac1b08ec8939dfe3205fe359">rlRfSetPALoopbackConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_p_a_loopback_cfg__t.html">rlRfPALoopbackCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga9e53c805ac1b08ec8939dfe3205fe359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable PA loopback for all enabled profiles.  <a href="#ga9e53c805ac1b08ec8939dfe3205fe359">More...</a><br /></td></tr>
<tr class="separator:ga9e53c805ac1b08ec8939dfe3205fe359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78dfcfa4b7fb299434d22edcedb4746d"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga78dfcfa4b7fb299434d22edcedb4746d">rlRfSetPSLoopbackConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_p_s_loopback_cfg__t.html">rlRfPSLoopbackCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga78dfcfa4b7fb299434d22edcedb4746d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable Phase shift loopback for all enabled profiles.  <a href="#ga78dfcfa4b7fb299434d22edcedb4746d">More...</a><br /></td></tr>
<tr class="separator:ga78dfcfa4b7fb299434d22edcedb4746d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd9d2dcea706ab65fe6b949e2008c6ed"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gafd9d2dcea706ab65fe6b949e2008c6ed">rlRfSetIFLoopbackConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_i_f_loopback_cfg__t.html">rlRfIFLoopbackCfg_t</a> *data)</td></tr>
<tr class="memdesc:gafd9d2dcea706ab65fe6b949e2008c6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable RF IF loopback for all enabled profiles. This is used for debug to check if both TX and RX chains are working correctly.  <a href="#gafd9d2dcea706ab65fe6b949e2008c6ed">More...</a><br /></td></tr>
<tr class="separator:gafd9d2dcea706ab65fe6b949e2008c6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76d9fa9dcd3af870a2bb46f6f1b5e8f2"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga76d9fa9dcd3af870a2bb46f6f1b5e8f2">rlRfSetProgFiltCoeffRam</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_prog_filt_coeff__t.html">rlRfProgFiltCoeff_t</a> *data)</td></tr>
<tr class="memdesc:ga76d9fa9dcd3af870a2bb46f6f1b5e8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Programmable Filter coefficient RAM.  <a href="#ga76d9fa9dcd3af870a2bb46f6f1b5e8f2">More...</a><br /></td></tr>
<tr class="separator:ga76d9fa9dcd3af870a2bb46f6f1b5e8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga935fe658cc0e519559c6f705dfeb9297"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga935fe658cc0e519559c6f705dfeb9297">rlRfSetProgFiltConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_prog_filt_conf__t.html">rlRfProgFiltConf_t</a> *data)</td></tr>
<tr class="memdesc:ga935fe658cc0e519559c6f705dfeb9297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Programmable Filter configuration.  <a href="#ga935fe658cc0e519559c6f705dfeb9297">More...</a><br /></td></tr>
<tr class="separator:ga935fe658cc0e519559c6f705dfeb9297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c3ef75c1d3da0a4134f6929107930e8"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga8c3ef75c1d3da0a4134f6929107930e8">rlRfSetMiscConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_misc_conf__t.html">rlRfMiscConf_t</a> *data)</td></tr>
<tr class="memdesc:ga8c3ef75c1d3da0a4134f6929107930e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets misc feature such as per chirp phase shifter.  <a href="#ga8c3ef75c1d3da0a4134f6929107930e8">More...</a><br /></td></tr>
<tr class="separator:ga8c3ef75c1d3da0a4134f6929107930e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ff25a87cf2f34635bb469d3df1d48ed"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga0ff25a87cf2f34635bb469d3df1d48ed">rlRfSetCalMonTimeUnitConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_cal_mon_time_unt_conf__t.html">rlRfCalMonTimeUntConf_t</a> *data)</td></tr>
<tr class="memdesc:ga0ff25a87cf2f34635bb469d3df1d48ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Calibration monitoring time unit.  <a href="#ga0ff25a87cf2f34635bb469d3df1d48ed">More...</a><br /></td></tr>
<tr class="separator:ga0ff25a87cf2f34635bb469d3df1d48ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012ff7b3e35f35373169b62e4227ce06"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga012ff7b3e35f35373169b62e4227ce06">rlRfSetCalMonFreqLimitConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_cal_mon_freq_limit_conf__t.html">rlRfCalMonFreqLimitConf_t</a> *data)</td></tr>
<tr class="memdesc:ga012ff7b3e35f35373169b62e4227ce06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Calibration monitoring Frequency Limit.  <a href="#ga012ff7b3e35f35373169b62e4227ce06">More...</a><br /></td></tr>
<tr class="separator:ga012ff7b3e35f35373169b62e4227ce06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0c70e4c766a79ec281f969d0c61561"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gabc0c70e4c766a79ec281f969d0c61561">rlRfInitCalibConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_init_cal_conf__t.html">rlRfInitCalConf_t</a> *data)</td></tr>
<tr class="memdesc:gabc0c70e4c766a79ec281f969d0c61561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set RF Init Calibration Mask bits and report type.  <a href="#gabc0c70e4c766a79ec281f969d0c61561">More...</a><br /></td></tr>
<tr class="separator:gabc0c70e4c766a79ec281f969d0c61561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab47b62709a01f0ba5bdcf3f804dd5a1a"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gab47b62709a01f0ba5bdcf3f804dd5a1a">rlRfRunTimeCalibConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_run_time_calib_conf__t.html">rlRunTimeCalibConf_t</a> *data)</td></tr>
<tr class="memdesc:gab47b62709a01f0ba5bdcf3f804dd5a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set RF one time &amp; periodic calibration of various RF/analog aspects and trigger.  <a href="#gab47b62709a01f0ba5bdcf3f804dd5a1a">More...</a><br /></td></tr>
<tr class="separator:gab47b62709a01f0ba5bdcf3f804dd5a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae35c3687d353c0fb6ad2a9cc08ccff3c"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gae35c3687d353c0fb6ad2a9cc08ccff3c">rlRxGainTempLutSet</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rx_gain_temp_lut_data__t.html">rlRxGainTempLutData_t</a> *data)</td></tr>
<tr class="memdesc:gae35c3687d353c0fb6ad2a9cc08ccff3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite RX gain temperature Lookup Table(LUT) in Radar SS.  <a href="#gae35c3687d353c0fb6ad2a9cc08ccff3c">More...</a><br /></td></tr>
<tr class="separator:gae35c3687d353c0fb6ad2a9cc08ccff3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae129023dfe4ed79d5df1c1001ada7985"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gae129023dfe4ed79d5df1c1001ada7985">rlTxGainTempLutSet</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_tx_gain_temp_lut_data__t.html">rlTxGainTempLutData_t</a> *data)</td></tr>
<tr class="memdesc:gae129023dfe4ed79d5df1c1001ada7985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrites TX gain temperature based Lookup table (LUT)  <a href="#gae129023dfe4ed79d5df1c1001ada7985">More...</a><br /></td></tr>
<tr class="separator:gae129023dfe4ed79d5df1c1001ada7985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga938c6847f8a19336019883723c1e214c"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga938c6847f8a19336019883723c1e214c">rlRfTxFreqPwrLimitConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_tx_freq_pwr_limit_mon_conf__t.html">rlRfTxFreqPwrLimitMonConf_t</a> *data)</td></tr>
<tr class="memdesc:ga938c6847f8a19336019883723c1e214c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the limits for RF frequency transmission for each TX and also TX power limits.  <a href="#ga938c6847f8a19336019883723c1e214c">More...</a><br /></td></tr>
<tr class="separator:ga938c6847f8a19336019883723c1e214c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26c4e8543f1b2c6acdab8714e77220d7"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga26c4e8543f1b2c6acdab8714e77220d7">rlSetLoopBckBurstCfg</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_loopback_burst__t.html">rlLoopbackBurst_t</a> *data)</td></tr>
<tr class="memdesc:ga26c4e8543f1b2c6acdab8714e77220d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API is used to introduce loopback chirps within the functional frames.  <a href="#ga26c4e8543f1b2c6acdab8714e77220d7">More...</a><br /></td></tr>
<tr class="separator:ga26c4e8543f1b2c6acdab8714e77220d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga894bc8ce4536062a05aac4248334c964"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga894bc8ce4536062a05aac4248334c964">rlSetDynChirpCfg</a> (rlUInt8_t deviceMap, rlUInt16_t segCnt, <a class="el" href="structrl_dyn_chirp_cfg__t.html">rlDynChirpCfg_t</a> **data)</td></tr>
<tr class="memdesc:ga894bc8ce4536062a05aac4248334c964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects chirp configuration to be programmed dynamically.  <a href="#ga894bc8ce4536062a05aac4248334c964">More...</a><br /></td></tr>
<tr class="separator:ga894bc8ce4536062a05aac4248334c964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24c37a764127e473cfa9c81320b31e9"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gac24c37a764127e473cfa9c81320b31e9">rlSetDynChirpEn</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_dyn_chirp_en_cfg__t.html">rlDynChirpEnCfg_t</a> *data)</td></tr>
<tr class="memdesc:gac24c37a764127e473cfa9c81320b31e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers copy of chirp config from SW to HW RAM.  <a href="#gac24c37a764127e473cfa9c81320b31e9">More...</a><br /></td></tr>
<tr class="separator:gac24c37a764127e473cfa9c81320b31e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed333a050ab0ff53b5ab5a808e715a5c"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gaed333a050ab0ff53b5ab5a808e715a5c">rlRfCalibDataStore</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_calibration_data__t.html">rlCalibrationData_t</a> *data)</td></tr>
<tr class="memdesc:gaed333a050ab0ff53b5ab5a808e715a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read calibration data from the device.  <a href="#gaed333a050ab0ff53b5ab5a808e715a5c">More...</a><br /></td></tr>
<tr class="separator:gaed333a050ab0ff53b5ab5a808e715a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f501504c14a199cb1c9a7073e545acd"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga0f501504c14a199cb1c9a7073e545acd">rlRfCalibDataRestore</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_calibration_data__t.html">rlCalibrationData_t</a> *data)</td></tr>
<tr class="memdesc:ga0f501504c14a199cb1c9a7073e545acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects calibration data to the device.  <a href="#ga0f501504c14a199cb1c9a7073e545acd">More...</a><br /></td></tr>
<tr class="separator:ga0f501504c14a199cb1c9a7073e545acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga401d0fb21dcf7d34bea938b2cd74e5ba"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga401d0fb21dcf7d34bea938b2cd74e5ba">rlRfInterRxGainPhaseConfig</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_inter_rx_gain_ph_conf__t.html">rlInterRxGainPhConf_t</a> *data)</td></tr>
<tr class="memdesc:ga401d0fb21dcf7d34bea938b2cd74e5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets different Rx gain/phase offset.  <a href="#ga401d0fb21dcf7d34bea938b2cd74e5ba">More...</a><br /></td></tr>
<tr class="separator:ga401d0fb21dcf7d34bea938b2cd74e5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c4baf29d7b1cfb475052cf9a432b83"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga67c4baf29d7b1cfb475052cf9a432b83">rlGetRfBootupStatus</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_boot_status_cfg__t.html">rlRfBootStatusCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga67c4baf29d7b1cfb475052cf9a432b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get radarSS bootup status.  <a href="#ga67c4baf29d7b1cfb475052cf9a432b83">More...</a><br /></td></tr>
<tr class="separator:ga67c4baf29d7b1cfb475052cf9a432b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b6120aed27414c89bc5d27a0e9a22d6"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga3b6120aed27414c89bc5d27a0e9a22d6">rlSetInterChirpBlkCtrl</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_inter_chirp_blk_ctrl_cfg__t.html">rlInterChirpBlkCtrlCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga3b6120aed27414c89bc5d27a0e9a22d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Inter-chip turn on and turn off times or various RF blocks.  <a href="#ga3b6120aed27414c89bc5d27a0e9a22d6">More...</a><br /></td></tr>
<tr class="separator:ga3b6120aed27414c89bc5d27a0e9a22d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0ac5048a8bc47744a685c8db2b9a3e7"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#gad0ac5048a8bc47744a685c8db2b9a3e7">rlSetSubFrameStart</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_sub_frame_start_cfg__t.html">rlSubFrameStartCfg_t</a> *data)</td></tr>
<tr class="memdesc:gad0ac5048a8bc47744a685c8db2b9a3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers the next sub-frame in software triggered sub-frame mode.  <a href="#gad0ac5048a8bc47744a685c8db2b9a3e7">More...</a><br /></td></tr>
<tr class="separator:gad0ac5048a8bc47744a685c8db2b9a3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00f3f0bee9ac7b8f6e35b8df1658158d"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga00f3f0bee9ac7b8f6e35b8df1658158d">rlRfPhShiftCalibDataStore</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_ph_shift_calibration_data__t.html">rlPhShiftCalibrationData_t</a> *data)</td></tr>
<tr class="memdesc:ga00f3f0bee9ac7b8f6e35b8df1658158d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read calibration data from the device.  <a href="#ga00f3f0bee9ac7b8f6e35b8df1658158d">More...</a><br /></td></tr>
<tr class="separator:ga00f3f0bee9ac7b8f6e35b8df1658158d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8983749694adc19bcc2fdf9144cfa0a4"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga8983749694adc19bcc2fdf9144cfa0a4">rlRfPhShiftCalibDataRestore</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_ph_shift_calibration_data__t.html">rlPhShiftCalibrationData_t</a> *data)</td></tr>
<tr class="memdesc:ga8983749694adc19bcc2fdf9144cfa0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Injects phase shifter calibration data to the device.  <a href="#ga8983749694adc19bcc2fdf9144cfa0a4">More...</a><br /></td></tr>
<tr class="separator:ga8983749694adc19bcc2fdf9144cfa0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga333b50fae881b6e9de6700be35e3836e"><td class="memItemLeft" align="right" valign="top">MMWL_EXPORT rlReturnVal_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___sensor.html#ga333b50fae881b6e9de6700be35e3836e">rlGetRfDieId</a> (rlUInt8_t deviceMap, <a class="el" href="structrl_rf_die_id_cfg__t.html">rlRfDieIdCfg_t</a> *data)</td></tr>
<tr class="memdesc:ga333b50fae881b6e9de6700be35e3836e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device die ID status.  <a href="#ga333b50fae881b6e9de6700be35e3836e">More...</a><br /></td></tr>
<tr class="separator:ga333b50fae881b6e9de6700be35e3836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>mmwave radar RF/Sensor Configuration Module </p>
<div class="image">
<img src="mmwave_frontend.png" alt="mmwave_frontend.png"/>
</div>
<p>The RF/Sensor Configuration module controls the different HW blocks inside mmWave Front end. mmWave Front End has below key blocks</p><ol type="1">
<li>Chirp sequencer (Radar Timing Engine) - This block is responsible for constructing the sequence of FMCW chirps or frames and programming the timing engine</li>
<li>Rx/Tx Channel - This defines how many Rx and Tx channel needs to be enabled. Also it defines how to configure the mmWave front end in cascade mode for Imaging Radar</li>
<li>Rx Analog Chain - This defines how the received signal is mixed and how different filters in the chain can be configured</li>
<li>ADC and Digital Front End Configuration - This defines how the IF data is digitized and how it is sampled for further processing in the DSP or Hardware Accelerator. Same ADC data can be sent over LVDS/CSI2 interface to an extenal processor</li>
</ol>
<p>The Sensor Control APIs needs to be called by application in below sequence </p><h2>Initial/Static Configuration</h2>
<p>Application should first configure the mmWave Front end or Radar SS with below Static configurations</p><ul>
<li>Channel Configuration - <a class="el" href="group___sensor.html#ga71a59b160bf9b7a688bad4ed24fdc1f6">rlSetChannelConfig</a></li>
<li>ADC output Configuration - <a class="el" href="group___sensor.html#gadf97bc35cf7acd9035b0fcadb00f3ad3">rlSetAdcOutConfig</a></li>
<li>Low power mode Configuration - <a class="el" href="group___sensor.html#ga0ce12087a177926f8423b5bbc03b5254">rlSetLowPowerModeConfig</a></li>
</ul>
<h2>Initialization and Calibration</h2>
<p>After initial static configurations, application should initialize RF and shall wait for calibration complete Asynchornous event RL_RF_AE_INITCALIBSTATUS_SB</p><ul>
<li><a class="el" href="group___sensor.html#ga958481166a629f374684c680904d5146">rlRfInit</a></li>
</ul>
<h2>FMCW chirp Configuration</h2>
<p>After RF initilization, Application can configure chirps and frame using below APIs</p><ul>
<li>Profile Configuration - <a class="el" href="group___sensor.html#gaadd84f565083150a4c09b28f77cf4294">rlSetProfileConfig</a></li>
<li>Chirp Configuraiton - <a class="el" href="group___sensor.html#ga02aca718122731c4376e25eeefe6ed5e">rlSetChirpConfig</a></li>
<li><p class="startli">Frame Configuration - <a class="el" href="group___sensor.html#gaf1e5cbc25891714db321da3bfa0d2014">rlSetFrameConfig</a> or rlSetAdvFrameConfig Note about HW SYNC_IN pulse in hardware triggered mode</p>
<p class="startli">a. The SYNC_IN pulse must not arrive before the frame end boundary b. If frame trigger delay is used with hardware triggered mode, then external SYNC_IN pulse periodicity should take care of the configured frame trigger delay and frame periodicity. The external pulse should be issued only after the sum total of frame trigger delay and frame periodicity. See figure below </p><div class="image">
<img src="mmwave_hwsyncincareabout.png" alt="mmwave_hwsyncincareabout.png"/>
</div>
<p> c. The inter frame blank time should be at least 250 uS(100 uS for frame preparation and 150 uS for any calibration updates to hardware). Add 150 uS to inter-frame blank time for test source configuration if test source is enabled.</p>
</li>
</ul>
<h2>Frame Trigger</h2>
<p>After All the configuration, Application can use Sensor Start API to start Frame and shall wait for Frame Ready Asynchronous event RL_RF_AE_FRAME_TRIGGER_RDY_SB</p><ul>
<li><a class="el" href="group___sensor.html#ga4ce3a292815faac84048977ad29658cd">rlSensorStart</a></li>
</ul>
<h2>Below is the list of advance features in mmWave Front end</h2>
<h2>Advance Frame</h2>
<p>Legacy frame config API <a class="el" href="group___sensor.html#gaf1e5cbc25891714db321da3bfa0d2014">rlSetFrameConfig</a> supports looping of the same FMCW frame. In order to configure multiple FMCW frames with different chirp profiles, user needs to use <a class="el" href="group___sensor.html#ga260d9e27b7b75c3cd33266a16f197ce7">rlSetAdvFrameConfig</a> API. Advance Frame consists of one or upto 4 Sub-Frames Each Sub-Frame consists of multiple bursts. Each burst consists of multiple chirps as shown in diagram below.<br />
 To enable Advance Frame, Application needs to follow below sequence</p><ul>
<li>Profile Configuration - <a class="el" href="group___sensor.html#gaadd84f565083150a4c09b28f77cf4294">rlSetProfileConfig</a></li>
<li>Chirp Configuraiton - <a class="el" href="group___sensor.html#ga02aca718122731c4376e25eeefe6ed5e">rlSetChirpConfig</a></li>
<li>Advance Frame Configuration - <a class="el" href="group___sensor.html#ga260d9e27b7b75c3cd33266a16f197ce7">rlSetAdvFrameConfig</a></li>
</ul>
<div class="image">
<img src="adv_frame_seq.png" alt="adv_frame_seq.png"/>
</div>
<h2>Dynamic Chirp Configuration</h2>
<p>Using Legacy chirp configuration API <a class="el" href="group___sensor.html#ga02aca718122731c4376e25eeefe6ed5e">rlSetChirpConfig</a>, chirps can't be re-configure without stopping the ongoing FMCW frame using <a class="el" href="group___sensor.html#ga3ed5478211ce88b74498e7978e200986">rlSensorStop</a> API. <br />
 If user needs to re-configure chirp during the frame, it needs to use Dynamic chirp config APIs. Once the API is received by mmWave Front end, it would re-configure the chirps for next FMCW frame. Dynamic Chirps can be defined using below APIs</p><ul>
<li>Dynamic Chirp Configuration - <a class="el" href="group___sensor.html#ga894bc8ce4536062a05aac4248334c964">rlSetDynChirpCfg</a></li>
<li>Enable Dynamic Chirps - <a class="el" href="group___sensor.html#gac24c37a764127e473cfa9c81320b31e9">rlSetDynChirpEn</a></li>
</ul>
<p>Diagram below shows the Dynamic Chirp behaviour. Note that since dynamic chirps are configured at run time, there is not error checks done on the input data. If input data is out of range or invalid, device might misbehave.</p>
<div class="image">
<img src="dyn_chip_seq.png" alt="dyn_chip_seq.png"/>
</div>
<h2>Calibration</h2>
<p>TI mmWave Front end includes built-in processor that is programmed by TI to handle RF calibrations and functional safety monitoring. The RF calibrations ensure that the performance of the device is maintained across temperature and process corners</p>
<ol type="1">
<li>Some of the calibrations are just temperature and process based look-up-tables, which are used to update the RF/Analog components</li>
<li>Built-in temperature sensors enable the device to monitor the temperature every few seconds and update the relevant components accordingly</li>
</ol>
<p>Below is the list of calibrations and corresponding duration in microseconds <br />
 Boot Time Calibration </p><a class="anchor" id="multi_row_1"></a>
<table class="doxtable">
<caption>Calibration Duration</caption>
<tr>
<th>Calibration </th><th>Duration(us) </th></tr>
<tr>
<td>APLL</td><td>330 </td></tr>
<tr>
<td>Synth VCO</td><td>1300 </td></tr>
<tr>
<td>LO DIST</td><td>12 </td></tr>
<tr>
<td>ADC DC </td><td>600 </td></tr>
<tr>
<td>HPF cutoff </td><td>3500 </td></tr>
<tr>
<td>LPF cut off </td><td>3200 </td></tr>
<tr>
<td>Peak detector</td><td>4200 </td></tr>
<tr>
<td>TX power (assumes 2 TX use-case)</td><td>6000 </td></tr>
<tr>
<td>RX gain </td><td>2300 </td></tr>
<tr>
<td>TX phase (not enabled in firmware)</td><td>150 </td></tr>
<tr>
<td>RX IQMM (Not applcicable for Real ADC mode)</td><td>32000 </td></tr>
</table>
<p>Run Time Calibration </p><a class="anchor" id="multi_row_2"></a>
<table class="doxtable">
<caption>Calibration Duration</caption>
<tr>
<th>Calibration </th><th>Duration(us) </th></tr>
<tr>
<td>APLL</td><td>150 </td></tr>
<tr>
<td>Synth VCO</td><td>300 </td></tr>
<tr>
<td>LO DIST</td><td>30 </td></tr>
<tr>
<td>Peak detector</td><td>500 </td></tr>
<tr>
<td>TX power (assumes 2 TX use-case)</td><td>800 </td></tr>
<tr>
<td>RX gain </td><td>30 </td></tr>
<tr>
<td>Application of calibration to hardware (This needs to be included always) </td><td>150 </td></tr>
</table>
<pre class="fragment"> Related Files
- rl_sensor.c</pre><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga65ff62ce5e024634fdc18df53dedf502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlEnableContMode </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_cont_mode_en__t.html">rlContModeEn_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable Continous mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Continous Mode enable/disable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function enables/disables the FMCW radar continous mode </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01291">1291</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga12e48d543221c5e1312a6bb73d209ffe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlGetAdvFrameConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_adv_frame_cfg__t.html">rlAdvFrameCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets Advance Frame Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- Container for Advance Frame Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function reads the advance frame properties of the device. </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01183">1183</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf441aded0e05ef3139df6b1fe2a607ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlGetChirpConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>chirpStartIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>chirpEndIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_chirp_cfg__t.html">rlChirpCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets Chirp Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chirpStartIdx</td><td>- Chirp Start Index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chirpEndIdx</td><td>- Chirp End Index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- Container for Chirp Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function gets the chirp configuration from the device. </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l00711">711</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga7619b9244bcee4f602cf3f4f995394c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlGetFrameConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_frame_cfg__t.html">rlFrameCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets Frame Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- Container for Frame Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function reads the frame properties of the device. </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01045">1045</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga52dfab9a128a66d75e51bf4d741a424b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlGetProfileConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>profileId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_profile_cfg__t.html">rlProfileCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets Chirp profile Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">profileId</td><td>- Profile Id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- Container for Profile Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function gets the FMCW radar chirp properties like FMCW slope, chirp duration, TX power etc. from the device. </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l00505">505</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga67c4baf29d7b1cfb475052cf9a432b83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlGetRfBootupStatus </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_boot_status_cfg__t.html">rlRfBootStatusCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get radarSS bootup status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- bootup status configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API gets the radarSS bootup status</p>
<dl class="section note"><dt>Note</dt><dd>: This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l03144">3144</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga333b50fae881b6e9de6700be35e3836e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlGetRfDieId </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_die_id_cfg__t.html">rlRfDieIdCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get device die ID status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- Die ID status</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API gets the device Die ID status</p>
<dl class="section note"><dt>Note</dt><dd>: This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l03424">3424</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f501504c14a199cb1c9a7073e545acd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfCalibDataRestore </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_calibration_data__t.html">rlCalibrationData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects calibration data to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Calibration data of 3 chunks stored at application space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API restores the calibration data which was stored previously using the rlCalibDataStore command. Application needs to feed in 3 chunks of calibration data.</p>
<dl class="section note"><dt>Note</dt><dd>: Once the calibration data is restored properly in radarSS SW RAM and validated, mmWave Front end would send asynchronous event RL_RF_AE_INITCALIBSTATUS_SB indicating the result of the calibrations based on Calib data sent by the application. </dd>
<dd>
: This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02970">2970</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaed333a050ab0ff53b5ab5a808e715a5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfCalibDataStore </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_calibration_data__t.html">rlCalibrationData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read calibration data from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Calibration data of 3 chunks which will filled by device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API reads the calibration data from the device which can be injected later using the rlCalibDataRestore command. RadarSS will return 3 chunks of calibration data.</p>
<dl class="section note"><dt>Note</dt><dd>: This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l03040">3040</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga39cf05329fbbf5783f53d8f80644e3ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfDfeRxStatisticsReport </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_dfe_stat_report__t.html">rlDfeStatReport_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets Digital Front end statistics such as Residual DC, RMS power in I and Q chains for different Receive channels for different selected profiles. It also includes Cross correlation between I and Q chains. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container of dfe receiver status report</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>Gets Digital Front end statistics such as Residual DC, RMS power in I and Q chains for different Receive channels for different selected profiles. It also includes Cross correlation between I and Q chains </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01637">1637</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga6fa427b370b330f4c559793d2df92691"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfDynamicPowerSave </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_dyn_pwr_save__t.html">rlDynPwrSave_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Configure dynamic power saving feature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container of dynamic power save information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>Configure dynamic power saving feature during Inter chirp Idle time by turning off various circuits such as Transmitter, Receiver and LO distribution blocks </p><dl class="section note"><dt>Note</dt><dd>: whether to enable dynamic power saving during inter-chirp IDLE times by turning off various circuits e.g. TX, RX, LO Distribution blocks. If Idle time + Tx start time &lt; 10us or Idle time &lt; 3.5us then inter-chirp dynamic power save option will be disabled, in that case, 15us of inter-burst idle time will be utilized to configure sequencer LO, TX and RX signal timings by firmware. </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01682">1682</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga335113f6e1e6c260dcd03e03a0932a1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfGetTemperatureReport </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_temp_data__t.html">rlRfTempData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets Time and Temperature information report. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>- Structure to store temperature report from all the temp sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function reads Temperature information from all temperature sensors in the device </p><dl class="section note"><dt>Note</dt><dd>: In IWR6843 ES1.0, only Tx0, Tx1, Tx2 and PM temperature sensors are supported, rest of the temperature sensors always reads zero </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01595">1595</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga958481166a629f374684c680904d5146"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfInit </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the RF/Analog Subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>Initializes the RF/Analog Subsystem. This triggers one time calibrations for APLL and synthesizer. Calibration can be enabled/disabled using Calibraton configuration APIs</p>
<dl class="section note"><dt>Note</dt><dd>: Once the calibration is complete, mmWave Front end would send asynchronous event RL_RF_AE_INITCALIBSTATUS_SB indicating the result of the initialization/calibrations </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01470">1470</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gabc0c70e4c766a79ec281f969d0c61561"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfInitCalibConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_init_cal_conf__t.html">rlRfInitCalConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set RF Init Calibration Mask bits and report type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- RF Init calib config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function configures RF Init calibration mask bits and report type. Normally, upon receiving rlRfInit API, the Radar SS performs all relevant initial calibrations. This step can be disabled by setting the corresponding bit in <a class="el" href="structrl_rf_init_cal_conf__t.html">rlRfInitCalConf_t</a> field to 0x0.If disabled, the host needs to send the calibration data using <a class="el" href="group___sensor.html#ga0f501504c14a199cb1c9a7073e545acd">rlRfCalibDataRestore</a> so that the RadarSS can operate using the injected calibration data</p>
<dl class="section note"><dt>Note</dt><dd>1 : Debug use: Each of these calibrations can be selectively disabled by issuing this message before rlRfInit API. </dd>
<dd>
2 : The APLL, SYNTH1 and SYNTH2 calibrations are always triggred by default on RF init command. </dd>
<dd>
3 : In IWR6843 ES1.0, only APLL, SYNTH1, SYNTH2 and LODIST calibrations are supported. </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02320">2320</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga401d0fb21dcf7d34bea938b2cd74e5ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfInterRxGainPhaseConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_inter_rx_gain_ph_conf__t.html">rlInterRxGainPhConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets different Rx gain/phase offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Inter RX gain, phase offset config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API can be used to induce different gain/phase offsets on the different RXs, for inter-RX mismatch compensation. </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l03109">3109</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8983749694adc19bcc2fdf9144cfa0a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfPhShiftCalibDataRestore </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_ph_shift_calibration_data__t.html">rlPhShiftCalibrationData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects phase shifter calibration data to the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Calibration data of number of TX channels enabled chunks stored at application space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API restores the phase shifter calibration data which was stored previously using the rlRfPhShiftCalibDataStore command. Application needs to feed number of TX channels enabled chunks of phase shifter calibration data. This is device specific feature, please refer data sheet. </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l03273">3273</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga00f3f0bee9ac7b8f6e35b8df1658158d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfPhShiftCalibDataStore </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_ph_shift_calibration_data__t.html">rlPhShiftCalibrationData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read calibration data from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Phase shift calibration data of number of TX channels enbled chunks which will filled by device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API reads the phase shifter calibration data from the device which can be injected later using the rlRfPhShifterCalibDataRestore command. RadarSS will return number of TX chunks of phase shifter calibration data.This is device specific feature, please refer data sheet. </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l03348">3348</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab47b62709a01f0ba5bdcf3f804dd5a1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfRunTimeCalibConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_run_time_calib_conf__t.html">rlRunTimeCalibConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set RF one time &amp; periodic calibration of various RF/analog aspects and trigger. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Runtime calibration config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function configures RF one time &amp; periodic calibration of various RF/analog aspects and trigger. The response is in the form of an asynchronous event. The calibration would be performed by Radar SS during while framing during any idle time slot of 200uS</p>
<dl class="section note"><dt>Note</dt><dd>1: This API must be called after rlSetProfileConfig </dd>
<dd>
2: This API should be issued when the device is not framing. </dd>
<dd>
3 : Only APLL, SYNTH1, SYNTH2 and LODIST run time calibrations are supported in IWR6843 ES1.0 device </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02365">2365</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga012ff7b3e35f35373169b62e4227ce06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetCalMonFreqLimitConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_cal_mon_freq_limit_conf__t.html">rlRfCalMonFreqLimitConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Calibration monitoring Frequency Limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- RF Calib Frequency Limit config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function configures limits on RF frequency transmission during calibration and monitoring</p>
<dl class="section note"><dt>Note</dt><dd>: This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02272">2272</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0ff25a87cf2f34635bb469d3df1d48ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetCalMonTimeUnitConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_cal_mon_time_unt_conf__t.html">rlRfCalMonTimeUntConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Calibration monitoring time unit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- RF Calib Monitoring Time unit config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function configures calibration monitoring time unit </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02229">2229</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga25ff76b7e26d26a184fd1c778cb4bf2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetDeviceCfg </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_dev_cfg__t.html">rlRfDevCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Set different RadarSS device configurations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Configuration parameter for AE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>Set different RadarSS device configurations. Enable and Configure asynchronous event direction for device. By default all asynchronous event are enabled and sent to the platform which issued the API. Below events can be configured to be received on different platform by using this API:<br />
[1.] CPU_FAULT [2.] ESM_FAULT [3.] ANALOG_FAULT Similarly all monitoring events can be configured to be received on specific platform using this API Below events can be disabled using this API:<br />
[1.] FRAME_START_ASYNC_EVENT [2.] FRAME_STOP_ASYNC_EVENT <br />
Enable[1]/Disable[0] RadarSS Watchdog, where by default it is disable. Configure CRC type for asynchronous event from RadarSS [0] 16Bit, [1] 32Bit, [2] 64Bit. </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01731">1731</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gafd9d2dcea706ab65fe6b949e2008c6ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetIFLoopbackConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_i_f_loopback_cfg__t.html">rlRfIFLoopbackCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable RF IF loopback for all enabled profiles. This is used for debug to check if both TX and RX chains are working correctly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- IF loopback configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function Enables/Disables RF IF loopback for all enabled profiles. This is used to debug the RX IF chain.</p>
<dl class="section note"><dt>Note</dt><dd>: This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02063">2063</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c3ef75c1d3da0a4134f6929107930e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetMiscConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_misc_conf__t.html">rlRfMiscConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets misc feature such as per chirp phase shifter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Misc configuration such as per chirp phase shifter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function enables misc feature such as per chirp phase shifter.This API is valid for devices for which phase shifter is enabled(AWR1243P, AWR1843). </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02191">2191</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9e53c805ac1b08ec8939dfe3205fe359"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetPALoopbackConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_p_a_loopback_cfg__t.html">rlRfPALoopbackCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable PA loopback for all enabled profiles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- PA loopback configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function Enables/Disables PA loopback for all enabled profiles. This is used for debug purpose that both the TX and RX paths are working properly</p>
<dl class="section note"><dt>Note</dt><dd>: This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01982">1982</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf9450d508e0fa2857f8f9cb6b5004ecc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetPhaseShiftConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_phase_shift_cfg__t.html">rlRfPhaseShiftCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable phase shift configurations per chirp in each of the TXs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>- Number of configurations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- phase shift enable/disable configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function configures the static phase shift configurations per chirp in each of the TXs. This API is applicable only in certain devices (please refer data sheet). This API will be honored after enabling per chirp phase shifter in rlRfSetMiscConfig.</p>
<dl class="section note"><dt>Note</dt><dd>1 : Phase shifters are applied at the knee of the ramp. </dd>
<dd>
2 : This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01860">1860</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga76d9fa9dcd3af870a2bb46f6f1b5e8f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetProgFiltCoeffRam </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_prog_filt_coeff__t.html">rlRfProgFiltCoeff_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Programmable Filter coefficient RAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- array of coefficients for the programmable filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function is used to program the coefficients for the external programmable filter. This API is applicable only in xWR1642/IWR6843/xWR1843.</p>
<dl class="section note"><dt>Note</dt><dd>1: The programmable filter is applicable in Complex 1X and Real-only output modes for sampling rates under 6.25 Msps (Complex 1X) and under 12.5 Msps (Real). This is to allow for a trade-off between digital filter chain setting time and close-in anti-alias attenuation. A real-coefficient FIR with up to 26 taps (16-bit coefficients) is supported in the Complex 1X output mode, and a real-coefficient FIR with up to 20 taps (16-bit coefficients) in supported in the Real output mode. </dd>
<dd>
2: This API should be issued before rlSetProfileConfig. </dd>
<dd>
3: This API should not be issued when frames are ongoing. </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02110">2110</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga935fe658cc0e519559c6f705dfeb9297"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetProgFiltConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_prog_filt_conf__t.html">rlRfProgFiltConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Programmable Filter configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- programmable filter configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function selects programmable filter cofficient RAM and map it to configured profile ID.</p>
<dl class="section note"><dt>Note</dt><dd>1: This API is applicable only in xWR1642/IWR6843/xWR1843 </dd>
<dd>
2: This API should not be issued when frames are ongoing. </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02152">2152</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga78dfcfa4b7fb299434d22edcedb4746d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfSetPSLoopbackConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_p_s_loopback_cfg__t.html">rlRfPSLoopbackCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/Disable Phase shift loopback for all enabled profiles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Phase shift loopback configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function Enables/Disables Phase shift loopback for all enabled profiles.This is used to debug the TX (before the PA) and RX chains.</p>
<dl class="section note"><dt>Note</dt><dd>: This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02022">2022</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga938c6847f8a19336019883723c1e214c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRfTxFreqPwrLimitConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rf_tx_freq_pwr_limit_mon_conf__t.html">rlRfTxFreqPwrLimitMonConf_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the limits for RF frequency transmission for each TX and also TX power limits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Tx Rf freq and power limit config data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API sets the limits for RF frequency transmission for each TX and also TX power limits.</p>
<dl class="section note"><dt>Note</dt><dd>: This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02606">2606</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae35c3687d353c0fb6ad2a9cc08ccff3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlRxGainTempLutSet </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_rx_gain_temp_lut_data__t.html">rlRxGainTempLutData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrite RX gain temperature Lookup Table(LUT) in Radar SS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- RX gain Temperature LUT config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API can be used to overwrite the RX gain Lookup Table(LUT) for different temperature used in RadarSS.</p>
<dl class="section note"><dt>Note</dt><dd>1 : This API should be issued after profile configuration API. </dd>
<dd>
2 : This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02406">2406</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ce3a292815faac84048977ad29658cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSensorStart </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers Transmission of Frames. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function triggers the transmission of the frames as per the frame and chirp configuration If trigger mode is selected as SW API based trigger, mmWaveFront end would start chirp immediately after receiving this API. If trigger mode is HW SYNC IN pulse, it would wait for SYNC pulse</p>
<dl class="section note"><dt>Note</dt><dd>: Once the chirping starts, mmWave Front end would send asynchronous event RL_RF_AE_FRAME_TRIGGER_RDY_SB indicating the start of frame </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01378">1378</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3ed5478211ce88b74498e7978e200986"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSensorStop </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops Transmission of Frames. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function stops the transmission of the frames.</p>
<dl class="section note"><dt>Note</dt><dd>: Once the chirping stops, mmWave Front end would send asynchronous event RL_RF_AE_FRAME_END_SB indicating the stop of frame </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01423">1423</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gadf97bc35cf7acd9035b0fcadb00f3ad3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetAdcOutConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_adc_out_cfg__t.html">rlAdcOutCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets ADC Output Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for ADC Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function sets the static device configuration for the data format of the ADC and digital front end output. This is RAW ADC samples of IF signal and needs to be processed by HW accelerator or DSP. The ADC data can be sent to external Processor over High Speed Interface such as LVDS or CSI2. The ADC data size supported are 12, 14 and 16 bits and supported formats are Real, Complex 1x and Complex 2x. In Complex 1x, Image band is filtered out and only signal band is sampled in ADC. Where as in Complex 2x, Both Image and Signal band is sampled.<br />
 Complex baseband architecture results in better noise figure and is recommended.</p>
<dl class="section note"><dt>Note</dt><dd>At the same sampling frequency(Fs), Complex 1x would support IF bandwidth of Fs, where as real and complex 2x would provide IF bandwidth of upto Fs/2. </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l00152">152</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga260d9e27b7b75c3cd33266a16f197ce7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetAdvFrameConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_adv_frame_cfg__t.html">rlAdvFrameCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Advance Frame Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for Advance Frame Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function allows configuration of advance frame in mmWave Front end. Advance Frame is a sequence of chirps and how this sequnece needs to be repeated over time. User first need to define a profile and set of chirps(associated with a profile).<br />
 This function then defines how to sequence these chirps. Multiple chirps can be looped to create a burst. Multiple bursts can be grouped to create a sub-frame. Multiple sub-frames(Upto 4) can be grouped to create advance frame.<br />
 This function defines the advance frame properties like the number of burst in subframe, number of chirps and loops in a burst, sequence of subframes to be transmitted, number of frames to be transmitted, periodicity of the frame and the trigger method. </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01126">1126</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ed1335fefa3bf89690418cfe6a379bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetBpmChirpConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_bpm_chirp_cfg__t.html">rlBpmChirpCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Binary Phase Modulation Chirp Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for BPM chirp configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API defines static configurations related to BPM (Binary Phase Modulation) feature in each of the TXs</p>
<dl class="section note"><dt>Note</dt><dd>1: BPM values are applied at TX start time. </dd>
<dd>
2: This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l00240">240</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gab1e0e3e2b0cf4ba51b6f14b42f3ae173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetBpmCommonConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_bpm_common_cfg__t.html">rlBpmCommonCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Binary Phase Modulation Common Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for BPM common Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API defines static configurations related to BPM (Binary Phase Modulation) feature in each of the TXs. E.g. the source of the BPM pattern (one constant value for each chirp as defined, or intra-chirp pseudo random BPM pattern as found by a programmable LFSR or a programmable sequence inside each chirp), are defined here.</p>
<dl class="section note"><dt>Note</dt><dd>1: Different source of BPM is currently not supported, hence this API is not required to be called by application. </dd>
<dd>
2: This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l00198">198</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga71a59b160bf9b7a688bad4ed24fdc1f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetChannelConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_chan_cfg__t.html">rlChanCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Rx and Tx Channel Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for Channel Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function allows configuration of mmWave Front end for how many Receiver and Transmit channels need to be enabled. It also defines whether to to enable single mmWave device or multiple mmWave devices to realize a larger antenna array (multiple is applicable only in AWR1243). This is applicable for given power cycle.</p>
<dl class="section note"><dt>Note</dt><dd>This is global configuration for transmit channels. Later one can chose which transmit channel to be used for each chirp using Chirp configuaration API. For e.g - If Chirp 0, uses TX0 and TX1, and Chirp 1 uses TX1 and TX2, One need to enable TX0, TX1 and TX2 in this API. Based on the configuration, mmWave Front would do necessary calibration before the transmit channel is used to transmit chirps</dd></dl>
<p><a class="el" href="group___sensor.html#ga02aca718122731c4376e25eeefe6ed5e">rlSetChirpConfig</a> </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l00107">107</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga02aca718122731c4376e25eeefe6ed5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetChirpConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_chirp_cfg__t.html">rlChirpCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Chirp Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>- Number of configurations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Array of Chirp Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function sets the chirp to chirp variations on top of the chirp profile. The User should first define a profile using rlSetProfileConfig. This function then configures the chirp by associating it with a particular profile defined in rlSetProfileConfig API. In addition to that user can define fine dither to the profile parameters using this API. The dithers used in this configuration are only additive on top of programmed parameters in rlSetProfileConfig. This API allows configuration of 1 or upto 512 chirps. Also it allows configuraiton of which Transmit channels to be used for each chirp.</p>
<dl class="section note"><dt>Note</dt><dd>1: One can set upto 512 unique chirps which can be stored in dedicated memory inside mmWave front end. Hence user doesn't need to program the chirps during run time. Also these chirps can be sequenced in a frame using rlSetFrameConfig to create a larger FMCW signal. </dd>
<dd>
2: If hardware triggered mode is used, the SYNC_IN pulse width should be less than the ON time of the frame (in case of legacy frame config mode) or the ON time of the burst (in case of advanced frame config mode). Also, the minimum pulse width of SYNC_IN should be 25 ns. </dd>
<dd>
3: If frame trigger delay is used with hardware triggered mode, then external SYNC_IN pulse periodicity should take care of the configured frame trigger delay and frame periodicity. The external pulse should be issued only after the sum total of frame trigger delay and frame periodicity.</dd></dl>
<p><a class="el" href="group___sensor.html#gaf1e5cbc25891714db321da3bfa0d2014">rlSetFrameConfig</a> </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l00587">587</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga7436761acc24664420be7cc4561e3757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetContModeConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_cont_mode_cfg__t.html">rlContModeCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Continous mode Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Continous mode Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function sets the FMCW radar continous mode properties like Start Freq, TX power etc. In continuous mode, the signal is not frequency modulated but has the same frequency over time. </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01252">1252</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga894bc8ce4536062a05aac4248334c964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetDynChirpCfg </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>segCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_dyn_chirp_cfg__t.html">rlDynChirpCfg_t</a> **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects chirp configuration to be programmed dynamically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segCnt</td><td>- number of segments for which application sends array of data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Dynamic chirp configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API can be used to dynamically change the chirp configuration while frames are on-going. The configuration will be stored in software and at rlDynChirpEnCfg API invocation radarSS copies these chirp configurations from SW RAM to HW RAM at the end of current on-going frame.</p>
<dl class="section note"><dt>Note</dt><dd>: The new feature of dynamic chirp configuaration to configuare 48 chirps in one API is not applicable in IWR6843. </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02693">2693</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gac24c37a764127e473cfa9c81320b31e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetDynChirpEn </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_dyn_chirp_en_cfg__t.html">rlDynChirpEnCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers copy of chirp config from SW to HW RAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Dynamic chirp enable configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API can be used to trigger the copy of chirp configuration from software to hardware RAM. The copy will be performed at the end of the ongoing frame. </p><dl class="section note"><dt>Note</dt><dd>User needs to invoke this API within inter-frame idle time, not at boundary of frame end. Since dynamic chirps are configured at run time, there is not error checks done on the input data. If input data is out of range or invalid, device might misbehave. </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02811">2811</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaf1e5cbc25891714db321da3bfa0d2014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetFrameConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_frame_cfg__t.html">rlFrameCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Frame Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for Frame Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function allows configuration of FMCW frame in mmWave Front end. A Frame is basically a sequence of chirps and how this sequnece needs to be repeated over time. User first need to define a profile and set of chirps(associated with a profile).<br />
 This function then defines how to sequence these chirps. The same chirp can be simply looped to create a large FMCW frame or multiple unique chirps cane be sequenced to create the frame. Chirp Start and end Index defines how to sequence them in a frame. <br />
 The API also allows configuration of number of frames to be transmitted, periodicity of the frame and the trigger method. The trigger method could be SW API based trigger or HW SYNC IN based trigger.</p>
<dl class="section note"><dt>Note</dt><dd>Frame could have multiple chirps associated with different profile, but number of samples need to be same in all the profiles. </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l00976">976</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaed3f172d9edbee35db9520b87485f525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetGpAdcConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_gp_adc_cfg__t.html">rlGpAdcCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Configure GP ADC data parameters </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Configuration parameter for GP ADC</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API enables the GPADC reads for external inputs (available only in xWR1642/IWR6843/ xWR1843). xWR1642/xWR1843 sends GP-ADC measurement data in async event RL_RF_AE_GPADC_MEAS_DATA_SB </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01772">1772</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b6120aed27414c89bc5d27a0e9a22d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetInterChirpBlkCtrl </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_inter_chirp_blk_ctrl_cfg__t.html">rlInterChirpBlkCtrlCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Inter-chip turn on and turn off times or various RF blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Inter chirp block control config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API programs the Inter-chip turn on and turn off times or various RF blocks </p><dl class="section note"><dt>Note</dt><dd>The minimum inter-chirp time should be greater than maximum of the following<ol type="1">
<li>abs(rx02RfTurnOffTime) + max(abs(rx02RfPreEnTime), abs(rx02RfTurnOnTime))</li>
<li>abs(rx13RfTurnOffTime) + max(abs(rx13RfPreEnTime), abs(rx13RfTurnOnTime))</li>
<li>abs(rx02BbTurnOffTime) + max(abs(rx02BbPreEnTime), abs(rx02BbTurnOnTime))</li>
<li>abs(rx13BbTurnOffTime) + max(abs(rx13BbPreEnTime), abs(rx13BbTurnOnTime))</li>
<li>abs(rxLoChainTurnOffTime) + abs(rxLoChainTurnOnTime)</li>
<li>abs(txLoChainTurnOffTime) + abs(txLoChainTurnOnTime) </li>
</ol>
</dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l03183">3183</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga26c4e8543f1b2c6acdab8714e77220d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetLoopBckBurstCfg </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_loopback_burst__t.html">rlLoopbackBurst_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API is used to introduce loopback chirps within the functional frames. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Loopback chirp config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API can be used to introduce loopback chirps within the functional frames. This loopback chirps will be introduced only if advanced frame configuration is used where user can define which sub-frame contains loopback chirps. The following loopback configuration will apply to one burst and user can program up to 16 different loopback configurations in 16 different bursts of a given sub-frame. User has to ensure that the corresponding sub-frame is defined in rlSetAdvFrameConfig and sufficient time is given to allow the loopback bursts to be transmitted.</p>
<dl class="section note"><dt>Note</dt><dd>1: If user desires to enable loopback chirps within functional frames, then this API should be issued before rlSetProfileConfig </dd>
<dd>
2: Only profile based phase shifter is supported in loopback configuration. Per-chirp phase shifter if enabled will not be reflected in loopback chirps. </dd>
<dd>
3: For the sub-frame in which loopback is desired, user should set numOfChirps per burst as 1 and can use numLoops per burst for multiple chirps in the burst. </dd>
<dd>
4: This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02654">2654</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0ce12087a177926f8423b5bbc03b5254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetLowPowerModeConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_low_power_mode_cfg__t.html">rlLowPowerModeCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Low Power Mode Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for Low power mode Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function sets the static device configurations of low power options. Sigma Delta ADC root sampling reduces to half the rate to save power in small IF bandwidth applications.</p>
<dl class="section note"><dt>Note</dt><dd>: Low power ADC mode is mandatory on 5 MHz part variant(for e.g. xWR1642), Normally if IF band width &lt;= 7.5MHz then low power mode setting is recommended. </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01335">1335</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9588a836954d95b432b5755dad11243d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetMultiBpmChirpConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_bpm_chirp_cfg__t.html">rlBpmChirpCfg_t</a> **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Binary Phase Modulation configuration for multiple Chirp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>- number of BPM chirp config data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- pointer to linked list/array of BPM chirp configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>Using this API application can configure multiple BPM chirp configuration in a single call. This API defines static configurations related to BPM (Binary Phase Modulation) feature in each of the TXs. </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l00283">283</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaabedb7c157bd33891293ad2f99bad138"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetMultiChirpCfg </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_chirp_cfg__t.html">rlChirpCfg_t</a> **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Injects chirp configuration to be programmed dynamically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>- number of chirps </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Pointer to Chirp configuration linked list/array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function sets the chirp to chirp variations on top of the chirp profile. The User should first define a profile using rlSetProfileConfig.<br />
 This function then configures the chirp by associating it with a particular profile defined in rlSetProfileConfig API. In addition to that user can define fine dither to the profile parameters using this API <br />
This API allows configuration of 1 or upto 512 chirps. Also it allows configuraiton of which Transmit channels to be used for each chirp.</p>
<dl class="section note"><dt>Note</dt><dd>One can set upto 512 unique chirps which can be stored in dedicated memory inside mmWave front end. Hence user doesn't need to program the chirps during run time. Also these chirps can be sequenced in a frame using rlSetFrameConfig to create a larger FMCW signal<br />
This API is similar to rlSetChirpConfig but gives the flexibility to pass the array of chirp configuration pointers, so chirp configuration memory need not be contiguous. </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l00849">849</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gaadd84f565083150a4c09b28f77cf4294"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetProfileConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rlUInt16_t&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_profile_cfg__t.html">rlProfileCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets Chirp profile Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnt</td><td>- Number of Profiles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Array of Profile Configuration data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This function sets the chirp profile in mmWave Front end. A profile is like a template which contains coarse information about FMCW signal such as start frequency, chirp slope, chirp duration, TX power etc. The API allows multiple profiles to be set together by passing the array of profile data along with count of profiles.</p>
<dl class="section note"><dt>Note</dt><dd>1: One can set upto 4 profiles. Each profile contains coarse inforamtion. Fine dithering can be added using chirp configuration API </dd>
<dd>
2: This API can be issued dynamically to change profile parameters. Few parameters which cannot be changed are<ol type="1">
<li>numAdcSamples</li>
<li>digOutSampleRate</li>
<li>Programmable filter coefficients in xWR1642/IWR6843/xWR1843</li>
</ol>
</dd></dl>
<p><a class="el" href="group___sensor.html#ga02aca718122731c4376e25eeefe6ed5e">rlSetChirpConfig</a> </p>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l00419">419</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gad0ac5048a8bc47744a685c8db2b9a3e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetSubFrameStart </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_sub_frame_start_cfg__t.html">rlSubFrameStartCfg_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers the next sub-frame in software triggered sub-frame mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Sub-frame start config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API triggers the next sub-frame in software triggered sub-frame mode</p>
<dl class="section note"><dt>Note</dt><dd>1: If the user wishes to trigger each sub-frame independently, then after advanced frame config, the rlSensorStart should be issued once using rlSensorStop. This does not start any sub-frames but it will prepare the hardware for sub-frame trigger. Next any subsequent sub-frame trigger will start the sub-frames. </dd>
<dd>
2: If the user wishes to use sub-frame trigger, he has to ensure that sub-frame trigger command is issued k*N times where k is the number of sub-frames in each frame and N is the number of frames. If the user wishes to stop frames in between, then he has to issue the rlSensorStop only after k*M triggers of sub-frame trigger command (where M is an integer). i.e. rlSensorStop can be issued only at frame boundaries. </dd>
<dd>
3: If software based sub-frame trigger mode is chosen by the user, watchdog feature will not be available. User has to ensure that the watchdog is disabled before enabling the software based sub-frame trigger mode. </dd>
<dd>
4: If sub-frame trigger or hardware trigger mode is used to trigger the frames/sub- frames and if frames need to be stopped before the specified number of frames, then the the frame stop command using rlSensorStop API should be issued while the frame is on-going. If the frames are stopped while the device is idle, it can lead to errors </dd>
<dd>
5: This API is not supported in IWR6843 ES1.0 </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l03235">3235</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae5d3076ae4314c75470c5f4c0339ea8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlSetTestSourceConfig </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_test_source__t.html">rlTestSource_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the Test Source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for Test source configuration</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API allows configuration of the Test Source in mmWave Front end. A Test source simulates 2 objects at certain position relative to the mmWave device and generates the RAW ADC data. It also simulates velocity of objects, relative position of TX and RX antennas.</p>
<dl class="section note"><dt>Note</dt><dd>1: This helps in checking the integrity of control and data path during development phase. API is meant to be used in development phase only and doesn't relate to any real use case. </dd>
<dd>
2: Test source is not characterized and tuned to 60GHz in IWR6843 ES1.0 device </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01513">1513</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga0cf47018653eb8cbd49adfccf0fc6ef9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlTestSourceEnable </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_test_source_enable__t.html">rlTestSourceEnable_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the Test Source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- Container for Test source enable parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>Enables the Test Source that is configured using <a class="el" href="group___sensor.html#gae5d3076ae4314c75470c5f4c0339ea8b">rlSetTestSourceConfig</a> API</p>
<dl class="section note"><dt>Note</dt><dd>: Test source is not characterized and tuned to 60GHz in IWR6843 ES1.0 device </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l01554">1554</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
<a class="anchor" id="gae129023dfe4ed79d5df1c1001ada7985"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rlReturnVal_t rlTxGainTempLutSet </td>
          <td>(</td>
          <td class="paramtype">rlUInt8_t&#160;</td>
          <td class="paramname"><em>deviceMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrl_tx_gain_temp_lut_data__t.html">rlTxGainTempLutData_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrites TX gain temperature based Lookup table (LUT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceMap</td><td>- Bitmap of devices to send the message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- TX gain Temperature LUT config</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rlReturnVal_t Success - 0, Failure - Error Code</dd></dl>
<p>This API can be used to overwrite the TX gain temperature LUT used in Radar SS. This API should be issued after profile configuration API.</p>
<dl class="section note"><dt>Note</dt><dd>: This API is not supported in IWR6843 ES1.0. </dd></dl>

<p>Definition at line <a class="el" href="rl__sensor_8c_source.html#l02506">2506</a> of file <a class="el" href="rl__sensor_8c_source.html">rl_sensor.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
