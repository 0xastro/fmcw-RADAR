<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>FFT Utilities</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">FFT Utilities</div>  </div>
</div><!--header-->
<div class="contents">

<p>The functions facilitate stage wise FFT.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad0f58e1c7dfd8ffa5c37aa3a012e5414"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#gad0f58e1c7dfd8ffa5c37aa3a012e5414">mmwavelib_dftSingleBin</a> (const uint32_t inBuf[restrict], const uint32_t sincos[restrict], uint64_t *restrict output, uint32_t length, uint32_t doppInd)</td></tr>
<tr class="memdesc:gad0f58e1c7dfd8ffa5c37aa3a012e5414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_dftSingleBin.  <a href="#gad0f58e1c7dfd8ffa5c37aa3a012e5414">More...</a><br /></td></tr>
<tr class="separator:gad0f58e1c7dfd8ffa5c37aa3a012e5414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09ac54ea25984994384c660c9d2ba1f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga09ac54ea25984994384c660c9d2ba1f8">mmwavelib_dftSingleBinWithWindow</a> (const uint32_t inBuf[restrict], const uint32_t sincos[restrict], const int32_t win[restrict], uint64_t *restrict output, uint32_t length, uint32_t doppInd)</td></tr>
<tr class="memdesc:ga09ac54ea25984994384c660c9d2ba1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_dftSingleBinWithWindow.  <a href="#ga09ac54ea25984994384c660c9d2ba1f8">More...</a><br /></td></tr>
<tr class="separator:ga09ac54ea25984994384c660c9d2ba1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad73a04108986ee793bf16261b790981f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#gad73a04108986ee793bf16261b790981f">mmwavelib_dftSingleBinWithWindow_ReIm</a> (const uint32_t inBuf[restrict], const uint32_t sincos[restrict], const int32_t win[restrict], uint64_t *restrict output, uint32_t length, uint32_t doppInd)</td></tr>
<tr class="memdesc:gad73a04108986ee793bf16261b790981f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_dftSingleBinWithWindow_ReIm.  <a href="#gad73a04108986ee793bf16261b790981f">More...</a><br /></td></tr>
<tr class="separator:gad73a04108986ee793bf16261b790981f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8ffc801081f734dd07a5d70106165ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#gac8ffc801081f734dd07a5d70106165ba">mmwavelib_dftSinCosTabelGen</a> (uint32_t dftLength, uint32_t *dftSinCosTbl)</td></tr>
<tr class="memdesc:gac8ffc801081f734dd07a5d70106165ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_dftSinCosTabelGen.  <a href="#gac8ffc801081f734dd07a5d70106165ba">More...</a><br /></td></tr>
<tr class="separator:gac8ffc801081f734dd07a5d70106165ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2de8e6b5ed556d0456cba95a15110cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#gac2de8e6b5ed556d0456cba95a15110cc">mmwavelib_fft16ptZeroPadded32x32</a> (const int32_t *restrict inp, const int32_t *restrict twiddle, int32_t *restrict temp, int32_t *restrict out, uint32_t numLines, uint32_t numSkipSamples)</td></tr>
<tr class="memdesc:gac2de8e6b5ed556d0456cba95a15110cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">mmwavelib_fft16ptZeroPadded32x32 Computes the 16pt FFT of vectors of length 8. The input vectors are assumed to be in transpose format (in inp). Hence the FFT can be thought of as operating along the columns of inp  <a href="#gac2de8e6b5ed556d0456cba95a15110cc">More...</a><br /></td></tr>
<tr class="separator:gac2de8e6b5ed556d0456cba95a15110cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga453fca8e41716837fcf9f0a0d454ad22"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga453fca8e41716837fcf9f0a0d454ad22">mmwavelib_gen_twiddle_fft16x16</a> (int16_t *w, int32_t n)</td></tr>
<tr class="memdesc:ga453fca8e41716837fcf9f0a0d454ad22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_gen_twiddle_fft16x16.  <a href="#ga453fca8e41716837fcf9f0a0d454ad22">More...</a><br /></td></tr>
<tr class="separator:ga453fca8e41716837fcf9f0a0d454ad22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49dbcbb1eb0456d44de4bb6fe8f0594b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga49dbcbb1eb0456d44de4bb6fe8f0594b">mmwavelib_gen_twiddle_fft16x16_imre_sa</a> (int16_t *w, int32_t n)</td></tr>
<tr class="memdesc:ga49dbcbb1eb0456d44de4bb6fe8f0594b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_gen_twiddle_fft16x16_imre_sa.  <a href="#ga49dbcbb1eb0456d44de4bb6fe8f0594b">More...</a><br /></td></tr>
<tr class="separator:ga49dbcbb1eb0456d44de4bb6fe8f0594b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa126b24e90cd56f52508047643bac2fc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#gaa126b24e90cd56f52508047643bac2fc">mmwavelib_gen_twiddle_smallfft_16x16</a> (int16_t *w, int32_t n)</td></tr>
<tr class="memdesc:gaa126b24e90cd56f52508047643bac2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_gen_twiddle_smallfft_16x16.  <a href="#gaa126b24e90cd56f52508047643bac2fc">More...</a><br /></td></tr>
<tr class="separator:gaa126b24e90cd56f52508047643bac2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab33fdc29ef57e309d6e75e4cb2dccf4d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#gab33fdc29ef57e309d6e75e4cb2dccf4d">mmwavelib_gen_twiddle_smallfft_16x16_imre_sa</a> (int16_t *w, int32_t n)</td></tr>
<tr class="memdesc:gab33fdc29ef57e309d6e75e4cb2dccf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_gen_twiddle_smallfft_16x16_imre_sa.  <a href="#gab33fdc29ef57e309d6e75e4cb2dccf4d">More...</a><br /></td></tr>
<tr class="separator:gab33fdc29ef57e309d6e75e4cb2dccf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b62b1ba79e28c8119c56526c023b067"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga1b62b1ba79e28c8119c56526c023b067">mmwavelib_gen_twiddle_largefft_16x16</a> (int16_t *w, int32_t n)</td></tr>
<tr class="memdesc:ga1b62b1ba79e28c8119c56526c023b067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_gen_twiddle_largefft_16x16.  <a href="#ga1b62b1ba79e28c8119c56526c023b067">More...</a><br /></td></tr>
<tr class="separator:ga1b62b1ba79e28c8119c56526c023b067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff018510f058d0c6e9e10776e4e660b6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#gaff018510f058d0c6e9e10776e4e660b6">mmwavelib_gen_twiddle_largefft_16x16_imre_sa</a> (int16_t *w, int32_t n)</td></tr>
<tr class="memdesc:gaff018510f058d0c6e9e10776e4e660b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_gen_twiddle_largefft_16x16_imre_sa.  <a href="#gaff018510f058d0c6e9e10776e4e660b6">More...</a><br /></td></tr>
<tr class="separator:gaff018510f058d0c6e9e10776e4e660b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44eb5f439689d90d3f669d198ec4529f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga44eb5f439689d90d3f669d198ec4529f">mmwavelib_gen_twiddle_largefftUp8k_16x16</a> (int16_t *w, int32_t n)</td></tr>
<tr class="memdesc:ga44eb5f439689d90d3f669d198ec4529f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_gen_twiddle_largefftUp8k_16x16.  <a href="#ga44eb5f439689d90d3f669d198ec4529f">More...</a><br /></td></tr>
<tr class="separator:ga44eb5f439689d90d3f669d198ec4529f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e66c7b243f46f35243eab84212f3939"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga1e66c7b243f46f35243eab84212f3939">mmwavelib_gen_twiddle_fft32x32</a> (int32_t *w, int32_t n)</td></tr>
<tr class="memdesc:ga1e66c7b243f46f35243eab84212f3939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_gen_twiddle_fft32x32.  <a href="#ga1e66c7b243f46f35243eab84212f3939">More...</a><br /></td></tr>
<tr class="separator:ga1e66c7b243f46f35243eab84212f3939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb6b6a95576d7c3f458ce4a47ce04f9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga8fb6b6a95576d7c3f458ce4a47ce04f9">mmwavelib_gen_twiddle_smallfft_32x32</a> (int32_t *w, int32_t n)</td></tr>
<tr class="memdesc:ga8fb6b6a95576d7c3f458ce4a47ce04f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_gen_twiddle_smallfft_32x32.  <a href="#ga8fb6b6a95576d7c3f458ce4a47ce04f9">More...</a><br /></td></tr>
<tr class="separator:ga8fb6b6a95576d7c3f458ce4a47ce04f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c3ba7d003aa3775901474bb8bcc526d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga0c3ba7d003aa3775901474bb8bcc526d">mmwavelib_gen_twiddle_largefft_32x32</a> (int32_t *w, int32_t n)</td></tr>
<tr class="memdesc:ga0c3ba7d003aa3775901474bb8bcc526d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_gen_twiddle_largefft_32x32.  <a href="#ga0c3ba7d003aa3775901474bb8bcc526d">More...</a><br /></td></tr>
<tr class="separator:ga0c3ba7d003aa3775901474bb8bcc526d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa28da06760bfe26ceedc3057039008a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#gaa28da06760bfe26ceedc3057039008a2">mmwavelib_windowCoef_gen</a> (void *winCoef, uint32_t windowDatumType, float initR, float initI, uint32_t winCoefLen, int32_t Qformat, uint32_t winType)</td></tr>
<tr class="memdesc:gaa28da06760bfe26ceedc3057039008a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_windowCoef_gen.  <a href="#gaa28da06760bfe26ceedc3057039008a2">More...</a><br /></td></tr>
<tr class="separator:gaa28da06760bfe26ceedc3057039008a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e93be64cedae950adb6a15e9bb1c08b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga4e93be64cedae950adb6a15e9bb1c08b">mmwavelib_windowing16x16</a> (int16_t inp[restrict], const int16_t win[restrict], uint32_t len)</td></tr>
<tr class="memdesc:ga4e93be64cedae950adb6a15e9bb1c08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_windowing16xl6.  <a href="#ga4e93be64cedae950adb6a15e9bb1c08b">More...</a><br /></td></tr>
<tr class="separator:ga4e93be64cedae950adb6a15e9bb1c08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03eec284913bf5a1a4508f87b0d5c570"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga03eec284913bf5a1a4508f87b0d5c570">mmwavelib_windowing16x32</a> (const int16_t inp[restrict], const int32_t win[restrict], int32_t out[restrict], uint32_t len)</td></tr>
<tr class="memdesc:ga03eec284913bf5a1a4508f87b0d5c570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_windowing16x32.  <a href="#ga03eec284913bf5a1a4508f87b0d5c570">More...</a><br /></td></tr>
<tr class="separator:ga03eec284913bf5a1a4508f87b0d5c570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a43ad3c5e94d1ac841d822f73196e01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga7a43ad3c5e94d1ac841d822f73196e01">mmwavelib_windowing16x32_IQswap</a> (const int16_t inp[restrict], const int32_t win[restrict], int32_t out[restrict], uint32_t len)</td></tr>
<tr class="memdesc:ga7a43ad3c5e94d1ac841d822f73196e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_windowing16x32_IQswap.  <a href="#ga7a43ad3c5e94d1ac841d822f73196e01">More...</a><br /></td></tr>
<tr class="separator:ga7a43ad3c5e94d1ac841d822f73196e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga424bff8de82528e9318cd24995aa0fba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga424bff8de82528e9318cd24995aa0fba">mmwavelib_windowing16x16_evenlen</a> (int16_t inp[restrict], const int16_t win[restrict], uint32_t len)</td></tr>
<tr class="memdesc:ga424bff8de82528e9318cd24995aa0fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_windowing16xl6_evenlen.  <a href="#ga424bff8de82528e9318cd24995aa0fba">More...</a><br /></td></tr>
<tr class="separator:ga424bff8de82528e9318cd24995aa0fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga28c3753b49aebd6c41a4378112d2184d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga28c3753b49aebd6c41a4378112d2184d"></a>
const int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___f_f_t.html#ga28c3753b49aebd6c41a4378112d2184d">mmwavelib_dftHalfBinExpValue</a> [2 *9]</td></tr>
<tr class="memdesc:ga28c3753b49aebd6c41a4378112d2184d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lookup table for half bin sin/cos values. It contains complex exponentials e(k) = cos(pi/N)+j*sin(-pi/N), N=4,8,16,32,64,128,256,512,1024 Imaginary values are in even, and real values are in odd locations. Values are in Q15 format, saturated to +32767/-32768. <br /></td></tr>
<tr class="separator:ga28c3753b49aebd6c41a4378112d2184d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The functions facilitate stage wise FFT. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac8ffc801081f734dd07a5d70106165ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_dftSinCosTabelGen </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dftLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>dftSinCosTbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_dftSinCosTabelGen. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Calculates the Sin and Cos values of exp(-1j*2*pi*k/N) for DFT, N is the DFT size, and k is [0 N-1]. The Sin/Cos values are in Q15 format. The function is optimized using lookup table. The exp(j*2*pi*k/N), with N=1024, k=[0: 255] are saved in the lookup table in Q31 format. For DFT size, which is power of 2, and less than 2048, The angles are always multiple of 2*pi/1024. If 0 &lt;= k &lt; N/4, the function uses the formula cos(-a)=cos(a), sin(-a)=-sin(a) to calculate the Sin/Cos values. If N/4 =&lt; k &lt; N/2, the function uses cos(3*pi/2-a)=-sin(a), sin(3*pi/2-a)=-cos(a) calculate the Sin/Cos values. If N/2 &lt;= k &lt; 3/4*N, the function uses formula cos(pi-a)=-cos(a), sin(pi-a)=sin(a) to calculate the Sin/Cos values. If 3/4*N &lt;= k &lt; N, the function uses the formula cos(pi/2-a) = sin(a), and sin(pi/2-a)=cos(a) to calculate the Sin/Cos values. and a is angle in [0 pi/2]. The function supports up to FFT size 1024.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dftLength</td><td>: dft Length. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dftSinCosTbl</td><td>: Table with sin and cos values for exp(-1j*2*pi*k/N) sin value is at low 16 bits, cos is at high 16 bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>DFT length is power of 2, and less than 2048.</dd></dl>
<p>Cycles 7.0 * dftLength + 50 (cgt 8.1.3) </p>

</div>
</div>
<a class="anchor" id="gad0f58e1c7dfd8ffa5c37aa3a012e5414"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_dftSingleBin </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>inBuf</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sincos</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *restrict&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>doppInd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_dftSingleBin. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Calculates single bin DFT. for (i = 0; i &lt; length; i++) outputComplex += inputComplex(i)*exp(-j*2*pi*i*doppInd/length);</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inBuf</td><td>: Input int16 real, int16 imaginary complex array, Real part is at low 16 bits, imaginary part is at high 16 bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sincos</td><td>: Table with sine cosine values for exp(-1j*2*pi*k/N) Sine is at low 16 bits, cosine is at high 16 bits. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: Single point DFT value, int32 real in lower half of 64bit, int32 imaginary in higher half. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>: Length of input buffer (size of DFT) must be multiple of 4</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doppInd</td><td>: Index value at wich the DFT is calculated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1) inBuf must be 8 byte aligned. </dd>
<dd>
(2) length must be multiple of 4.</dd></dl>
<p>Cycles length/4*5 + 76 (cgt 8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga09ac54ea25984994384c660c9d2ba1f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_dftSingleBinWithWindow </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>inBuf</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sincos</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>win</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *restrict&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>doppInd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_dftSingleBinWithWindow. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Calculates single bin DFT with windowing. <pre class="fragment">                     for (i = 0; i &lt; length; i++)
                        outputComplex +=  inputComplex(i)*win(i)*exp(-j*2*pi*i*doppInd/length);
</pre></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inBuf</td><td>: Input int16 real, int16 imaginary complex array, Real part is at low 16 bits, imaginary part is at high 16 bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sincos</td><td>: Table with sine cosine values for exp(-1j*2*pi*k/N) Sine is at low 16 bits, cosine is at high 16 bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>: Window real array (32 bit) of length length/2 (since its a symmetric window) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: Single point DFT value, int32 real in lower half of 64bit, int32 imaginary in higher half. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>: Length of input buffer (size of DFT) must be multiple of 4 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doppInd</td><td>: Index value at which the DFT is calculated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1) inBuf and win must be 8 byte aligned. </dd>
<dd>
(2) length must be multiple of 4.</dd></dl>
<p>Cycles length/4*7 + 58 (cgt 8.1.3) </p>

</div>
</div>
<a class="anchor" id="gad73a04108986ee793bf16261b790981f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_dftSingleBinWithWindow_ReIm </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>inBuf</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sincos</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>win</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *restrict&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>doppInd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_dftSingleBinWithWindow_ReIm. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Calculates single bin DFT with windowing, and swaps the Re/Im order in the output. <pre class="fragment">                     for (i = 0; i &lt; length; i++)
                        outputComplex +=  inputComplex(i)*win(i)*exp(-j*2*pi*i*doppInd/length);
</pre></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inBuf</td><td>: Input int16 real, int16 imaginary complex array, Real part is at higher 16 bits, imaginary part is at lower 16 bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sincos</td><td>: Table with sine cosine values for exp(-1j*2*pi*k/N) Sine is at low 16 bits, cosine is at high 16 bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>: Window real array (32 bit) of length length/2 (since its a symmetric window) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: Single point DFT value, int32 real in lower half of 64bit, int32 imaginary in higher half. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>: Length of input buffer (size of DFT) must be multiple of 4 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doppInd</td><td>: Index value at which the DFT is calculated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1) inBuf and win must be 8 byte aligned. </dd>
<dd>
(2) length must be multiple of 4.</dd></dl>
<p>Cycles length/4*6 + 73 (cgt 8.1.3) </p>

</div>
</div>
<a class="anchor" id="gac2de8e6b5ed556d0456cba95a15110cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_fft16ptZeroPadded32x32 </td>
          <td>(</td>
          <td class="paramtype">const int32_t *restrict&#160;</td>
          <td class="paramname"><em>inp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *restrict&#160;</td>
          <td class="paramname"><em>twiddle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *restrict&#160;</td>
          <td class="paramname"><em>temp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *restrict&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numSkipSamples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mmwavelib_fft16ptZeroPadded32x32 Computes the 16pt FFT of vectors of length 8. The input vectors are assumed to be in transpose format (in inp). Hence the FFT can be thought of as operating along the columns of inp </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: input complex array (32 bit I, 32 bit Q). The input array is assumed to be a x[8][numLines*2] array, *2 is for complex, with each FFT operating along each columns resultingin an ouput of length 16. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">twiddle</td><td>: twiddle factors array (32 bit I, 32 bit Q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">temp</td><td>: temporary buffer (sufficient to store 16*numLines complex samples) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: output complex array (32 bit I, 32 bit Q) (size: out[numLines][16*2]) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numLines</td><td>: number of consecutive columns of inp for which the FFT must be run. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSkipSamples</td><td>: number of total columns L of inp if L&gt;numLines. otherwise this equals to numLines.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input array (inp), output array (out), twiddle factor array (twiddle), temp buffer (temp) are all 8 byte aligned </dd></dl>

</div>
</div>
<a class="anchor" id="ga453fca8e41716837fcf9f0a0d454ad22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_gen_twiddle_fft16x16 </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_gen_twiddle_fft16x16. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : this function is equivalent of the dsplib's gen_twiddle_fft16x16() function with optimization. The maximum error with respect to the dsplib function is in the LSB (+/- 1). The math for twiddle factors is defined as follows for (j = 1, k = 0; j &lt; n &gt;&gt; 2; j = j &lt;&lt; 2) { for (i = 0; i &lt; n &gt;&gt; 2; i += j &lt;&lt; 1) { w[k + 0] = exp(2.0 * PI * i / n); w[k + 1] = exp(2.0 * PI * (i + j) / n); w[k + 2] = -exp(4.0 * PI * i / n); w[k + 3] = -exp(4.0 * PI * (i + j) / n); w[k + 4] = exp(6.0 * PI * i / n); w[k + 5] = exp(6.0 * PI * (i + j) / n); k += 6; } }</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: the FFT size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>: Pointer to twiddle-factor array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual length of the twiddle factor array</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>FFT size must be power of 2. </dd>
<dd>
the maximum FFT size is 8192 </dd></dl>

</div>
</div>
<a class="anchor" id="ga49dbcbb1eb0456d44de4bb6fe8f0594b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_gen_twiddle_fft16x16_imre_sa </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_gen_twiddle_fft16x16_imre_sa. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : this function is equivalent of the dsplib's gen_twiddle_fft16x16_imre_sa() function with optimization. The maximum error with respect to the dsplib function is in the LSB (+/- 1). The math for twiddle factors is defined as follows for (j = 1, k = 0; j &lt; n &gt;&gt; 2; j = j &lt;&lt; 2) { for (i = 0; i &lt; n &gt;&gt; 2; i += j &lt;&lt; 1) { w[k + 0] = exp(-2.0 * PI * i / n); w[k + 1] = exp(-2.0 * PI * (i + j) / n); w[k + 2] = exp(PI-(4.0 * PI * i / n)); w[k + 3] = exp(PI-(4.0 * PI * (i + j) / n)); w[k + 4] = exp(-6.0 * PI * i / n); w[k + 5] = exp(-6.0 * PI * (i + j) / n); k += 6; } }</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: the FFT size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>: Pointer to twiddle-factor array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual length of the twiddle factor array</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>FFT size must be power of 2. </dd>
<dd>
the maximum FFT size is 4096 </dd></dl>

</div>
</div>
<a class="anchor" id="ga1e66c7b243f46f35243eab84212f3939"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_gen_twiddle_fft32x32 </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_gen_twiddle_fft32x32. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : This function is equivalent to the dsplib's gen_twiddle_fft32x32() function with optimization. The maximum error with respect to th dsplib function is in the LSB (+/- 2). It supports FFT size upto 8192. The math for twiddle factors is defined as follows for (j = 1; j &lt; n &gt;&gt; 2; j = j &lt;&lt; 2) { for (i = 0; i &lt; n &gt;&gt; 2; i += j) { w[k + 0] = exp(2.0 * PI * i / n); w[k + 1] = exp(4.0 * PI * i / n); w[k + 2] = exp(6.0 * PI * i / n); k += 3; } }</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: the FFT size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>: Pointer to twiddle-factor array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual length of the twiddle factor array</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>FFT size must be power of 2. </dd>
<dd>
the maximum FFT size is 8192 </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b62b1ba79e28c8119c56526c023b067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_gen_twiddle_largefft_16x16 </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_gen_twiddle_largefft_16x16. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : This function is equivalent of the dsplib's gen_twiddle_fft16x16() function with optimization. The optimization is similar to the function mmwavelib_gen_twiddle_smallfft_16x16. This function supports FFT size 2048, 4096. If the twiddle factor angle is the multiple of 2*pi/1024, the twiddle factor values are obtained the same way as the function mmwavelib_gen_twiddle_smallfft_16x16. If the twiddle factor angle is not multiple of 2*pi/1024, the function uses the formula cos(a+b) = cos(a)cos(b) - sin(a)sin(b) sin(a+b) = sin(a)cos(b) + cos(a)sin(b) to calculate the twiddle factor values, where a is the multiple of 2*pi/1024, and b is the remainder. The corresponding sin/cos values for the remainder (b) are saved in the mmwavelib_twiddleTableLargeFFTSize table.The maximum error with respect to the dsplib function is in the LSB (+/- 1).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: the FFT size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>: Pointer to twiddle-factor array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The actual length of the twiddle factor array</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>It supports FFT size 2048, 4096.</dd></dl>
<pre class="fragment">                     Cycles: 8.15 * n + 678 (cgt 8.1.3)       </pre> 
</div>
</div>
<a class="anchor" id="gaff018510f058d0c6e9e10776e4e660b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_gen_twiddle_largefft_16x16_imre_sa </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_gen_twiddle_largefft_16x16_imre_sa. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : This function is equivalent of the dsplib's gen_twiddle_fft16x16_imre_sa() function with optimization. The optimization is similar to the function mmwavelib_gen_twiddle_smallfft_16x16. This function supports FFT size 2048, 4096. If the twiddle factor angle is the multiple of 2*pi/1024, the twiddle factor values are obtained the same way as the function mmwavelib_gen_twiddle_smallfft_16x16. If the twiddle factor angle is not multiple of 2*pi/1024, the function uses the formula cos(a+b) = cos(a)cos(b) - sin(a)sin(b) sin(a+b) = sin(a)cos(b) + cos(a)sin(b) to calculate the twiddle factor values, where a is the multiple of 2*pi/1024, and b is the remainder. The corresponding sin/cos values for the remainder (b) are saved in the mmwavelib_twiddleTableLargeFFTSize table.The maximum error with respect to the dsplib function is in the LSB (+/- 1).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: the FFT size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>: Pointer to twiddle-factor array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The actual length of the twiddle factor array</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>It supports FFT size 2048, 4096.</dd></dl>
<pre class="fragment">                     Cycles: 8.23 * n + 780 (cgt 8.1.3)</pre> 
</div>
</div>
<a class="anchor" id="ga0c3ba7d003aa3775901474bb8bcc526d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_gen_twiddle_largefft_32x32 </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_gen_twiddle_largefft_32x32. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : This function is equivalent to the dsplib's gen_twiddle_fft32x32() function with optimization. The optimization is similar to the function mmwavelib_gen_twiddle_smallfft_32x32. If the twiddle factor angle is the multiple of 2*pi/1024, the twiddle factor values are obtained the same way as the function mmwavelib_gen_twiddle_smallfft_32x32. If the twiddle factor angle is not multiple of 2*pi/1024, the function uses the formula cos(a+b) = cos(a)cos(b) - sin(a)sin(b) sin(a+b) = sin(a)cos(b) + cos(a)sin(b) to calculate the twiddle factor values, where a is the multiple of 2*pi/1024, and b is the remainder, the corresponding sin/cos values for the remainder are saved in the mmwavelib_twiddleTableLargeFFTSize table. It supports FFT size 2048, 4096, 8192. The maximum error with respect to the dsplib function is in the LSB (+/- 1) for FFT size 2048, and (+/- 2) for FFT size 2048 and 8192.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: the FFT size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>: Pointer to twiddle-factor array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual length of the twiddle factor array</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>It supports FFT size 2048, 4096 and 8192.</dd></dl>
<pre class="fragment">                     Cycles: 13.67 * n + 188 (cgt 8.1.3)  </pre> 
</div>
</div>
<a class="anchor" id="ga44eb5f439689d90d3f669d198ec4529f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_gen_twiddle_largefftUp8k_16x16 </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_gen_twiddle_largefftUp8k_16x16. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : This function is equivalent of the dsplib's gen_twiddle_fft16x16() function with optimization. The optimization is similar to the function mmwavelib_gen_twiddle_smallfft_16x16. This function supports FFT size 2048, 4096, and 8192. If the twiddle factor angle is the multiple of 2*pi/1024, the twiddle factor values are obtained the same way as the function mmwavelib_gen_twiddle_smallfft_16x16. If the twiddle factor angle is not multiple of 2*pi/1024, the function uses the formula cos(a+b) = cos(a)cos(b) - sin(a)sin(b) sin(a+b) = sin(a)cos(b) + cos(a)sin(b) to calculate the twiddle factor values, where a is the multiple of 2*pi/1024, and b is the remainder. The corresponding sin/cos values for the remainder (b) are saved in the mmwavelib_twiddleTableLargeFFTSize table.The maximum error with respect to the dsplib function is in the LSB (+/- 1).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: the FFT size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>: Pointer to twiddle-factor array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The actual length of the twiddle factor array</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>It supports FFT size 2048, 4096, 8192.</dd></dl>
<pre class="fragment">                     Cycles: 21 * n + 432 (cgt 8.1.3)       </pre> 
</div>
</div>
<a class="anchor" id="gaa126b24e90cd56f52508047643bac2fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_gen_twiddle_smallfft_16x16 </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_gen_twiddle_smallfft_16x16. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : This function is equivalent to the dsplib's gen_twiddle_fft16x16() function with optimization. The optimization is to use the look up table. The sin and cos values of the angles from 0 to pi/2 in the step of 2*pi/1024 are saved in the lookup table in Q31 format. For FFT size, which is power of 2, and less than or equal to 1024, the twiddle factor angles are always multiple of 2*pi/1024. If the twiddle factor angle is in the range of [0 pi/2], the function reads the sin/cos values directly from the table, then converts into Q16 format. If the factor angle is in the range of [pi/2 pi], the function uses the formula sin(pi/2+a)=cos(a), cos(pi/2+a)=-sin(a), to find the twiddle factor values. If the twiddle factor angle is in the range of [pi 3*pi/2], the function uses the formula sin(pi+a) = -sin(a), cos(pi+a)= -cos(a) to find the twiddle factor values. No twiddle factor angle is in the range of [3*pi/2 2*pi]. The maximum error with respect to the dsplib function is in the LSB (+/- 1). It supports up to FFT size 1024.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: the FFT size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>: Pointer to twiddle-factor array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual length of the generated twiddle factor array</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>FFT size must be power of 2. </dd>
<dd>
The maximum FFT size is 1024</dd></dl>
<pre class="fragment">                     Cycles 4.45 * n + 181 (cgt 8.1.3)  </pre> 
</div>
</div>
<a class="anchor" id="gab33fdc29ef57e309d6e75e4cb2dccf4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_gen_twiddle_smallfft_16x16_imre_sa </td>
          <td>(</td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_gen_twiddle_smallfft_16x16_imre_sa. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : This function is equivalent to the dsplib's gen_twiddle_fft16x16_imre_sa() function with optimization. The optimization is to use the look up table. The sin and cos values of the angles from 0 to pi/2 in the step of 2*pi/1024 are saved in the lookup table in Q31 format. For FFT size, which is power of 2, and less than or equal to 1024, the twiddle factor angles are always multiple of 2*pi/1024. If the twiddle factor angle is in the range of [0 pi/2], the function reads the sin/cos values directly from the table, then converts into Q16 format. If the factor angle is in the range of [pi/2 pi], the function uses the formula sin(pi/2+a)=cos(a), cos(pi/2+a)=-sin(a), to find the twiddle factor values. If the twiddle factor angle is in the range of [pi 3*pi/2], the function uses the formula sin(pi+a) = -sin(a), cos(pi+a)= -cos(a) to find the twiddle factor values. No twiddle factor angle is in the range of [3*pi/2 2*pi]. The maximum error with respect to the dsplib function is in the LSB (+/- 1). It supports up to FFT size 1024.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: the FFT size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>: Pointer to twiddle-factor array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual length of the generated twiddle factor array</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>FFT size must be power of 2. </dd>
<dd>
The maximum FFT size is 1024</dd></dl>
<pre class="fragment">                     Cycles 6.2 * n + 345 (cgt 8.1.3)</pre> 
</div>
</div>
<a class="anchor" id="ga8fb6b6a95576d7c3f458ce4a47ce04f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_gen_twiddle_smallfft_32x32 </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_gen_twiddle_smallfft_32x32. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : This function is equivalent to the dsplib's gen_twiddle_fft32x32() function with optimization. The optimization is to use look up table for twiddle factor generation. The sin and cos values of the angles from 0 to pi/2 in the step of 2*pi/1024 are saved in the lookup table in Q31 format. For FFT size, which is power of 2, less than and equal to 1024, the twiddle factor angles are always multiple of 2*pi/1024. If the twiddle factor angle is in the range of [0 pi/2], the function reads the factor values directly from the table. If the factor angle is in the range of [pi/2 pi], the function uses the formula sin(pi/2+a)=cos(a), cos(pi/2+a)=-sin(a), to find the twiddle factor values. If the twiddle factor angle is in the range of [pi 3*pi/2], the function uses the formula sin(pi+a) = -sin(a), cos(pi+a)= -cos(a) to find the twiddle factor values. No twiddle factor angle is in the range of [3*pi/2 2*pi]. The maximum error with respect to the dsplib function is in the LSB (+/- 1). It supports FFT size upto 1024.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>: the FFT size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>: Pointer to twiddle-factor array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual length of the twiddle factor array</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>FFT size must be power of 2. </dd>
<dd>
The maximum FFT size is 1024</dd></dl>
<pre class="fragment">                     Cycles 4.60 * n + 204 (cgt 8.1.3)        </pre> 
</div>
</div>
<a class="anchor" id="gaa28da06760bfe26ceedc3057039008a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_windowCoef_gen </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>winCoef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>windowDatumType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>initR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>initI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>winCoefLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>Qformat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>winType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_windowCoef_gen. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : The function generates window coefficients in specified format. It calls single precision sine an cosine functions from mathlib library then recursively generates the cosine values for the other samples</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">windowDatumType</td><td>: generated windowing coefficients data format. <a class="el" href="mmwavelib__fft_8h.html#a2e939f8c9be0e2b8bca23cff03480b19">MMWAVELIB_WINDOW_INT16</a>, int16_t <a class="el" href="mmwavelib__fft_8h.html#ab95173287d8d14447c30ebb1bf5a170b">MMWAVELIB_WINDOW_INT32</a>, int32_t </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initR</td><td>: cos(2*pi/(winLen-1)) value in floating point format can be obtained by using mathlib function cossp() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initI</td><td>: sin(2*pi/(winLen-1)) value in floating point format can be obtained by using mathlib function sinsp() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">winCoefLen</td><td>: The number of the generated window samples. The generated window is real symmetric window. Only half of the window samples are generated. If the window length is even, winCoefLen is the half of the window length, if the window length is odd, winCoefLen is half of the window length plus one. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Qformat</td><td>: Q format used for the generated widown coefficients. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">winType</td><td>: Type of window, one of <a class="el" href="mmwavelib__fft_8h.html#a25863fbfb8c392111294a4fe450dc7f6">MMWAVELIB_WIN_HANNING</a>, w(n)=0.5*(1-cos(2*pi*n/(N-1)) <a class="el" href="mmwavelib__fft_8h.html#aabedda49772109dcc14c3af6ccfc2802">MMWAVELIB_WIN_BLACKMAN</a>, w(n)=0.42-0.5*cos(2*pi*n/(N-1)) +0.08*cos(4*pi*n/(N-1))</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="mmwavelib__fft_8h.html#a5a4b564e8a107aeeb993246e798b0f5f">MMWAVELIB_WIN_RECT</a>, w(n) = 1 <a class="el" href="mmwavelib__fft_8h.html#ae50bb3542b716e4f1e7d9c707636e74e">MMWAVELIB_WIN_HAMMING</a>, w(n) = 0.54-0.46*cos(2*pi*n/(N-1)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">winCoef</td><td>: Pointer to calculated window sample array, with length of winCoefLen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1) Only support Blackman, Rectangle, Hamming, and Hanning windows </dd>
<dd>
(2) winCoef must be 8 byte aligned.</dd></dl>
<p>Cycles (cgt 8.1.3) Hanning/Hamming: 5 * winCoefLen + 103 Blackman: 6 * winCoefLen + 120 rectangle: 0.25 * winCoefLen + 74 </p>

</div>
</div>
<a class="anchor" id="ga4e93be64cedae950adb6a15e9bb1c08b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_windowing16x16 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>win</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_windowing16xl6. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Multiplies a 16 bit complex vector with a 16 bit real windowing vector. The rounded result is stored inplace. The math is as follows: output_real[n]=round(input_real[n]*window[n]/2^15); output_imag[n]=round(input_imag[n]*window[n]/2^15)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: Input complex array (16bit I followed by 16bit Q). Output is written inplace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>: Windowing real array (16 bit) of length len/2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of complex elements in inp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Input (inp) and Windowing array (win) are all 8 byte aligned. </dd>
<dd>
(2)Input array length (len) is a multiple of 8. </dd>
<dd>
(3)Window is assumed to be symmetric. So only the first len/2 elements of the window array are accessed.</dd></dl>
<p>Cycles (cgt 8.1.3) 0.59375*len +54 </p>

</div>
</div>
<a class="anchor" id="ga424bff8de82528e9318cd24995aa0fba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_windowing16x16_evenlen </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>win</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_windowing16xl6_evenlen. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Multiplies a 16 bit complex vector with a 16 bit real windowing vector. The rounded result is stored inplace. The math is as follows: output_real[n]=round(input_real[n]*window[n]/2^15); output_imag[n]=round(input_imag[n]*window[n]/2^15)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: Input complex array (16bit I followed by 16bit Q). Output is written inplace. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>: Windowing real array (16 bit) of length len/2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of complex elements in inp.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Input (inp) and Windowing array (win) are all 8 byte aligned. </dd>
<dd>
(2)Input array length (len) is multiple of 2. </dd>
<dd>
(3)Window is assumed to be symmetric. So only the first len/2 elements of the window array are accessed.</dd></dl>
<p>Cycles (cgt 8.1.3) 0.59375*len + ovh; len%16=0: ovh=~79; len%16=6,8,14: ovh=~88; 0.6548 *len + ovh; len%16=2,4: ovh=~82; len%16=10,12: ovh=~90. </p>

</div>
</div>
<a class="anchor" id="ga03eec284913bf5a1a4508f87b0d5c570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_windowing16x32 </td>
          <td>(</td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>win</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>out</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_windowing16x32. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Multiplies a 16 bit complex vector with a 32 bit real symmetric window vector. The result is stored as a 32 bit complex vector, with same Re/Im order as input complex signal. The math is as follows: output_real[n]=round(input_real[n]*window[n]/2^15); output_imag[n]=round(input_imag[n]*window[n]/2^15)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: Input complex array (16bit I followed by 16 bit Q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>: Windowing real array (32 bit) of length len/2 (since its a symmetric window) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: Output complex array (32 bit I followed by 32 bit Q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of complex elements in inp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Input (inp), Output (out) and Windowing array (win) are all 8 byte aligned. </dd>
<dd>
(2)Input array length (len) is a multiple of 4 </dd>
<dd>
(3)Window is assumed to be symmetric. So only the first len/2 elements of the window array are accessed.</dd></dl>
<p>Cycles (cgt 8.1.3) 1.25*len +47 </p>

</div>
</div>
<a class="anchor" id="ga7a43ad3c5e94d1ac841d822f73196e01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_windowing16x32_IQswap </td>
          <td>(</td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>win</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>out</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_windowing16x32_IQswap. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Multiplies a 16 bit complex vector with a 32 bit real symmetric window vector, The result is stored as a 32 bit complex vector, with swapped Re/Im order compared with the input signal. The math is as follows: output_real[n]=round(input_real[n]*window[n]/2^15); output_imag[n]=round(input_imag[n]*window[n]/2^15)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: Input complex array (16bit I followed by 16 bit Q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>: Windowing real array (32 bit) of length len/2 (since its a symmetric window) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: Output complex array (32 bit Q followed by 32 bit I) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of complex elements in inp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Input (inp), Output (out) and Windowing array (win) are all 8 byte aligned. </dd>
<dd>
(2)Input array length (len) is a multiple of 4 </dd>
<dd>
(3)Window is assumed to be symmetric. So only the first len/2 elements of the window array are accessed.</dd></dl>
<p>Cycles (cgt 8.1.3) 1.25*len + 36 </p>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
