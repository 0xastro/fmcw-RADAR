<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Detection</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Detection</div>  </div>
</div><!--header-->
<div class="contents">

<p>The functions related to detecting objects.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac072c14f0f469c909e5ad4e85eafb04f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___d_e_t_e_c_t.html#gac072c14f0f469c909e5ad4e85eafb04f">mmwavelib_cfarCa</a> (const uint16_t inp[restrict], uint16_t out[restrict], uint32_t len, uint32_t const1, uint32_t const2, uint32_t guardLen, uint32_t noiseLen)</td></tr>
<tr class="memdesc:gac072c14f0f469c909e5ad4e85eafb04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_cfarCa.  <a href="#gac072c14f0f469c909e5ad4e85eafb04f">More...</a><br /></td></tr>
<tr class="separator:gac072c14f0f469c909e5ad4e85eafb04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2869b28ce97e87fdeba8ec6b7efbcf1c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___d_e_t_e_c_t.html#ga2869b28ce97e87fdeba8ec6b7efbcf1c">mmwavelib_cfarCadB</a> (const uint16_t inp[restrict], uint16_t out[restrict], uint32_t len, uint32_t const1, uint32_t const2, uint32_t guardLen, uint32_t noiseLen)</td></tr>
<tr class="memdesc:ga2869b28ce97e87fdeba8ec6b7efbcf1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_cfarCadB.  <a href="#ga2869b28ce97e87fdeba8ec6b7efbcf1c">More...</a><br /></td></tr>
<tr class="separator:ga2869b28ce97e87fdeba8ec6b7efbcf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bdf755d63420479b7f808ee2ddb661d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___d_e_t_e_c_t.html#ga3bdf755d63420479b7f808ee2ddb661d">mmwavelib_cfarCadBwrap</a> (const uint16_t inp[restrict], uint16_t out[restrict], uint32_t len, uint32_t const1, uint32_t const2, uint32_t guardLen, uint32_t noiseLen)</td></tr>
<tr class="memdesc:ga3bdf755d63420479b7f808ee2ddb661d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_cfarCadBwrap.  <a href="#ga3bdf755d63420479b7f808ee2ddb661d">More...</a><br /></td></tr>
<tr class="separator:ga3bdf755d63420479b7f808ee2ddb661d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7356a806e6afc8cb94c5d20c9afd9f9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___d_e_t_e_c_t.html#gae7356a806e6afc8cb94c5d20c9afd9f9">mmwavelib_cfarCadB_SOGO</a> (const uint16_t inp[restrict], uint16_t out[restrict], uint32_t len, uint16_t cfartype, uint32_t const1, uint32_t const2, uint32_t guardLen, uint32_t noiseLen)</td></tr>
<tr class="memdesc:gae7356a806e6afc8cb94c5d20c9afd9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_cfarCadB_SOGO.  <a href="#gae7356a806e6afc8cb94c5d20c9afd9f9">More...</a><br /></td></tr>
<tr class="separator:gae7356a806e6afc8cb94c5d20c9afd9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3f2b14b0fe26048db37fc6a4fc3e09"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___d_e_t_e_c_t.html#gaba3f2b14b0fe26048db37fc6a4fc3e09">mmwavelib_cfarOS</a> (const uint16_t *restrict data, const uint32_t len, const uint32_t lenCUTend, const int16_t k, const int16_t alpha, uint16_t *restrict detectedList, uint16_t *restrict kosList)</td></tr>
<tr class="memdesc:gaba3f2b14b0fe26048db37fc6a4fc3e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_cfarOS.  <a href="#gaba3f2b14b0fe26048db37fc6a4fc3e09">More...</a><br /></td></tr>
<tr class="separator:gaba3f2b14b0fe26048db37fc6a4fc3e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9140e996f2f06b358bf17909932333df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___d_e_t_e_c_t.html#ga9140e996f2f06b358bf17909932333df">mmwavelib_log2Abs32</a> (const int32_t inp[restrict], uint16_t out[restrict], uint32_t len)</td></tr>
<tr class="memdesc:ga9140e996f2f06b358bf17909932333df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_log2Abs32.  <a href="#ga9140e996f2f06b358bf17909932333df">More...</a><br /></td></tr>
<tr class="separator:ga9140e996f2f06b358bf17909932333df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8789406c7020ba540f170246f8c4e75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___d_e_t_e_c_t.html#gad8789406c7020ba540f170246f8c4e75">mmwavelib_log2Abs16</a> (const int16_t inp[restrict], uint16_t out[restrict], uint32_t len)</td></tr>
<tr class="memdesc:gad8789406c7020ba540f170246f8c4e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_log2Abs16.  <a href="#gad8789406c7020ba540f170246f8c4e75">More...</a><br /></td></tr>
<tr class="separator:gad8789406c7020ba540f170246f8c4e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The functions related to detecting objects. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac072c14f0f469c909e5ad4e85eafb04f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mmwavelib_cfarCa </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>out</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>const1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>const2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>guardLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>noiseLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_cfarCa. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Performs a regular Cell Averaging CFAR on an 16-bit unsigned input vector (CFAR-CA)</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: input array (16 bit unsigned numbers) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: output array (indices of detected peaks (zero based counting)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: number of elements in input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">const1,const2</td><td>: const1,const2 : used to compare the Cell Under Test (CUT) to the sum of the noise cells: [noise sum *const1 /(2^(const2-1))] for one sided comparison (at the begining and end of the input vector). [noise sum *const1 /(2^(const2))] for two sided comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">guardLen</td><td>: one sided guard length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noiseLen</td><td>: one sided Noise length</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>: output array with indices of the detected peaks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of detected peaks (i.e length of out)</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input (inp) and Output (out) arrays are non-aliased. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2869b28ce97e87fdeba8ec6b7efbcf1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mmwavelib_cfarCadB </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>out</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>const1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>const2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>guardLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>noiseLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_cfarCadB. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Performs a CFAR on an 16-bit unsigned input vector (CFAR-CA). The input values are assumed to be in lograthimic scale. So the comparision between the CUT and the noise samples is additive rather than multiplicative.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: input array (16 bit unsigned numbers) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: output array (indices of detected peaks (zero based counting)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: number of elements in input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">const1,const2</td><td>: used to compare the Cell Under Test (CUT) to the sum of the noise cells: [noise sum /(2^(const2-1))]+const1 for one sided comparison (at the begining and end of the input vector). [noise sum /(2^(const2))]+const1 for two sided comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">guardLen</td><td>: one sided guard length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noiseLen</td><td>: one sided noise length</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>: output array with indices of the detected peaks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of detected peaks (i.e length of out)</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input (inp) and Output (out) arrays are non-aliased.</dd></dl>
<p>Cycles (cgt 8.1.3) 3*len + 121 </p>

</div>
</div>
<a class="anchor" id="gae7356a806e6afc8cb94c5d20c9afd9f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mmwavelib_cfarCadB_SOGO </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>out</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>cfartype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>const1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>const2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>guardLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>noiseLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_cfarCadB_SOGO. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Performs a CFAR on an 16-bit unsigned input vector. The input values are assumed to be in lograthimic scale. So the comparision between the CUT and the noise samples is additive rather than multiplicative. Supports CA, CA SO, and CA GO.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: input array (16 bit unsigned numbers) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: output array (indices of detected peaks (zero based counting)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: number of elements in input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cfartype</td><td>: type of noise floor calculation when two sides of noise available. CFAR_CA; use sum of both sides then average. CFAR_CASO; use smaller of the left and right side. CFAR_CAGO; use greater of the left and right side. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">const1,const2</td><td>: used to compare the Cell Under Test (CUT) to the sum of the noise cells: [noise sum /(2^(const2-1))]+const1 for one sided comparison (at the begining and end of the input vector). [noise sum /(2^(const2))]+const1 for two sided comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">guardLen</td><td>: one sided guard length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noiseLen</td><td>: one sided noise length</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>: output array with indices of the detected peaks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of detected peaks (i.e length of out)</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input (inp) and Output (out) arrays are non-aliased.</dd></dl>
<p>Cycles (cgt 8.1.3) type CA: 3*len +111; type CASO: 4*len +114; type CAGO: 4*len +108 </p>

</div>
</div>
<a class="anchor" id="ga3bdf755d63420479b7f808ee2ddb661d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mmwavelib_cfarCadBwrap </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>out</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>const1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>const2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>guardLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>noiseLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_cfarCadBwrap. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Performs a CFAR on an 16-bit unsigned input vector (CFAR-CA). The input values are assumed to be in lograthimic scale. So the comparision between the CUT and the noise samples is additive rather than multiplicative. Comparison is two-sided (wrap around when needed) for all CUTs.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: input array (16 bit unsigned numbers) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: output array (indices of detected peaks (zero based counting)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: number of elements in input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">const1,const2</td><td>: used to compare the Cell Under Test (CUT) to the sum of the noise cells: [noise sum /(2^(const2))] +const1 for two sided comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">guardLen</td><td>: one sided guard length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">noiseLen</td><td>: one sided Noise length</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>: output array with indices of the detected peaks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of detected peaks (i.e length of out)</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Input (inp) and Output (out) arrays are non-aliased.</dd></dl>
<p>Cycles (cgt 8.1.3) 3*len + 169 </p>

</div>
</div>
<a class="anchor" id="gaba3f2b14b0fe26048db37fc6a4fc3e09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mmwavelib_cfarOS </td>
          <td>(</td>
          <td class="paramtype">const uint16_t *restrict&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>lenCUTend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *restrict&#160;</td>
          <td class="paramname"><em>detectedList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *restrict&#160;</td>
          <td class="paramname"><em>kosList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_cfarOS. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Performs Ordered Statistics CFAR on 16-bit input data. For a CUT(Cell Under Test) to be detected as peak, it has to be greater than the k-th OS i.e. the k-th smallest sample in the search window by certain threshold scaling factor. The search window includes WINDOW_SIZE/2 samples on each side of CUT. The first sample of the input array will be used to pre-fill the window since the first few CUTs don't have enough samples in left-side window.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>: pointer to input data array (16 bit unsigned integers) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: length of input data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lenCUTend</td><td>&lt;=len, length where Cell Under Test ends. The last (len-lenCUTend) samples will not be considered by the detector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>: statistic order. k-th ordered statistic is the k-th smallest sample in the search window of WINDOW_SIZE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>: threshold scaling factor. CUT &gt; (alpha/(2^N_FRAC_BITS_ALPHA))*kth_statistic e.g. CUT &gt; (alpha/64)*kth_statistic is the peak detection criteria. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">detectedList</td><td>: output array with indices of the detected peaks </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">kosList</td><td>: array with corresponding k-th OS of the detected peaks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of detected peaks (i.e length of detectedList and kosList)</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) 8-byte aligned data array; each input data sample &lt;= 32767. </dd>
<dd>
2) lenCUTend &lt;= len. </dd>
<dd>
3) 1 &lt;= k &lt;= WINDOW_SIZE. Normally it's 1/2 to 3/4 of WINDOW_SIZE. </dd>
<dd>
4) Input and output arrays are non-aliased. </dd>
<dd>
5) WINDOW_SIZE is multiple of 8. </dd>
<dd>
6) Enough memory should be allocated to detectedList and kosList.</dd></dl>
<p>Cycles (cgt 8.1.3) 62.375*lenCUTend +734 with WINDOW_SIZE=32 30*lenCUTend +244 with WINDOW_SIZE=16 16.25*lenCUTend +145 with WINDOW_SIZE=8 </p>

</div>
</div>
<a class="anchor" id="gad8789406c7020ba540f170246f8c4e75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_log2Abs16 </td>
          <td>(</td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>out</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_log2Abs16. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Takes a 16 bit complex input vector and computes the log2(|x[i]|^2). First the magnitude square of each complex numer is taken. Subsequently, log2 is found using a look-up table (LUT) based approximation. The output is a 16 bit number in Q8 format. Thus each value of the output is computed as round(log2(|x[i]|)*2^8), where log2() is the LUT based approximation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: input complex array (16 bit I, 16 bit Q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: output array (16 bit unsigned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: number of complex elements in inp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Input and Output arrays are all 8 byte aligned. </dd>
<dd>
(2)Input array length (len) is a multiple of 2 </dd></dl>

</div>
</div>
<a class="anchor" id="ga9140e996f2f06b358bf17909932333df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_log2Abs32 </td>
          <td>(</td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>out</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_log2Abs32. </p>
<hr/>
<p> Takes a 32 bit complex input vector and computes the log2(abs(x[i])). The abs(a+j*b) is approximated using (max(|a|,|b|) + min(|a|,|b|)*3/8). Subsequently, log2 is found using a lookup table based approximation. The output is a 16 bit number in Q8 format. Thus each value of the output is computed as round(log2(abs(x[i]))*2^8).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: input complex array (32 bit I, 32 bit Q) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>: output array (16 bit unsigned) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: number of complex elements in inp</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Input and output arrays are all 8 byte aligned. </dd>
<dd>
(2)Input array length (len) is a multiple of 4</dd></dl>
<p>Cycles 3.5*len + 89 (cgt 8.1.3) </p>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
