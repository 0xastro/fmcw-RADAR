<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>alg/mmwavelib/src/vecutils/mmwavelib_vecutils.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c9839ac9bd42e86e6159886378237831.html">alg</a></li><li class="navelem"><a class="el" href="dir_5f5b3a6c6f9ee84cdf9c273ccf43003e.html">mmwavelib</a></li><li class="navelem"><a class="el" href="dir_9fa96890f77570b05e4519e45129846b.html">src</a></li><li class="navelem"><a class="el" href="dir_b3ef34606b33680a8488a597966dd609.html">vecutils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mmwavelib_vecutils.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for vector utility mmwavelib library routines.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7a0caca055eef56c597d066bef6f3167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga7a0caca055eef56c597d066bef6f3167">mmwavelib_accum16</a> (const uint16_t inp[restrict], uint16_t out[restrict], uint32_t len)</td></tr>
<tr class="memdesc:ga7a0caca055eef56c597d066bef6f3167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function mmwavelib_accum16 accumlates input vector to the output vector. It is the optimized implementation of the for loop: for ( idx=0; idx&lt;len; idx++ ) { out[idx] += inp[idx];//addition saturated to 0xFFFF }.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga7a0caca055eef56c597d066bef6f3167">More...</a><br /></td></tr>
<tr class="separator:ga7a0caca055eef56c597d066bef6f3167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2fd00fe176f2f406369b63e983ed43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga4b2fd00fe176f2f406369b63e983ed43">mmwavelib_accum16to32</a> (const int16_t input[restrict], int32_t output[restrict], uint32_t len)</td></tr>
<tr class="memdesc:ga4b2fd00fe176f2f406369b63e983ed43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function accumlates(adds) 16-bit input vector to the 32-bit output vector. It is the optimized implementation of the for loop: for ( i = 0; i &lt; len; i++ ) { output[i] += input[i]; }.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga4b2fd00fe176f2f406369b63e983ed43">More...</a><br /></td></tr>
<tr class="separator:ga4b2fd00fe176f2f406369b63e983ed43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga629b301147256390e4b0fd894df8c089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga629b301147256390e4b0fd894df8c089">mmwavelib_vecsum</a> (const int16_t input[restrict], int32_t output[restrict], int32_t ncplx)</td></tr>
<tr class="memdesc:ga629b301147256390e4b0fd894df8c089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_vecsum.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga629b301147256390e4b0fd894df8c089">More...</a><br /></td></tr>
<tr class="separator:ga629b301147256390e4b0fd894df8c089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3abbe77f0716d7a664d3b517281034c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga3abbe77f0716d7a664d3b517281034c4">mmwavelib_vecsubc</a> (int16_t *restrict input, int16_t *restrict output, const uint32_t subval, int32_t ncplx)</td></tr>
<tr class="memdesc:ga3abbe77f0716d7a664d3b517281034c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_vecsubc.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga3abbe77f0716d7a664d3b517281034c4">More...</a><br /></td></tr>
<tr class="separator:ga3abbe77f0716d7a664d3b517281034c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ce192512cf33bfd3013bee87903d28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gae2ce192512cf33bfd3013bee87903d28">mmwavelib_vecsub16</a> (int16_t *restrict input1, int16_t *restrict input2, int16_t *restrict output, int32_t len)</td></tr>
<tr class="memdesc:gae2ce192512cf33bfd3013bee87903d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_vecsub16.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gae2ce192512cf33bfd3013bee87903d28">More...</a><br /></td></tr>
<tr class="separator:gae2ce192512cf33bfd3013bee87903d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272359269ae91ec99cc4bdf2bf1b6ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga272359269ae91ec99cc4bdf2bf1b6ddd">mmwavelib_shiftright16</a> (int16_t input[restrict], int16_t output[restrict], uint8_t numshift, uint32_t len)</td></tr>
<tr class="memdesc:ga272359269ae91ec99cc4bdf2bf1b6ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function shifts each signed 16-bit element in vector right by k bits. The math is as follows: for ( i=0; i &lt; len; i++) { output[i] = input[i]&gt;&gt;k; }.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga272359269ae91ec99cc4bdf2bf1b6ddd">More...</a><br /></td></tr>
<tr class="separator:ga272359269ae91ec99cc4bdf2bf1b6ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3a5c0cc0ff8f08dfa600b23f5a15f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gace3a5c0cc0ff8f08dfa600b23f5a15f0">mmwavelib_shiftright32</a> (int32_t input[restrict], int32_t output[restrict], uint8_t numshift, uint32_t len)</td></tr>
<tr class="memdesc:gace3a5c0cc0ff8f08dfa600b23f5a15f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function shifts each signed 32-bit word in vector right by k bits. The math is as follows: for ( i=0; i &lt; len; i++) { output[i] = input[i]&gt;&gt;k; }.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gace3a5c0cc0ff8f08dfa600b23f5a15f0">More...</a><br /></td></tr>
<tr class="separator:gace3a5c0cc0ff8f08dfa600b23f5a15f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade39bc3d31985fe57856fc2abe968bba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gade39bc3d31985fe57856fc2abe968bba">mmwavelib_shiftright32to16</a> (int32_t input[restrict], int16_t output[restrict], uint8_t numshift, uint32_t len)</td></tr>
<tr class="memdesc:gade39bc3d31985fe57856fc2abe968bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function shifts each signed 32-bit word in vector right by k bits, and store the lower 16bits only. The math is as follows: for ( i=0; i &lt; len; i++) { output[i] = (int16_t)(input[i]&gt;&gt;k); }.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gade39bc3d31985fe57856fc2abe968bba">More...</a><br /></td></tr>
<tr class="separator:gade39bc3d31985fe57856fc2abe968bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga296a4ffed31c9015b34581b6712dc0cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga296a4ffed31c9015b34581b6712dc0cf">mmwavelib_histogram</a> (uint16_t input[restrict], uint16_t hist[restrict], uint16_t histTemp[restrict], uint32_t inpLen, uint32_t histLen, uint8_t numshift)</td></tr>
<tr class="memdesc:ga296a4ffed31c9015b34581b6712dc0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function calculates the histogram of the right-shifted input array The math is as follows: for ( i=0; i &lt; len; i++) { hist[input[i]&gt;&gt;k] ++; }.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga296a4ffed31c9015b34581b6712dc0cf">More...</a><br /></td></tr>
<tr class="separator:ga296a4ffed31c9015b34581b6712dc0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf66af7cbc8b38fd72a0077a3eae305d3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gaf66af7cbc8b38fd72a0077a3eae305d3">mmwavelib_vecsumabs</a> (const int16_t input[], int32_t len)</td></tr>
<tr class="memdesc:gaf66af7cbc8b38fd72a0077a3eae305d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_vecsumabs.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gaf66af7cbc8b38fd72a0077a3eae305d3">More...</a><br /></td></tr>
<tr class="separator:gaf66af7cbc8b38fd72a0077a3eae305d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef502b1920c086d1e12483276ec4181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga9ef502b1920c086d1e12483276ec4181">mmwavelib_vecmul16x16</a> (int16_t *restrict x, const int16_t *restrict w, uint32_t nx)</td></tr>
<tr class="memdesc:ga9ef502b1920c086d1e12483276ec4181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function multiply two 16-bit complex vectors element by element. The math is as follows: for ( i=0; i &lt; nx; i++) { outreal[i] = sat((inreal[i]*wreal[i]-inimag[i]*wimag[i]+0x4000)*2)/2^16; outimag[i] = sat((inreal[i]*wimag[i]+inimag[i]*wreal[i]+0x4000)*2)/2^16; }.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga9ef502b1920c086d1e12483276ec4181">More...</a><br /></td></tr>
<tr class="separator:ga9ef502b1920c086d1e12483276ec4181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14c99972390f53e06dffa11d319e69be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga14c99972390f53e06dffa11d319e69be">mmwavelib_vecmul16x32</a> (const int16_t *restrict x, int32_t *restrict w, int32_t *restrict y, uint32_t nx)</td></tr>
<tr class="memdesc:ga14c99972390f53e06dffa11d319e69be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs element-wise complex multiplication on a 16bit vector and a 32bit vector. The math is as follows: for ( i=0; i &lt; nx; i++) { yreal[i] = round(xreal[i]*wreal[i]/2^15)-round(ximag[i]*wimag[i]/2^15); yimag[i] = round(xreal[i]*wimag[i]/2^15)+round(ximag[i]*wreal[i]/2^15); }.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga14c99972390f53e06dffa11d319e69be">More...</a><br /></td></tr>
<tr class="separator:ga14c99972390f53e06dffa11d319e69be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga986a2fa2e49a16a32a0aabbe6de62ddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga986a2fa2e49a16a32a0aabbe6de62ddf">mmwavelib_vecmul16x32_anylen</a> (const uint32_t *restrict x, int64_t *restrict w, int64_t *restrict y, uint32_t len)</td></tr>
<tr class="memdesc:ga986a2fa2e49a16a32a0aabbe6de62ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs element-wise complex multiplication on a 16bit vector and a 32bit vector. The math is as follows: for ( i=0; i &lt; nx; i++) { yreal[i] = round(xreal[i]*wreal[i]/2^15)-round(ximag[i]*wimag[i]/2^15); yimag[i] = round(xreal[i]*wimag[i]/2^15)+round(ximag[i]*wreal[i]/2^15); }.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga986a2fa2e49a16a32a0aabbe6de62ddf">More...</a><br /></td></tr>
<tr class="separator:ga986a2fa2e49a16a32a0aabbe6de62ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37dcc6e41dca0b7c258f791e9f872983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga37dcc6e41dca0b7c258f791e9f872983">mmwavelib_vecmul32x16c</a> (const uint32_t x, int64_t *restrict w, int64_t *restrict y, uint32_t len)</td></tr>
<tr class="memdesc:ga37dcc6e41dca0b7c258f791e9f872983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function multiplies a 16bit complex constant to a 32bit complex vector. The math is as follows: for ( i=0; i &lt; nx; i++) { yreal[i] = round(xreal*wreal[i]/2^15)-round(ximag*wimag[i]/2^15); yimag[i] = round(xreal*wimag[i]/2^15)+round(ximag*wreal[i]/2^15); }.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga37dcc6e41dca0b7c258f791e9f872983">More...</a><br /></td></tr>
<tr class="separator:ga37dcc6e41dca0b7c258f791e9f872983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c76050f4862b78d1f05325be3a4237"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gac8c76050f4862b78d1f05325be3a4237">mmwavelib_maxpow</a> (const int32_t *restrict input, int32_t Ncplx, float32_t *maxpow)</td></tr>
<tr class="memdesc:gac8c76050f4862b78d1f05325be3a4237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_maxpow.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gac8c76050f4862b78d1f05325be3a4237">More...</a><br /></td></tr>
<tr class="separator:gac8c76050f4862b78d1f05325be3a4237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga920a1def3c0071fb9de8e1579a809f69"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga920a1def3c0071fb9de8e1579a809f69">mmwavelib_powerAndMax</a> (const int32_t *restrict input, int32_t Ncplx, float32_t *restrict outpowbuf, float32_t *maxpow)</td></tr>
<tr class="memdesc:ga920a1def3c0071fb9de8e1579a809f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_powerAndMax.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga920a1def3c0071fb9de8e1579a809f69">More...</a><br /></td></tr>
<tr class="separator:ga920a1def3c0071fb9de8e1579a809f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab517cd68c46c2007015f54b888675612"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gab517cd68c46c2007015f54b888675612">mmwavelib_multiPeakSearch</a> (float32_t *x, uint16_t *peakIdxBuf, int32_t len, float32_t thresholdScale)</td></tr>
<tr class="memdesc:gab517cd68c46c2007015f54b888675612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_multiPeakSearch.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gab517cd68c46c2007015f54b888675612">More...</a><br /></td></tr>
<tr class="separator:gab517cd68c46c2007015f54b888675612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe267edb07f90ab94276dbe090d9c44"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga8fe267edb07f90ab94276dbe090d9c44">mmwavelib_secondPeakSearch</a> (float32_t *x, int32_t len, int32_t maxIdx)</td></tr>
<tr class="memdesc:ga8fe267edb07f90ab94276dbe090d9c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_secondPeakSearch.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga8fe267edb07f90ab94276dbe090d9c44">More...</a><br /></td></tr>
<tr class="separator:ga8fe267edb07f90ab94276dbe090d9c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c47f4edbcd1317fde1d38d727bbdfce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga2c47f4edbcd1317fde1d38d727bbdfce">mmwavelib_power_float</a> (float32_t *restrict input, int32_t Ncplx, float32_t *restrict outpowbuf)</td></tr>
<tr class="memdesc:ga2c47f4edbcd1317fde1d38d727bbdfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_power_float.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga2c47f4edbcd1317fde1d38d727bbdfce">More...</a><br /></td></tr>
<tr class="separator:ga2c47f4edbcd1317fde1d38d727bbdfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60b15223a93ce22679cf523c311d97a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga60b15223a93ce22679cf523c311d97a1">mmwavelib_dcRemovalFloat</a> (uint32_t ncplx, float32_t *input, float32_t *output)</td></tr>
<tr class="memdesc:ga60b15223a93ce22679cf523c311d97a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_dcRemovalFloat.  <a href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga60b15223a93ce22679cf523c311d97a1">More...</a><br /></td></tr>
<tr class="separator:ga60b15223a93ce22679cf523c311d97a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for vector utility mmwavelib library routines. </p>
</div></div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
