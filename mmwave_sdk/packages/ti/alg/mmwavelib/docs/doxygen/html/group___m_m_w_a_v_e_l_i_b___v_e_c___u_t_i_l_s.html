<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Vector Utilities</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Vector Utilities</div>  </div>
</div><!--header-->
<div class="contents">

<p>Vector arithmetic functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7a0caca055eef56c597d066bef6f3167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga7a0caca055eef56c597d066bef6f3167">mmwavelib_accum16</a> (const uint16_t inp[restrict], uint16_t out[restrict], uint32_t len)</td></tr>
<tr class="memdesc:ga7a0caca055eef56c597d066bef6f3167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function mmwavelib_accum16 accumlates input vector to the output vector. It is the optimized implementation of the for loop: for ( idx=0; idx&lt;len; idx++ ) { out[idx] += inp[idx];//addition saturated to 0xFFFF }.  <a href="#ga7a0caca055eef56c597d066bef6f3167">More...</a><br /></td></tr>
<tr class="separator:ga7a0caca055eef56c597d066bef6f3167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2fd00fe176f2f406369b63e983ed43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga4b2fd00fe176f2f406369b63e983ed43">mmwavelib_accum16to32</a> (const int16_t input[restrict], int32_t output[restrict], uint32_t len)</td></tr>
<tr class="memdesc:ga4b2fd00fe176f2f406369b63e983ed43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function accumlates(adds) 16-bit input vector to the 32-bit output vector. It is the optimized implementation of the for loop: for ( i = 0; i &lt; len; i++ ) { output[i] += input[i]; }.  <a href="#ga4b2fd00fe176f2f406369b63e983ed43">More...</a><br /></td></tr>
<tr class="separator:ga4b2fd00fe176f2f406369b63e983ed43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60b15223a93ce22679cf523c311d97a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga60b15223a93ce22679cf523c311d97a1">mmwavelib_dcRemovalFloat</a> (uint32_t ncplx, float32_t *input, float32_t *output)</td></tr>
<tr class="memdesc:ga60b15223a93ce22679cf523c311d97a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_dcRemovalFloat.  <a href="#ga60b15223a93ce22679cf523c311d97a1">More...</a><br /></td></tr>
<tr class="separator:ga60b15223a93ce22679cf523c311d97a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga296a4ffed31c9015b34581b6712dc0cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga296a4ffed31c9015b34581b6712dc0cf">mmwavelib_histogram</a> (uint16_t input[restrict], uint16_t hist[restrict], uint16_t histTemp[restrict], uint32_t inpLen, uint32_t histLen, uint8_t numshift)</td></tr>
<tr class="memdesc:ga296a4ffed31c9015b34581b6712dc0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function calculates the histogram of the right-shifted input array The math is as follows: for ( i=0; i &lt; len; i++) { hist[input[i]&gt;&gt;k] ++; }.  <a href="#ga296a4ffed31c9015b34581b6712dc0cf">More...</a><br /></td></tr>
<tr class="separator:ga296a4ffed31c9015b34581b6712dc0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c76050f4862b78d1f05325be3a4237"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gac8c76050f4862b78d1f05325be3a4237">mmwavelib_maxpow</a> (const int32_t *restrict input, int32_t Ncplx, float32_t *maxpow)</td></tr>
<tr class="memdesc:gac8c76050f4862b78d1f05325be3a4237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_maxpow.  <a href="#gac8c76050f4862b78d1f05325be3a4237">More...</a><br /></td></tr>
<tr class="separator:gac8c76050f4862b78d1f05325be3a4237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga920a1def3c0071fb9de8e1579a809f69"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga920a1def3c0071fb9de8e1579a809f69">mmwavelib_powerAndMax</a> (const int32_t *restrict input, int32_t Ncplx, float32_t *restrict outpowbuf, float32_t *maxpow)</td></tr>
<tr class="memdesc:ga920a1def3c0071fb9de8e1579a809f69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_powerAndMax.  <a href="#ga920a1def3c0071fb9de8e1579a809f69">More...</a><br /></td></tr>
<tr class="separator:ga920a1def3c0071fb9de8e1579a809f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab517cd68c46c2007015f54b888675612"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gab517cd68c46c2007015f54b888675612">mmwavelib_multiPeakSearch</a> (float32_t *x, uint16_t *peakIdxBuf, int32_t len, float32_t thresholdScale)</td></tr>
<tr class="memdesc:gab517cd68c46c2007015f54b888675612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_multiPeakSearch.  <a href="#gab517cd68c46c2007015f54b888675612">More...</a><br /></td></tr>
<tr class="separator:gab517cd68c46c2007015f54b888675612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17fbdf17581d9b6afd131287118cac41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga17fbdf17581d9b6afd131287118cac41">mmwavelib_power</a> (int32_t *restrict input, int32_t Ncplx, float32_t *restrict outpowbuf)</td></tr>
<tr class="memdesc:ga17fbdf17581d9b6afd131287118cac41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_power.  <a href="#ga17fbdf17581d9b6afd131287118cac41">More...</a><br /></td></tr>
<tr class="separator:ga17fbdf17581d9b6afd131287118cac41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c47f4edbcd1317fde1d38d727bbdfce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga2c47f4edbcd1317fde1d38d727bbdfce">mmwavelib_power_float</a> (float32_t *restrict input, int32_t Ncplx, float32_t *restrict outpowbuf)</td></tr>
<tr class="memdesc:ga2c47f4edbcd1317fde1d38d727bbdfce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_power_float.  <a href="#ga2c47f4edbcd1317fde1d38d727bbdfce">More...</a><br /></td></tr>
<tr class="separator:ga2c47f4edbcd1317fde1d38d727bbdfce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga048b44d24170630317ca0b1589a285af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga048b44d24170630317ca0b1589a285af">mmwavelib_accumPowerFltpAllAnt</a> (uint32_t fftSize, int32_t numAnt, float32_t *inputPtr, float32_t *outputPtr)</td></tr>
<tr class="memdesc:ga048b44d24170630317ca0b1589a285af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function mmwavelib_accumPowerFltpAllAnt accumulates number of fftSize signal power over all antenna. It can be called per range bin or dopper bin.  <a href="#ga048b44d24170630317ca0b1589a285af">More...</a><br /></td></tr>
<tr class="separator:ga048b44d24170630317ca0b1589a285af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac73796cc03472f1c27897d572c2c8322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gac73796cc03472f1c27897d572c2c8322">mmwavelib_accumPowerFltp</a> (uint32_t length, int32_t accumFlag, float32_t *inputPtr, float32_t *outputPtr)</td></tr>
<tr class="memdesc:gac73796cc03472f1c27897d572c2c8322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function mmwavelib_accumPowerFltp accumulates signal power of the input signal .  <a href="#gac73796cc03472f1c27897d572c2c8322">More...</a><br /></td></tr>
<tr class="separator:gac73796cc03472f1c27897d572c2c8322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe267edb07f90ab94276dbe090d9c44"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga8fe267edb07f90ab94276dbe090d9c44">mmwavelib_secondPeakSearch</a> (float32_t *x, int32_t len, int32_t maxIdx)</td></tr>
<tr class="memdesc:ga8fe267edb07f90ab94276dbe090d9c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_secondPeakSearch.  <a href="#ga8fe267edb07f90ab94276dbe090d9c44">More...</a><br /></td></tr>
<tr class="separator:ga8fe267edb07f90ab94276dbe090d9c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272359269ae91ec99cc4bdf2bf1b6ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga272359269ae91ec99cc4bdf2bf1b6ddd">mmwavelib_shiftright16</a> (int16_t input[restrict], int16_t output[restrict], uint8_t numshift, uint32_t len)</td></tr>
<tr class="memdesc:ga272359269ae91ec99cc4bdf2bf1b6ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function shifts each signed 16-bit element in vector right by k bits. The math is as follows: for ( i=0; i &lt; len; i++) { output[i] = input[i]&gt;&gt;k; }.  <a href="#ga272359269ae91ec99cc4bdf2bf1b6ddd">More...</a><br /></td></tr>
<tr class="separator:ga272359269ae91ec99cc4bdf2bf1b6ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3a5c0cc0ff8f08dfa600b23f5a15f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gace3a5c0cc0ff8f08dfa600b23f5a15f0">mmwavelib_shiftright32</a> (int32_t input[restrict], int32_t output[restrict], uint8_t numshift, uint32_t len)</td></tr>
<tr class="memdesc:gace3a5c0cc0ff8f08dfa600b23f5a15f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function shifts each signed 32-bit word in vector right by k bits. The math is as follows: for ( i=0; i &lt; len; i++) { output[i] = input[i]&gt;&gt;k; }.  <a href="#gace3a5c0cc0ff8f08dfa600b23f5a15f0">More...</a><br /></td></tr>
<tr class="separator:gace3a5c0cc0ff8f08dfa600b23f5a15f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade39bc3d31985fe57856fc2abe968bba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gade39bc3d31985fe57856fc2abe968bba">mmwavelib_shiftright32to16</a> (int32_t input[restrict], int16_t output[restrict], uint8_t numshift, uint32_t len)</td></tr>
<tr class="memdesc:gade39bc3d31985fe57856fc2abe968bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function shifts each signed 32-bit word in vector right by k bits, and store the lower 16bits only. The math is as follows: for ( i=0; i &lt; len; i++) { output[i] = (int16_t)(input[i]&gt;&gt;k); }.  <a href="#gade39bc3d31985fe57856fc2abe968bba">More...</a><br /></td></tr>
<tr class="separator:gade39bc3d31985fe57856fc2abe968bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ef502b1920c086d1e12483276ec4181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga9ef502b1920c086d1e12483276ec4181">mmwavelib_vecmul16x16</a> (int16_t *restrict x, const int16_t *restrict w, uint32_t nx)</td></tr>
<tr class="memdesc:ga9ef502b1920c086d1e12483276ec4181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function multiply two 16-bit complex vectors element by element. The math is as follows: for ( i=0; i &lt; nx; i++) { outreal[i] = sat((inreal[i]*wreal[i]-inimag[i]*wimag[i]+0x4000)*2)/2^16; outimag[i] = sat((inreal[i]*wimag[i]+inimag[i]*wreal[i]+0x4000)*2)/2^16; }.  <a href="#ga9ef502b1920c086d1e12483276ec4181">More...</a><br /></td></tr>
<tr class="separator:ga9ef502b1920c086d1e12483276ec4181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14c99972390f53e06dffa11d319e69be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga14c99972390f53e06dffa11d319e69be">mmwavelib_vecmul16x32</a> (const int16_t *restrict x, int32_t *restrict w, int32_t *restrict y, uint32_t nx)</td></tr>
<tr class="memdesc:ga14c99972390f53e06dffa11d319e69be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs element-wise complex multiplication on a 16bit vector and a 32bit vector. The math is as follows: for ( i=0; i &lt; nx; i++) { yreal[i] = round(xreal[i]*wreal[i]/2^15)-round(ximag[i]*wimag[i]/2^15); yimag[i] = round(xreal[i]*wimag[i]/2^15)+round(ximag[i]*wreal[i]/2^15); }.  <a href="#ga14c99972390f53e06dffa11d319e69be">More...</a><br /></td></tr>
<tr class="separator:ga14c99972390f53e06dffa11d319e69be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga986a2fa2e49a16a32a0aabbe6de62ddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga986a2fa2e49a16a32a0aabbe6de62ddf">mmwavelib_vecmul16x32_anylen</a> (const uint32_t *restrict x, int64_t *restrict w, int64_t *restrict y, uint32_t len)</td></tr>
<tr class="memdesc:ga986a2fa2e49a16a32a0aabbe6de62ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs element-wise complex multiplication on a 16bit vector and a 32bit vector. The math is as follows: for ( i=0; i &lt; nx; i++) { yreal[i] = round(xreal[i]*wreal[i]/2^15)-round(ximag[i]*wimag[i]/2^15); yimag[i] = round(xreal[i]*wimag[i]/2^15)+round(ximag[i]*wreal[i]/2^15); }.  <a href="#ga986a2fa2e49a16a32a0aabbe6de62ddf">More...</a><br /></td></tr>
<tr class="separator:ga986a2fa2e49a16a32a0aabbe6de62ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37dcc6e41dca0b7c258f791e9f872983"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga37dcc6e41dca0b7c258f791e9f872983">mmwavelib_vecmul32x16c</a> (const uint32_t x, int64_t *restrict w, int64_t *restrict y, uint32_t len)</td></tr>
<tr class="memdesc:ga37dcc6e41dca0b7c258f791e9f872983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function multiplies a 16bit complex constant to a 32bit complex vector. The math is as follows: for ( i=0; i &lt; nx; i++) { yreal[i] = round(xreal*wreal[i]/2^15)-round(ximag*wimag[i]/2^15); yimag[i] = round(xreal*wimag[i]/2^15)+round(ximag*wreal[i]/2^15); }.  <a href="#ga37dcc6e41dca0b7c258f791e9f872983">More...</a><br /></td></tr>
<tr class="separator:ga37dcc6e41dca0b7c258f791e9f872983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ce192512cf33bfd3013bee87903d28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gae2ce192512cf33bfd3013bee87903d28">mmwavelib_vecsub16</a> (int16_t *restrict input1, int16_t *restrict input2, int16_t *restrict output, int32_t len)</td></tr>
<tr class="memdesc:gae2ce192512cf33bfd3013bee87903d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_vecsub16.  <a href="#gae2ce192512cf33bfd3013bee87903d28">More...</a><br /></td></tr>
<tr class="separator:gae2ce192512cf33bfd3013bee87903d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3abbe77f0716d7a664d3b517281034c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga3abbe77f0716d7a664d3b517281034c4">mmwavelib_vecsubc</a> (int16_t *restrict input, int16_t *restrict output, const uint32_t subval, int32_t ncplx)</td></tr>
<tr class="memdesc:ga3abbe77f0716d7a664d3b517281034c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_vecsubc.  <a href="#ga3abbe77f0716d7a664d3b517281034c4">More...</a><br /></td></tr>
<tr class="separator:ga3abbe77f0716d7a664d3b517281034c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga629b301147256390e4b0fd894df8c089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#ga629b301147256390e4b0fd894df8c089">mmwavelib_vecsum</a> (const int16_t input[restrict], int32_t output[restrict], int32_t ncplx)</td></tr>
<tr class="memdesc:ga629b301147256390e4b0fd894df8c089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_vecsum.  <a href="#ga629b301147256390e4b0fd894df8c089">More...</a><br /></td></tr>
<tr class="separator:ga629b301147256390e4b0fd894df8c089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf66af7cbc8b38fd72a0077a3eae305d3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___m_m_w_a_v_e_l_i_b___v_e_c___u_t_i_l_s.html#gaf66af7cbc8b38fd72a0077a3eae305d3">mmwavelib_vecsumabs</a> (const int16_t input[], int32_t len)</td></tr>
<tr class="memdesc:gaf66af7cbc8b38fd72a0077a3eae305d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function Name : mmwavelib_vecsumabs.  <a href="#gaf66af7cbc8b38fd72a0077a3eae305d3">More...</a><br /></td></tr>
<tr class="separator:gaf66af7cbc8b38fd72a0077a3eae305d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Vector arithmetic functions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga7a0caca055eef56c597d066bef6f3167"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_accum16 </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>inp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>out</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function mmwavelib_accum16 accumlates input vector to the output vector. It is the optimized implementation of the for loop: for ( idx=0; idx&lt;len; idx++ ) { out[idx] += inp[idx];//addition saturated to 0xFFFF }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inp</td><td>: input vector of 16-bit samples </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>: output vector of 16-bit samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: number of samples in vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Input and output arrays both are 8 byte aligned </dd>
<dd>
(2)Array length (len) is a multiple of 4</dd></dl>
<p>Cycles 1.1N+40 </p>

</div>
</div>
<a class="anchor" id="ga4b2fd00fe176f2f406369b63e983ed43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_accum16to32 </td>
          <td>(</td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>input</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>output</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function accumlates(adds) 16-bit input vector to the 32-bit output vector. It is the optimized implementation of the for loop: for ( i = 0; i &lt; len; i++ ) { output[i] += input[i]; }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: input vector of 16-bit samples </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">output</td><td>: output vector of 32-bit samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: number of samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output arrays both are 8 byte aligned. </dd>
<dd>
(2)len is a multiple of 2.</dd></dl>
<p>Cycles 0.75*len + 58 (cgt 8.1.3) </p>

</div>
</div>
<a class="anchor" id="gac73796cc03472f1c27897d572c2c8322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_accumPowerFltp </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>accumFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>inputPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>outputPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function mmwavelib_accumPowerFltp accumulates signal power of the input signal . </p>
<hr/>
<p> if (accumFlag==0) { for (j = 0; j &lt; length; j++) outputPtr[j]=inputPtr[2*j]^2+inputPtr[2*j+1]^2; } else //accuFlag !=0 { for (j = 0; j &lt; length; j++) outputPtr[j]+=(inputPtr[2*j]^2+inputPtr[2*j+1]^2); }</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>: Input complex signal length. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accumFlag</td><td>: if 0, initialize the output as the input signal power if not 0, accumulate the input signal power to output power </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputPtr</td><td>: floating-point I/Q complex signal input, size of length*2, Must be aligned to 8-byte boundary. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputPtr</td><td>: accumulated power output (non-coherent combining). Must be aligned to 8-byte boundary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)inputPtr and outputPtr arrays both are 8 byte aligned</dd></dl>
<p>Cycles (cgt 8.1.3) 1) accumFlag=0, 1*length+36 2) accumFlag!=0, 1.5*length+49</p>
<hr/>
 
</div>
</div>
<a class="anchor" id="ga048b44d24170630317ca0b1589a285af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_accumPowerFltpAllAnt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fftSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>numAnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>inputPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>outputPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function mmwavelib_accumPowerFltpAllAnt accumulates number of fftSize signal power over all antenna. It can be called per range bin or dopper bin. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fftSize</td><td>: Input FFT sizes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numAnt</td><td>: number of accumulated RX antennas. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputPtr</td><td>: floating-point I/Q complex signal input, size of fftSize*2*numAnt the data is stored one antenna after another. Must be aligned to 8-byte boundary. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outputPtr</td><td>: accumulated power output (non-coherent combining). Must be aligned to 8-byte boundary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)inputPtr and outputPtr arrays both are 8 byte aligned</dd></dl>
<p>Cycles L1P and L1D cache is set to 32K. Input and output are all floating point version. (8.1.3) 1 Antenna: 1*fftsize+61, 2 Antenna: 2.5*fftsize+90, except 1024 with 4224 4 Antenna: 4.08*fftsize+53 except 1024 with 27076 8 Antenna: 9.16*fftsize+61, except 512 with 39526, and 1024 with 83316 </p>

</div>
</div>
<a class="anchor" id="ga60b15223a93ce22679cf523c311d97a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_dcRemovalFloat </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ncplx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_dcRemovalFloat. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Calculate the average (dc value) of 32-bit float complex vector (by sum all complex values and divide it by ncplx) and remove i.e subtract it from each input complex value. The math is as follows: for ( i=0; i &lt; ncplx; i++) { sumI += input[2*i]; sumQ += input[2*i+1]; } avgI = sumI/ncplx; avgQ = sumQ/ncplx; for ( i=0; i &lt; ncplx; i++) { output[2*i] = input[2*i] - avgI; output[2*i+1] = input[2*i+1] - avgQ; } The order of I&amp;Q in output is same as that in input.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ncplx</td><td>: Number of complex elements in input/output array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input array (e.g. each float 32bit I followed by float 32bit Q) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: Output array, can be the same array as input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output are 8 byte aligned. </dd>
<dd>
(2)input and output point to either the same array, or two arrays that do not overlap with each other.</dd></dl>
<p>Cycles (cgt8.1.3) 4.5*N + ovh, for N%8 = 0; 3.5*N + ovh, for N%8 = 2,4, 4*N + ovh, for N%8 = 6; for odd number N&gt;1, cycles are same as the cycles for (N-1); where N=ncplx; overhead cycles ovh=84 to 89. </p>

</div>
</div>
<a class="anchor" id="ga296a4ffed31c9015b34581b6712dc0cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_histogram </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>input</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hist</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>histTemp</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>inpLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>histLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numshift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function calculates the histogram of the right-shifted input array The math is as follows: for ( i=0; i &lt; len; i++) { hist[input[i]&gt;&gt;k] ++; }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: input array of unsigned 16-bit elements. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hist</td><td>: output histogram array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">histTemp</td><td>: temp scratch buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inpLen</td><td>: number of 16-bit elements in input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">histLen</td><td>: length of historgram, = 1&lt;&lt;(16-numshift) normally. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numshift</td><td>: number of bits to be right-shifted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and histTemp are 8 byte aligned. </dd>
<dd>
(2)inpLen is multiple of 8, and histLen is multiple of 2. </dd>
<dd>
(3)histTemp buffer's length is 8*histLen.</dd></dl>
<p>Cycles inpLen*1.125 + histLen*2.75 + overhead (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="gac8c76050f4862b78d1f05325be3a4237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_maxpow </td>
          <td>(</td>
          <td class="paramtype">const int32_t *restrict&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>Ncplx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>maxpow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_maxpow. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Find from 32bit complex vector the maximum sample power(I^2+Q^2), and the index of the corresponding complex sample. The math is as follows: for ( i=0; i &lt; Ncplx; i++) { pow = input[2*i]*input[2*i] + input[2*i+1]*input[2*i+1]; if (pow &gt; max) {maxpow = pow; maxidx = i;} }</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input array of complex samples (32bit I 32bit Q or vice versa). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ncplx</td><td>: Number of complex elements in input. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxpow</td><td>: Output pointer to store the maximum power found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the index of the complex input sample that has the max I^2+Q^2.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input is 8 byte aligned. </dd>
<dd>
(2)Ncplx is a multiple of 2.</dd></dl>
<p>Cycles 1.5*Ncplx + 46 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="gab517cd68c46c2007015f54b888675612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mmwavelib_multiPeakSearch </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>peakIdxBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t&#160;</td>
          <td class="paramname"><em>thresholdScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_multiPeakSearch. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Find from 32bit float vector the peaks that have value satisfies: x[i] &gt;= x[i-1] &amp; mask and x[i] &gt;= x[i+1] &amp; mask and x[i] &gt; the maximum value in vector * thresholdScale where mask = len-1.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input array of float values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">peakIdxBuf</td><td>output buffer to store the index of detected peaks. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of elements in input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thresholdScale</td><td>maximum value multiplied by this will be the threshold for search other peaks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the number of detected peaks.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input array x is 8 byte aligned. </dd>
<dd>
(2)len is a multiple of 4. </dd>
<dd>
(3)Maximum value max(x)&gt;0.0. </dd>
<dd>
(4)0.0 &lt;=thresholdScale &lt;=1.0.</dd></dl>
<p>Cycles 11.75*len +53 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga17fbdf17581d9b6afd131287118cac41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_power </td>
          <td>(</td>
          <td class="paramtype">int32_t *restrict&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>Ncplx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *restrict&#160;</td>
          <td class="paramname"><em>outpowbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_power. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Calculate sample power(I^2+Q^2) for each 32bit complex sample in vector. The math is as follows: for ( i=0; i &lt; Ncplx; i++) { power[i] = (float32_t)input[2*i]*input[2*i];<ul>
<li>(float32_t)input[2*i+1]*input[2*i+1]; }</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input array of complex samples (32bit I 32bit Q or vice versa). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ncplx</td><td>: Number of complex elements in input array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outpowbuf</td><td>: Output buffer to store sample powers in float type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and outpowbuf are 8 byte aligned. </dd>
<dd>
(2)Ncplx is a multiple of 2.</dd></dl>
<p>Cycles 1.5*Ncplx + 45 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga2c47f4edbcd1317fde1d38d727bbdfce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_power_float </td>
          <td>(</td>
          <td class="paramtype">float32_t *restrict&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>Ncplx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *restrict&#160;</td>
          <td class="paramname"><em>outpowbuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_power_float. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Calculate sample power(I^2+Q^2) for each float complex sample in vector. The math is as follows: for ( i=0; i &lt; Ncplx; i++) { power[i] = input[2*i]*input[2*i] + input[2*i+1]*input[2*i+1]; }</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input array of floating point complex samples. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ncplx</td><td>: Number of complex elements in input array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outpowbuf</td><td>: Output buffer to store sample powers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and outpowbuf are 8 byte aligned. </dd>
<dd>
(2)Ncplx is a multiple of 2.</dd></dl>
<p>Cycles 1*Ncplx + 41 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga920a1def3c0071fb9de8e1579a809f69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_powerAndMax </td>
          <td>(</td>
          <td class="paramtype">const int32_t *restrict&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>Ncplx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *restrict&#160;</td>
          <td class="paramname"><em>outpowbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>maxpow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_powerAndMax. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Find from 32bit complex vector the maximum sample power(I^2+Q^2), and the index of the corresponding complex sample. The sample power of each complex sample will be stored to output buffer which is the difference between this function and mmwavelib_maxpow. The math is as follows: for ( i=0; i &lt; Ncplx; i++) { power[i] = input[2*i]*input[2*i] + input[2*i+1]*input[2*i+1]; if (power[i] &gt; max) {maxpow = pow; maxidx = i;} }</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input array of complex samples (32bit I 32bit Q or vice versa). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ncplx</td><td>: Number of complex elements in input. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outpowbuf</td><td>: Output buffer to store sample powers in float type. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxpow</td><td>: Output pointer to store the maximum power found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the index of the complex input sample that has the maximum power.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and outpowbuf are 8 byte aligned. </dd>
<dd>
(2)Ncplx is a multiple of 2.</dd></dl>
<p>Cycles 1.5*Ncplx + 51 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga8fe267edb07f90ab94276dbe090d9c44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_secondPeakSearch </td>
          <td>(</td>
          <td class="paramtype">float32_t *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>maxIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_secondPeakSearch. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Find from 32bit float vector the second peak and return its index i. A peak satisfies: x[i] &gt; x[i-1] &amp; lenLess1 and x[i] &gt; x[i+1] &amp; lenLess1 where lenLess1 = len-1 The second peak x[i] &lt;= x[maxIdx] but greater than all other peaks.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Input array of float values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of elements in input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxIdx</td><td>Index of the element with the maximum value in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the index of the second peak.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Elements in x are all &gt;=0. </dd>
<dd>
(2)len is a multiple of 2.</dd></dl>
<p>Cycles 4*len + 100 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga272359269ae91ec99cc4bdf2bf1b6ddd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_shiftright16 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>input</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>output</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numshift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function shifts each signed 16-bit element in vector right by k bits. The math is as follows: for ( i=0; i &lt; len; i++) { output[i] = input[i]&gt;&gt;k; }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: Output array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numshift</td><td>: Number of bits to be right-shifted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of 16-bit elements in input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output are 8 byte aligned. </dd>
<dd>
(2)len is a multiple of 8.</dd></dl>
<p>Cycles 0.25*len + 32 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="gace3a5c0cc0ff8f08dfa600b23f5a15f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_shiftright32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>input</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>output</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numshift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function shifts each signed 32-bit word in vector right by k bits. The math is as follows: for ( i=0; i &lt; len; i++) { output[i] = input[i]&gt;&gt;k; }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: Output array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numshift</td><td>: Number of bits to be right-shifted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of 32-bit words in input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output are 8 byte aligned. </dd>
<dd>
(2)len is a multiple of 4.</dd></dl>
<p>Cycles 0.5*len + 32 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="gade39bc3d31985fe57856fc2abe968bba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_shiftright32to16 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>input</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>output</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numshift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function shifts each signed 32-bit word in vector right by k bits, and store the lower 16bits only. The math is as follows: for ( i=0; i &lt; len; i++) { output[i] = (int16_t)(input[i]&gt;&gt;k); }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input 32-bit array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: Output 16-bit array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numshift</td><td>: Number of bits to be right-shifted. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of 32-bit words in input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output are 8 byte aligned. </dd>
<dd>
(2)input and output either are the same i.e. results are written inplace to first half of input array, or do not overlap with each other. </dd>
<dd>
(3)len is a multiple of 2.</dd></dl>
<p>Cycles (cgt8.1.3) 0.5*len + 51 for len%4=0 and len+2 has same cycles as len. 40 for len=2. </p>

</div>
</div>
<a class="anchor" id="ga9ef502b1920c086d1e12483276ec4181"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_vecmul16x16 </td>
          <td>(</td>
          <td class="paramtype">int16_t *restrict&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t *restrict&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function multiply two 16-bit complex vectors element by element. The math is as follows: for ( i=0; i &lt; nx; i++) { outreal[i] = sat((inreal[i]*wreal[i]-inimag[i]*wimag[i]+0x4000)*2)/2^16; outimag[i] = sat((inreal[i]*wimag[i]+inimag[i]*wreal[i]+0x4000)*2)/2^16; }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>: Input array. Output will be written in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>: The second input array, e.g. the array of windowing coefficients. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nx</td><td>: Number of complex elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)Arrays are 8 byte aligned. </dd>
<dd>
(2)nx is a multiple of 4. </dd>
<dd>
(3)Imaginary/real components are stored in adjacent locations in the arrays. The imaginary components are stored at even array indices, and the real components are stored at odd array indices.</dd></dl>
<p>Cycles 0.75*nx + 38 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga14c99972390f53e06dffa11d319e69be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_vecmul16x32 </td>
          <td>(</td>
          <td class="paramtype">const int16_t *restrict&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *restrict&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *restrict&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performs element-wise complex multiplication on a 16bit vector and a 32bit vector. The math is as follows: for ( i=0; i &lt; nx; i++) { yreal[i] = round(xreal[i]*wreal[i]/2^15)-round(ximag[i]*wimag[i]/2^15); yimag[i] = round(xreal[i]*wimag[i]/2^15)+round(ximag[i]*wreal[i]/2^15); }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: Pointer to 16-bit input array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>: Pointer to 32-bit input array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>: Pointer to 32-bit output array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nx</td><td>Number of complex elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output arrays are 8 byte aligned. </dd>
<dd>
(2)nx is a multiple of 4. </dd>
<dd>
(3)Input x,w: The imaginary components are stored at even array indices, and the real components are stored at odd array indices. Output y: The real components are stored at even array indices, and the imaginary components are stored at odd array indices.</dd></dl>
<p>Cycles 1.5*nx + 43 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga986a2fa2e49a16a32a0aabbe6de62ddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_vecmul16x32_anylen </td>
          <td>(</td>
          <td class="paramtype">const uint32_t *restrict&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *restrict&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *restrict&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function performs element-wise complex multiplication on a 16bit vector and a 32bit vector. The math is as follows: for ( i=0; i &lt; nx; i++) { yreal[i] = round(xreal[i]*wreal[i]/2^15)-round(ximag[i]*wimag[i]/2^15); yimag[i] = round(xreal[i]*wimag[i]/2^15)+round(ximag[i]*wreal[i]/2^15); }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: Pointer to 16-bit complex input array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>: Pointer to 32-bit complex input array. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>: Pointer to 32-bit complex output array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of complex elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output arrays are 8 byte aligned. </dd>
<dd>
(2)x: The imaginary components are in lower 16bits of 32bits, and the real components are in higher 16bits of 32bits. w, y: The real components are in lower 32bits of 64bits, and the imaginary components are in higher 32bits of 64bits.</dd></dl>
<p>Cycles 2.25*len + 50 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="ga37dcc6e41dca0b7c258f791e9f872983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_vecmul32x16c </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *restrict&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *restrict&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function multiplies a 16bit complex constant to a 32bit complex vector. The math is as follows: for ( i=0; i &lt; nx; i++) { yreal[i] = round(xreal*wreal[i]/2^15)-round(ximag*wimag[i]/2^15); yimag[i] = round(xreal*wimag[i]/2^15)+round(ximag*wreal[i]/2^15); }. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: constant complex value.16bitI|16bitQ packed in 32bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>: Pointer to input array. 32bitQ|32bitI packed in each 64bits. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">y</td><td>: Pointer to output array. 32bitQ|32bitI packed in each 64bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of complex elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output arrays are 8 byte aligned. </dd>
<dd>
(2)x: The imaginary component is in lower 16bits of 32bits, and the real component is in higher 16bits of 32bits. w and y: The real components are in lower 32bits of 64bits, and the imaginary components are in higher 32bits of 64bits.</dd></dl>
<p>Cycles 2*len + 54 (cgt8.1.3) </p>

</div>
</div>
<a class="anchor" id="gae2ce192512cf33bfd3013bee87903d28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_vecsub16 </td>
          <td>(</td>
          <td class="paramtype">int16_t *restrict&#160;</td>
          <td class="paramname"><em>input1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *restrict&#160;</td>
          <td class="paramname"><em>input2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *restrict&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_vecsub16. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : 16-bit vector subtraction. The math is as follows: output[n]= input1[n] - input2[n]; The function can also be used for complex vector (16bit I 16bit Q), as long as input1 and input2 have the same I/Q order. (2*number of complex samples) shall be len for the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input1</td><td>: pointer to first input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input2</td><td>: pointer to second input array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: pointer to output, can be the same array as input1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of 16-bit elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input1, input2 and output 8 byte aligned. </dd>
<dd>
(2)input1 and output either point to the same array or do not overlap with each other, and they don't overlap with input2. </dd>
<dd>
(3)len is multiple of 2.</dd></dl>
<p>Cycles (cgt8.1.3) 0.375*len +ovh, ovh=~45(len%8=0) +8.25,9.5 or 10.75(if len%8=2,4,or 6) </p>

</div>
</div>
<a class="anchor" id="ga3abbe77f0716d7a664d3b517281034c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_vecsubc </td>
          <td>(</td>
          <td class="paramtype">int16_t *restrict&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *restrict&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>subval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ncplx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_vecsubc. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Subtract const value from each element in 16-bit complex vector. The math is as follows: output_real[n]= input_real[n] - subval_real; output_imag[n]= input_imag[n] - subval_imag; The function can be used for 16-bit real vector too, by simply pack two subval_real in 32-bit subval.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: pointer to input array (e.g. 16bit I followed by 16bit Q) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: pointer to output, can be the same array as input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subval</td><td>: Packed value to be subtracted (e.g. Q in high 16, I in low 16) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ncplx</td><td>: Number of complex elements</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output 8 byte aligned. </dd>
<dd>
(2)ncplx is a multiple of 4.</dd></dl>
<p>Cycles 0.5*Ncplx + ovh (0.25*NumOf16bitElements + ovh), ovh=~40 cgt8.1.3 </p>

</div>
</div>
<a class="anchor" id="ga629b301147256390e4b0fd894df8c089"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmwavelib_vecsum </td>
          <td>(</td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>input</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>output</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ncplx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_vecsum. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Sum the elements in 16-bit complex vector. The math is as follows: for ( i=0; i &lt; ncplx; i++) { output[0] += input[2*i]; output[1] += input[2*i+1]; } The order of I&amp;Q in output is same as that in input. The function can be used for 16-bit real vector too, and user can simply do output[0]+output[1] after the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input complex array (e.g.16bit I followed by 16bit Q each). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ncplx</td><td>: Number of complex elements in input. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>: Output sum (e.g. 32bit sum I followed by 32bit sum Q).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input and output are 8 byte aligned. </dd>
<dd>
(2)Number of complex elements is a multiple of 4.</dd></dl>
<p>Cycles 0.5*Ncplx + ovh (0.25*NumOf16bitElements + ovh), ovh=~30 cgt8.1.3 </p>

</div>
</div>
<a class="anchor" id="gaf66af7cbc8b38fd72a0077a3eae305d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mmwavelib_vecsumabs </td>
          <td>(</td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>input</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function Name : mmwavelib_vecsumabs. </p>
<hr/>
 <dl class="section user"><dt></dt><dd><b>Description</b> : Sum the absolute values of 16-bit elements in vector. The math is as follows: for ( i=0; i &lt; len; i++) { sum += abs(input[i]); }</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>: Input array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>: Number of 16-bit elements in input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the 32-bit sum</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>(1)input is 8 byte aligned. </dd>
<dd>
(2)len is a multiple of 4.</dd></dl>
<p>Cycles 0.25*len + ovh, ovh=37 cgt8.1.3 </p>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
