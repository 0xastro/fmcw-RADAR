<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Object Detection Data-path Processing Chain (DPC)</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Object Detection Data-path Processing Chain (DPC) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="objdetintro"></a>
Introduction</h1>
<p>The Object detection DPC provides the functionality of processing ADC samples to detected objects during the frame acquisition and inter-frame processing periods. It can be used by the application by registering with the DPM framework and invoked using DPM APIs. The external interface of Object detection DPC can be seen at <a class="el" href="group___d_p_c___o_b_j_d_e_t___e_x_t_e_r_n_a_l.html">Object Detection DPC (Data-path Processing Chain) External</a></p>
<h1><a class="anchor" id="objdethwa_datapath"></a>
Data Path</h1>
<div class="image">
<img src="object_detection_datapath.png" alt="object_detection_datapath.png"/>
<div class="caption">
Object Detection Data Path Processing Chain</div></div>
<p> <br />
 <br />
 The data path processing consists of:</p><ul>
<li>Processing during the chirps as seen in the timing diagram:<ul>
<li>This consists of 1D (range) FFT processing that takes input from multiple receive antennae from the ADC buffer for every chirp (corresponding to the chirping pattern on the transmit antennae) and performs FFT on it and generates output into the L3 RAM in the format defined by <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpc/dpu/dopplerproc/docs/dopplerproc.tag:../../../../../dpu/dopplerproc/docs/doxygen/html/" href="../../../../../dpu/dopplerproc/docs/doxygen/html/group___d_p_i_f___r_a_d_a_r_c_u_b_e___f_o_r_m_a_t.html#ga4f1cc2e5019a697f3cafa1cecdf3b144">DPIF_RADARCUBE_FORMAT_1</a>. For more details, see the doxygen documentation of range processing DPU (Data Path Unit) located at: <pre class="fragment">   ti/datapath/dpu/rangeproc/docs/doxygen/html/index.html</pre></li>
</ul>
</li>
<li>Processing during the time between the end of chirps until the beginning of the next chirping period, shown as "Inter frame Period" in the timing diagram. This processing consists of:<ul>
<li>Static clutter removal when enabled, removes all static objects from the scene. For more details, see: <pre class="fragment">      ti/datapath/dpc/dpu/staticclutterproc/docs/doxygen/html/index.html</pre></li>
<li>2D (velocity) FFT processing that takes input from 1D output in L3 RAM and performs FFT to give a (range,velocity) matrix in the L3 RAM. For more details, see: <pre class="fragment">      ti/datapath/dpc/dpu/dopplerproc/docs/doxygen/html/index.html</pre></li>
<li>CFAR processing and peak grouping on detection matrix output of doppler processing. For more details, see: <pre class="fragment">      ti/datapath/dpc/dpu/cfarcaproc/docs/doxygen/html/index.html</pre></li>
<li>Angle (Azimuth, Elevation) of Arrival processing to produce a final list of detected objects with position coordinates (x,y,z) and velocity. For more details, see: <pre class="fragment">      ti/datapath/dpc/dpu/aoaproc/docs/doxygen/html/index.html</pre></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="appdpcFlow"></a>
Application-DPC Execution Flow</h1>
<p>Following diagram shows the application-DPC execution Flow.</p>
<div class="image">
<img src="dpc_flow.png" alt="dpc_flow.png"/>
<div class="caption">
Application-DPC Execution Flow</div></div>
<p> The flow above shows the sequencing of initialization, configuration, execution and dynamic control operations of the DPC and some level of detail of what happens under these operations. Most of the hardware resource (e.g HWA, EDMA related) configuration for the DPUs that is issued by the DPC as part of processing <a class="el" href="group___d_p_c___o_b_j_d_e_t___i_o_c_t_l_____c_o_m_m_a_n_d.html#ga80aa6076fb941f1be8943b04e7e91446">DPC_OBJDET_IOCTL__STATIC_PRE_START_CFG</a> commands is provided by the application at build time using a resource file (DPC sources are built as part of building the application, there is no separate DPC library object). This file is passed as a compiler command line define </p><pre class="fragment">--define=APP_RESOURCE_FILE="fileName" </pre><p> The "fileName" above includes the path as if to include the file when building the the DPC sources as part of building the application, and any DPC source that needs to refer to this file (currently <a class="el" href="objectdetection_8c.html">objectdetection.c</a>) has the following code </p><pre class="fragment">#include APP_RESOURCE_FILE </pre><p> One of the demos that uses this DPC is located at ti/demo/xwr68xx/mmw. The resource file in this demo is mmw_res.h, this file shows all the definitions that are needed by the DPC from the application. This file is provided on compiler command line when building as follows: </p><pre class="fragment">--define=APP_RESOURCE_FILE="&lt;ti/demo/xwr68xx/mmw/mmw_res.h&gt;" </pre><p>The partitioning of L3 and Core Local RAM (hitherto referred in short as LRAM) memories provided by the application (in <a class="el" href="struct_d_p_c___object_detection___init_params__t.html#a747cb5f37bb064c1d8e21446f1010971">DPC_ObjectDetection_InitParams_t::L3ramCfg</a> and <a class="el" href="struct_d_p_c___object_detection___init_params__t.html#a9a7a77461ef3647a4eceec71267e709e">DPC_ObjectDetection_InitParams_t::CoreLocalRamCfg</a>) during <a class="el" href="group___d_p_c___o_b_j_d_e_t_____i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gab3688b470b396b17d361ff868aaaafe1">DPC_ObjectDetection_init</a> (invoked by application through <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/control/dpm/docs/dpm.tag:../../../../../../../control/dpm/docs/doxygen/html/" href="../../../../../../../control/dpm/docs/doxygen/html/group___d_p_m___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga4b9d232412d832c17c606c733792ab2c">DPM_init</a>) happens during the processing of <a class="el" href="group___d_p_c___o_b_j_d_e_t___i_o_c_t_l_____c_o_m_m_a_n_d.html#ga80aa6076fb941f1be8943b04e7e91446">DPC_OBJDET_IOCTL__STATIC_PRE_START_CFG</a> command and is shown in the following figure. The allocation from application system heap (typically in LRAM) using the MemoryP_osal API is done during <a class="el" href="group___d_p_c___o_b_j_d_e_t_____i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gab3688b470b396b17d361ff868aaaafe1">DPC_ObjectDetection_init</a> (object instances of DPC and DPUs for all sub-frames) and during the processing of <a class="el" href="group___d_p_c___o_b_j_d_e_t___i_o_c_t_l_____c_o_m_m_a_n_d.html#gadd76b7822011f2beb6aa4ee56e34f1fd">DPC_OBJDET_IOCTL__STATIC_PRE_START_COMMON_CFG</a> command (range DPUs dc antenna coupling signature buffer that is unique for each sub-frame) is also shown in the figure.</p>
<div class="image">
<img src="memory_allocation.png" alt="memory_allocation.png"/>
<div class="caption">
Data memory allocation</div></div>
<p> In the above picture, the LRAM shows allocation of the "cfarRngDopSnrList" (<a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpu/rangeproc/docs/rangeproc.tag:../../../../../../dpu/rangeproc/docs/doxygen/html/" href="../../../../../../dpu/rangeproc/docs/doxygen/html/struct_d_p_i_f___c_f_a_r_det_list__t.html">DPIF_CFARDetList_t</a>) outside of scratch usage as this is shared buffer between CFAR and AoA in the processing flow and therefore needs to persist within the sub-frame until AoA is executed at the end of the processing chain. The buffers labeled "windowBuffer" in the picture for range and doppler DPUs are consumed during the DPU config processing into the HWA config RAM (sequentially) and so could be generated in local stack memory but this would require large stack depth, so the LRAM is used instead. The AoA interface buffers are allocated from the LRAM from the end of windowBuffer of the doppler DPU (that is configured prior to the AoA configuration) because AoA needs to be provided the same window as that of doppler as it uses it to recompute the 2D doppler FFT. This sequencing and arrangement in memory prevents window recomputation for AoA, although AoA will (redundant to doppler DPU) recopy the window to the HWA config RAM at the same window RAM offset as that of the doppler DPU. The AoA DPU API has been designed to require 2D-FFT window configuration (i.e window configuration is not optional) because it may be used in contexts (unit test, other DPC flavors) where doppler processing may not exist. The AoA interface buffers are consumed by the application at the end of the DPC execute API.</p>
<h2><a class="anchor" id="reconfig"></a>
DPU reconfiguration related to data path processing within and across sub-frames</h2>
<p>When number of transmit antennas is 3 (versus less than 3), the HWA resources (param sets) between CFAR and AoA are overlapped because total HWA param sets needed for all the DPUs exceeds the total available in the HWA (16). In this case, within each sub-frame's processing (in the DPC's execute API implementation), the CFAR and AoA's HWA configuration on overlapping param sets needs to be redone before invoking their process APIs. Currently there are no special partial configuration APIs for DPUs to just reconfigure the desired overlapping param sets, the full DPU configuration (xxx_config) must be issued (this includes for example FFT window configuration in relevant DPUs). Additionally, such a case of reconfiguration is also required when switching sub-frames because all HWA param sets and EDMA resources are overlapped across sub-frames. Note that the DPU's xxx_config API is a full configuration API beyond the HWA and EDMA resources configuration (e.g static and dynamic configuration) so restricting to the full configuration would imply that no sub-frame specific DPU instantiation is necessary. However, the code illustrates separate instances of DPUs for each sub-frame to demonstrate generality of the sub-frame solution, in the case where there may be specialized (partial) configuration APIs in an optimized implementation (that only configured the overlapped EDMA/HWA resources). The limiting to full configuration also means that all the code required to build the configuration structures of the DPUs during the pre-start config time either has to be repeated or alternatively, the configurations that were created during the pre-start config processing be saved and reused later. The latter path has been taken, all DPU configuration that is built during the pre-start processing is stored in separate storage, this can be located at <a class="el" href="struct_sub_frame_obj__t.html#a37653d9d2f77b2b0d30203bf759dc483">SubFrameObj_t::dpuCfg</a>. However, parts of this reconfiguration that cannot be captured in this storage need to be repeated, namely, window generation (<a class="el" href="group___d_p_c___o_b_j_d_e_t_____i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gab1a6c01f7f111a19fb678a1fa9a19925">DPC_ObjDet_GenDopplerWindow</a>, <a class="el" href="group___d_p_c___o_b_j_d_e_t_____i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga2f463e6965f2ccf32cb5048bf38d33ac">DPC_ObjDet_GenRangeWindow</a>) and rx phase compensation (<a class="el" href="group___d_p_c___o_b_j_d_e_t_____i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga0bdebcef1961a77d81c74a30b637bf12">DPC_ObjDet_GetRxChPhaseComp</a>).</p>
<p>The DPU top-level dynamic configuration structure contains pointers to the individual configurations (e.g see <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpc/dpu/aoaproc/docs/aoaproc.tag:../../../../../dpu/aoaproc/docs/doxygen/html/" href="../../../../../dpu/aoaproc/docs/doxygen/html/struct_d_p_u___ao_a_proc___dynamic_config__t.html">DPU_AoAProc_DynamicConfig_t</a>) so DPC stores the dynamic configuration in pre-start config (<a class="el" href="struct_d_p_c___object_detection___dyn_cfg__t.html">DPC_ObjectDetection_DynCfg_t</a>) in permanent storage (<a class="el" href="struct_sub_frame_obj__t.html#a38b9e73ebf0b34a3c96a30d8b9f9df6d">SubFrameObj_t::dynCfg</a>) and DPUs are passed from this storage area so that their pointers point to this permanent storage during reconfiguration. The static configuration during pre-start config (<a class="el" href="struct_d_p_c___object_detection___static_cfg__t.html">DPC_ObjectDetection_StaticCfg_t</a>) is also stored (<a class="el" href="struct_sub_frame_obj__t.html#aba389f7f6362bb018619742cb4cf5677">SubFrameObj_t::staticCfg</a>) for convenient referencing when doing range bias and rx phase measurement (<a class="el" href="group___d_p_c___o_b_j_d_e_t_____i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gae36e17bc51634e4e4d155242f9d392da">DPC_ObjDet_rangeBiasRxChPhaseMeasure</a>) and the above referred rx ch phase computation during reconfiguration (<a class="el" href="group___d_p_c___o_b_j_d_e_t_____i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga0bdebcef1961a77d81c74a30b637bf12">DPC_ObjDet_GetRxChPhaseComp</a>). Saving this entire static configuration is probably more than necessary (versus storing only the parameters that need to be referred in the above mentioned functions) but it keeps implementation simpler/cleaner and may be useful in debugging.</p>
<h1><a class="anchor" id="objdethwa_calibration"></a>
Range Bias and Rx Channel Gain/Offset Measurement and Compensation</h1>
<p>Because of imperfections in antenna layouts on the board, RF delays in SOC, etc, there is need to calibrate the sensor to compensate for bias in the range estimation and receive channel gain and phase imperfections. The DPC provides the ability to do the measurement and compensation.</p>
<p><a class="anchor" id="Figure_calibration"></a> </p><div class="image">
<img src="calibration.png" alt="calibration.png"/>
<div class="caption">
Range Bias and Rx Channel Gain/Offset Measurement and Compensation</div></div>
 <h2><a class="anchor" id="measurement"></a>
Measurement</h2>
<p>If the measurement (<a class="el" href="struct_d_p_c___object_detection___measure_rx_channel_bias_cfg__t.html#a243bd494352d2138f1e01271810e1373">DPC_ObjectDetection_MeasureRxChannelBiasCfg_t::enabled</a>) is enabled in pre-start common config (<a class="el" href="struct_d_p_c___object_detection___pre_start_common_cfg__t.html#a6bc589fcc17d780889d452025fa6ee82">DPC_ObjectDetection_PreStartCommonCfg_t::measureRxChannelBiasCfg</a>) or dynamic config (<a class="el" href="group___d_p_c___o_b_j_d_e_t___i_o_c_t_l_____c_o_m_m_a_n_d.html#ga2c431f3f05cc138597dfdfc2ce33e49a">DPC_OBJDET_IOCTL__DYNAMIC_MEASURE_RANGE_BIAS_AND_RX_CHAN_PHASE</a>), it is assumed that a strong target like a corner reflector is kept at boresight at a distance of X = <a class="el" href="struct_d_p_c___object_detection___measure_rx_channel_bias_cfg__t.html#a7c264c66c0912800939ac2dc821323c4">DPC_ObjectDetection_MeasureRxChannelBiasCfg_t::targetDistance</a>. Peak search is done after the 2D FFT in the 0th Doppler of the detection matrix within distance D = <a class="el" href="struct_d_p_c___object_detection___measure_rx_channel_bias_cfg__t.html#ac3a21a07d41a24d7ba511b50d310d64d">DPC_ObjectDetection_MeasureRxChannelBiasCfg_t::searchWinSize</a> around X i.e peak is searched between -D/2 + X and X + D/2. The peak position is then used to compute the square root of the sum of the magnitude squares of the virtual antennas (taken from 1D-FFT Radar Cube matrix) for the peak and its two nearest neighbors. These three magnitudes and their positions are used to do parabolic interpolation to find the more accurate peak location from which the range bias is estimated as this interpolated peak position minus the configured target distance X. The rx channel phase and gain estimation is done by finding the minimum of the magnitude squared of the virtual antennas and this minimum is used to scale the individual antennas so that the magnitude of the coefficients is always less than or equal to 1. Rx channel compensation coefficients are calculated according to following equations. The radar cube matrix is laid out as four dimensional matrix defined as <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpc/dpu/dopplerproc/docs/dopplerproc.tag:../../../../../dpu/dopplerproc/docs/doxygen/html/" href="../../../../../dpu/dopplerproc/docs/doxygen/html/group___d_p_i_f___r_a_d_a_r_c_u_b_e___f_o_r_m_a_t.html#ga4f1cc2e5019a697f3cafa1cecdf3b144">DPIF_RADARCUBE_FORMAT_1</a>, i.e. as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mbox{RadarCube}[\mbox{numTxPatterns}][\mbox{numDopplerChirps}][\mbox{numRxAnt}][\mbox{numRangeBins}] \]" src="form_0.png"/>
</p>
<p>The received symbols are extracted from the 1D-FFT radar cube from the first chirp at the range index <img class="formulaInl" alt="$i_{Max}$" src="form_1.png"/>corresponding to the maximum in the searched range as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x(i_{Tx},i_{Rx}) = \mbox{RadarCube}(i_{Tx},0,i_{Rx},i_{Max}), \;\;\;\; i_{Tx}=0,...,N_{TxAnt}-1, \;\;\;\; i_{Rx}=0,...,N_{RxAnt}-1 \]" src="form_2.png"/>
</p>
<p>The coefficients are calculated as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ c(i_{Tx},i_{Rx}) = \frac{x^*(i_{Tx},i_{Rx})}{|x(i_{Tx},i_{Rx})|^2}\;x_{Min}, \;\;\;\; i_{Tx}=0,...,N_{TxAnt}-1, \;\;\;\; i_{Rx}=0,...,N_{RxAnt}-1 \]" src="form_3.png"/>
</p>
<p>where</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ x_{Min} = \min{|x(i_{Tx},i_{Rx})|} \]" src="form_4.png"/>
</p>
<p>The compensation rx coefficients are in Q15 format. Refer to the function <a class="el" href="group___d_p_c___o_b_j_d_e_t_____i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gae36e17bc51634e4e4d155242f9d392da">DPC_ObjDet_rangeBiasRxChPhaseMeasure</a> which performs the measurements, the measurement result (<a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpc/dpu/aoaproc/docs/aoaproc.tag:../../../../../dpu/aoaproc/docs/doxygen/html/" href="../../../../../dpu/aoaproc/docs/doxygen/html/struct_d_p_u___ao_a_proc__comp_rx_channel_bias_cfg__t.html">DPU_AoAProc_compRxChannelBiasCfg_t</a>) is given out of the DPC to the application as part of the result structure produced by DPC's execute API (<a class="el" href="struct_d_p_c___object_detection___execute_result__t.html#a1d115a7fd41c8f3998611247d0c800a2">DPC_ObjectDetection_ExecuteResult_t::compRxChanBiasMeasurement</a>). </p>
<h2><a class="anchor" id="compensation"></a>
Compensation</h2>
<p>When compensation configuration (<a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpc/dpu/aoaproc/docs/aoaproc.tag:../../../../../dpu/aoaproc/docs/doxygen/html/" href="../../../../../dpu/aoaproc/docs/doxygen/html/struct_d_p_u___ao_a_proc__comp_rx_channel_bias_cfg__t.html">DPU_AoAProc_compRxChannelBiasCfg_t</a>) is provided as part of pre-start common config (<a class="el" href="struct_d_p_c___object_detection___pre_start_common_cfg__t.html#a2e483e5e8979be44d7ed778369a3c672">DPC_ObjectDetection_PreStartCommonCfg_t::compRxChanCfg</a>) or dynamic config (<a class="el" href="group___d_p_c___o_b_j_d_e_t___i_o_c_t_l_____c_o_m_m_a_n_d.html#ga41ce76942b5dee5914dff7e84a7f0a19">DPC_OBJDET_IOCTL__DYNAMIC_COMP_RANGE_BIAS_AND_RX_CHAN_PHASE</a>), as seen in figure <a class="el" href="index.html#Figure_calibration">Figure_calibration</a>, for each sub-frame the DPC determines the rx compensation vector (<a class="el" href="group___d_p_c___o_b_j_d_e_t_____i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga0bdebcef1961a77d81c74a30b637bf12">DPC_ObjDet_GetRxChPhaseComp</a>) to apply for that sub-frame (the resulting compensation vector is such that all antennas enabled for that configuration are contiguous in storage) depending on the antenna configuration for that sub-frame and passes this to the AoA DPU. During processing, AoA DPU will apply this contiguously stored vector on the virtual antenna array before performing angle computation.</p>
<dl class="section note"><dt>Note</dt><dd>Although the range bias estimation is immune to motion because the bias estimation is based on searching peak position after 2D FFT, the rx compensation coefficients are calculated from 1D FFT output, so this will not be immune to motion in the scene. Hence, during calibration care must exercised to ensure that there are no moving objects in the search window range.</dd></dl>
<h1><a class="anchor" id="objdethwa_designNotes"></a>
Data Path Design Notes</h1>
<h2><a class="anchor" id="objdethwa_scaling"></a>
Scaling</h2>
<p>The HWA uses 24-bit fixed point arithmetic for the data path processing. In order to prevent overflows in the FFT processing, the scaling factors have to be set appropriately in the HWA configuration. The HWA has up to 10 stages of processing with ability to scale by 1/2 for each stage.</p><ul>
<li>1D processing: If the HWA's FFT scale is set to <img class="formulaInl" alt="$\frac{1}{2^k}$" src="form_5.png"/> where <img class="formulaInl" alt="$k$" src="form_6.png"/> is the number of stages for which the scaling is enabled, and input to the FFT were a pure tone at one of the bins, then the output magnitude of the FFT at that bin will be <img class="formulaInl" alt="$\frac{N}{2^k}$" src="form_7.png"/> ( <img class="formulaInl" alt="$N$" src="form_8.png"/> is the FFT order) times the input tone amplitude (because tone is complex, this implies that the individual real and imaginary components will also be amplified by a maximum of this scale). Because we do a Blackman window before the FFT, the overall scale is about 1/2.4 of the FFT scale. This means for example for 256 point FFT, the windowing + FFT scale will be <img class="formulaInl" alt="$\frac{106.7}{2^k}$" src="form_9.png"/>. For k=2 which is currently how it is in the implementation (no matter the FFT order), this will be 26.7. Therefore, the ADC output when it is a pure tone should not exceed +/-2^15/26.7 = 1228 for the I and Q components (even though HWA is internally 24-bit, the FFT output is stored as 16-bit before 2D processing, hence 2^15). The XWR68xx EVM when presented with a strong single reflector reasonably close to it (with Rx dB gain of 30 dB in the chirp profile) shows ADC samples to be a max of about 2000 and while this exceeds the 1228 maximum, is not a pure tone, the energy of the FFT is seen in other bins also and the solution still works well and detects the strong object.</li>
<li>2D processing: For the 2D FFT, given that the input is the output of 1D FFT that can amplify its input as mentioned in previous section, it is more appropriate to use full scale. So currently in the implementation, scaling is enabled for all stages of the FFT except for the first stage because of Hanning window related scaling by 1/2. </li>
</ul>
</div></div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
