<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>I2C Driver Internal Data Structures</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C Driver Internal Data Structures<div class="ingroups"><a class="el" href="group___i2_c___d_r_i_v_e_r.html">I2C Master Driver</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___hw_cfg__t.html">I2C_HwCfg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Driver HW configuration.  <a href="struct_i2_c___hw_cfg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_i2_c___master_m_c_b__t.html">I2C_MasterMCB_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Driver Master Control Block.  <a href="struct_i2_c___master_m_c_b__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9745db7a5c0bba1384a4c97f1907783b"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga6aab202f91ee4bf17ceb364ecb71ba7e">I2C_DriverState_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga9745db7a5c0bba1384a4c97f1907783b">I2C_DriverState</a></td></tr>
<tr class="memdesc:ga9745db7a5c0bba1384a4c97f1907783b"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Driver Status.  <a href="#ga9745db7a5c0bba1384a4c97f1907783b">More...</a><br /></td></tr>
<tr class="separator:ga9745db7a5c0bba1384a4c97f1907783b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf912fec4460954a57458de70f7f5e09"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___hw_cfg__t.html">I2C_HwCfg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gabf912fec4460954a57458de70f7f5e09">I2C_HwCfg</a></td></tr>
<tr class="memdesc:gabf912fec4460954a57458de70f7f5e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Driver HW configuration.  <a href="#gabf912fec4460954a57458de70f7f5e09">More...</a><br /></td></tr>
<tr class="separator:gabf912fec4460954a57458de70f7f5e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c9650d909ae8464a7e9cba03575589"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gae4566330c54fb5c0b7195f57823a38f9">I2C_Mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gaf8c9650d909ae8464a7e9cba03575589">I2C_Mode</a></td></tr>
<tr class="memdesc:gaf8c9650d909ae8464a7e9cba03575589"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C mode.  <a href="#gaf8c9650d909ae8464a7e9cba03575589">More...</a><br /></td></tr>
<tr class="separator:gaf8c9650d909ae8464a7e9cba03575589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0279eaf77896881789eb54e67413597c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_i2_c___master_m_c_b__t.html">I2C_MasterMCB_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga0279eaf77896881789eb54e67413597c">I2C_MasterMCB</a></td></tr>
<tr class="memdesc:ga0279eaf77896881789eb54e67413597c"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Driver Master Control Block.  <a href="#ga0279eaf77896881789eb54e67413597c">More...</a><br /></td></tr>
<tr class="separator:ga0279eaf77896881789eb54e67413597c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0013a1dd9a09b03f3615da308118c1fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga0013a1dd9a09b03f3615da308118c1fb">I2CSetPSC</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs, uint32_t psc)</td></tr>
<tr class="memdesc:ga0013a1dd9a09b03f3615da308118c1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures the prescaler value.  <a href="#ga0013a1dd9a09b03f3615da308118c1fb">More...</a><br /></td></tr>
<tr class="separator:ga0013a1dd9a09b03f3615da308118c1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc3f165ef8483daa899feda5be1e9a1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gadc3f165ef8483daa899feda5be1e9a1a">I2CReset</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs)</td></tr>
<tr class="memdesc:gadc3f165ef8483daa899feda5be1e9a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the I2C Module. This will put the I2C module in reset. Only Tx and Rx are cleared, status bits are set their default values and all configuration registers are not reset, they keep their initial values.  <a href="#gadc3f165ef8483daa899feda5be1e9a1a">More...</a><br /></td></tr>
<tr class="separator:gadc3f165ef8483daa899feda5be1e9a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2572a631d73e705a1f05b3ad148f953"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gab2572a631d73e705a1f05b3ad148f953">I2CSetOwnAddress</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs, uint32_t ownAddr)</td></tr>
<tr class="memdesc:gab2572a631d73e705a1f05b3ad148f953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the own slave address.  <a href="#gab2572a631d73e705a1f05b3ad148f953">More...</a><br /></td></tr>
<tr class="separator:gab2572a631d73e705a1f05b3ad148f953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8451dd00e59879adfd63f388d4572660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga8451dd00e59879adfd63f388d4572660">I2CIntEnable</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs, uint32_t intFlag)</td></tr>
<tr class="memdesc:ga8451dd00e59879adfd63f388d4572660"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables only specified I2C interrupts in master mode.  <a href="#ga8451dd00e59879adfd63f388d4572660">More...</a><br /></td></tr>
<tr class="separator:ga8451dd00e59879adfd63f388d4572660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad6d64a331fedc4daaf7dd4f0fa2c14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga0ad6d64a331fedc4daaf7dd4f0fa2c14">I2CIntDisable</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs, uint32_t intFlag)</td></tr>
<tr class="memdesc:ga0ad6d64a331fedc4daaf7dd4f0fa2c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function disables the specified I2C interrupts.  <a href="#ga0ad6d64a331fedc4daaf7dd4f0fa2c14">More...</a><br /></td></tr>
<tr class="separator:ga0ad6d64a331fedc4daaf7dd4f0fa2c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac01d9c573c3ba726baaf7c0842d273c3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gac01d9c573c3ba726baaf7c0842d273c3">I2CGetIntStatus</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs, uint32_t intFlag)</td></tr>
<tr class="memdesc:gac01d9c573c3ba726baaf7c0842d273c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the status of specified interrupts in master mode.  <a href="#gac01d9c573c3ba726baaf7c0842d273c3">More...</a><br /></td></tr>
<tr class="separator:gac01d9c573c3ba726baaf7c0842d273c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ab2cceba222c8f6b28175d8143836af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga9ab2cceba222c8f6b28175d8143836af">I2CIntClear</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs, uint32_t intFlag)</td></tr>
<tr class="memdesc:ga9ab2cceba222c8f6b28175d8143836af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the status of specified interrupts.  <a href="#ga9ab2cceba222c8f6b28175d8143836af">More...</a><br /></td></tr>
<tr class="separator:ga9ab2cceba222c8f6b28175d8143836af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8142acecf2345a807d0a154f42cf22c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gad8142acecf2345a807d0a154f42cf22c">I2CSetDataCount</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs, uint32_t count)</td></tr>
<tr class="memdesc:gad8142acecf2345a807d0a154f42cf22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configure I2C data count register with a value. The value in the I2C data count register indicate how many data words to transfer when the I2C is configured as a master-transmitter and repeat mode is off.  <a href="#gad8142acecf2345a807d0a154f42cf22c">More...</a><br /></td></tr>
<tr class="separator:gad8142acecf2345a807d0a154f42cf22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaabd72c27ed8c25fd5a0903976d6980"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gabaabd72c27ed8c25fd5a0903976d6980">I2CGetDataCount</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs)</td></tr>
<tr class="memdesc:gabaabd72c27ed8c25fd5a0903976d6980"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the current value from the I2C data count register with a value. The value in the I2C data count register indicate how many data words to transfer when the I2C is configured as a master-transmitter and repeat mode is off.  <a href="#gabaabd72c27ed8c25fd5a0903976d6980">More...</a><br /></td></tr>
<tr class="separator:gabaabd72c27ed8c25fd5a0903976d6980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cf4fc55e944c6cdd4ce21073d9ae796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga0cf4fc55e944c6cdd4ce21073d9ae796">I2CPutData</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs, uint8_t data)</td></tr>
<tr class="memdesc:ga0cf4fc55e944c6cdd4ce21073d9ae796"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function transmits a byte from the I2C.  <a href="#ga0cf4fc55e944c6cdd4ce21073d9ae796">More...</a><br /></td></tr>
<tr class="separator:ga0cf4fc55e944c6cdd4ce21073d9ae796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga192f72fc0bcfc1c702ad35f1a36d3dba"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga192f72fc0bcfc1c702ad35f1a36d3dba">I2CGetData</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs)</td></tr>
<tr class="memdesc:ga192f72fc0bcfc1c702ad35f1a36d3dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fuunction receives a byte.  <a href="#ga192f72fc0bcfc1c702ad35f1a36d3dba">More...</a><br /></td></tr>
<tr class="separator:ga192f72fc0bcfc1c702ad35f1a36d3dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac827f468b5171dc8532c7d89c0f9f740"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gac827f468b5171dc8532c7d89c0f9f740">I2CGetIntVector</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs)</td></tr>
<tr class="memdesc:gac827f468b5171dc8532c7d89c0f9f740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interrupt vector code.  <a href="#gac827f468b5171dc8532c7d89c0f9f740">More...</a><br /></td></tr>
<tr class="separator:gac827f468b5171dc8532c7d89c0f9f740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6afa0e0aa62c74da684b2ac26df15271"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga6afa0e0aa62c74da684b2ac26df15271">I2CMasterInitClk</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs, uint32_t sysClk, uint32_t internalClk, uint32_t outputClk)</td></tr>
<tr class="memdesc:ga6afa0e0aa62c74da684b2ac26df15271"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines and configures the module and master clock frequency.  <a href="#ga6afa0e0aa62c74da684b2ac26df15271">More...</a><br /></td></tr>
<tr class="separator:ga6afa0e0aa62c74da684b2ac26df15271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafc05666dc2cca46003ad81abd76b8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gacafc05666dc2cca46003ad81abd76b8a">I2CMasterEnable</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs)</td></tr>
<tr class="memdesc:gacafc05666dc2cca46003ad81abd76b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the I2C module. This will bring the I2C module out of reset.  <a href="#gacafc05666dc2cca46003ad81abd76b8a">More...</a><br /></td></tr>
<tr class="separator:gacafc05666dc2cca46003ad81abd76b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e3692c68a98cd9101b407fefba92f45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga0e3692c68a98cd9101b407fefba92f45">I2CMasterBusBusy</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs)</td></tr>
<tr class="memdesc:ga0e3692c68a98cd9101b407fefba92f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines whether bus is busy or not.  <a href="#ga0e3692c68a98cd9101b407fefba92f45">More...</a><br /></td></tr>
<tr class="separator:ga0e3692c68a98cd9101b407fefba92f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64a064145db6b3bc581c0a17d391e01f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga64a064145db6b3bc581c0a17d391e01f">I2CMasterErr</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs)</td></tr>
<tr class="memdesc:ga64a064145db6b3bc581c0a17d391e01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines whether error occurred or not during I2C operation.  <a href="#ga64a064145db6b3bc581c0a17d391e01f">More...</a><br /></td></tr>
<tr class="separator:ga64a064145db6b3bc581c0a17d391e01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga933acd39be6955eae804a55eb7ae5f6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga933acd39be6955eae804a55eb7ae5f6c">I2CMasterControl</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs, uint32_t ctrlMask, uint32_t ctrlCmds)</td></tr>
<tr class="memdesc:ga933acd39be6955eae804a55eb7ae5f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configure I2C in different modes of operation.  <a href="#ga933acd39be6955eae804a55eb7ae5f6c">More...</a><br /></td></tr>
<tr class="separator:ga933acd39be6955eae804a55eb7ae5f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae3488a15c056b644b5cfd64eff163ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gaae3488a15c056b644b5cfd64eff163ed">I2CMasterStart</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs)</td></tr>
<tr class="memdesc:gaae3488a15c056b644b5cfd64eff163ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts a I2C transaction on the bus. This API must be called after all the configuration for the i2c module is done and after bringing I2C out of local reset.  <a href="#gaae3488a15c056b644b5cfd64eff163ed">More...</a><br /></td></tr>
<tr class="separator:gaae3488a15c056b644b5cfd64eff163ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e06a7b709d773a2ed55904b2b6c3e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga17e06a7b709d773a2ed55904b2b6c3e4">I2CMasterStop</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs)</td></tr>
<tr class="memdesc:ga17e06a7b709d773a2ed55904b2b6c3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function stops a I2C transaction on the bus. This function must be used in case a deliberate STOP needs to be sent on the bus.  <a href="#ga17e06a7b709d773a2ed55904b2b6c3e4">More...</a><br /></td></tr>
<tr class="separator:ga17e06a7b709d773a2ed55904b2b6c3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5772c90e7f2f80014189e4d4b0200919"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga5772c90e7f2f80014189e4d4b0200919">I2CMasterSetSlaveAddr</a> (<a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *i2cRegs, uint32_t slaveAdd)</td></tr>
<tr class="memdesc:ga5772c90e7f2f80014189e4d4b0200919"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the address of the slave device with which I2C wants to communicate.  <a href="#ga5772c90e7f2f80014189e4d4b0200919">More...</a><br /></td></tr>
<tr class="separator:ga5772c90e7f2f80014189e4d4b0200919"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga9745db7a5c0bba1384a4c97f1907783b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga6aab202f91ee4bf17ceb364ecb71ba7e">I2C_DriverState_t</a> <a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga9745db7a5c0bba1384a4c97f1907783b">I2C_DriverState</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Driver Status. </p>
<p>The enumeration describes the status of the I2C Driver Instance </p>

</div>
</div>
<a class="anchor" id="gabf912fec4460954a57458de70f7f5e09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___hw_cfg__t.html">I2C_HwCfg_t</a> <a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gabf912fec4460954a57458de70f7f5e09">I2C_HwCfg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Driver HW configuration. </p>
<p>The structure is used to store the hardware specific configuration which is passed to each driver instance </p>

</div>
</div>
<a class="anchor" id="ga0279eaf77896881789eb54e67413597c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_i2_c___master_m_c_b__t.html">I2C_MasterMCB_t</a> <a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga0279eaf77896881789eb54e67413597c">I2C_MasterMCB</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Driver Master Control Block. </p>
<p>The structure is used to hold all the pertinent information with respect to the I2C Driver. </p>

</div>
</div>
<a class="anchor" id="gaf8c9650d909ae8464a7e9cba03575589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gae4566330c54fb5c0b7195f57823a38f9">I2C_Mode_t</a>  <a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gaf8c9650d909ae8464a7e9cba03575589">I2C_Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C mode. </p>
<p>This enum defines the state of the I2C Master driver's state-machine. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga6aab202f91ee4bf17ceb364ecb71ba7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#ga6aab202f91ee4bf17ceb364ecb71ba7e">I2C_DriverState_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C Driver Status. </p>
<p>The enumeration describes the status of the I2C Driver Instance </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga6aab202f91ee4bf17ceb364ecb71ba7ea6d313eab30c1ad807e412ea3a05b0f26"></a>I2C_DriverState_UNINIT&#160;</td><td class="fielddoc">
<p>Driver is uninitialized. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6aab202f91ee4bf17ceb364ecb71ba7eaf1f2c47e8e724e56ab55c1216f0b8ad6"></a>I2C_DriverState_OPERATIONAL&#160;</td><td class="fielddoc">
<p>Driver is operational. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gae4566330c54fb5c0b7195f57823a38f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___i2_c___i_n_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gae4566330c54fb5c0b7195f57823a38f9">I2C_Mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C mode. </p>
<p>This enum defines the state of the I2C Master driver's state-machine. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga192f72fc0bcfc1c702ad35f1a36d3dba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2CGetData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This fuunction receives a byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returns</td><td>the byte received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabaabd72c27ed8c25fd5a0903976d6980"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CGetDataCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the current value from the I2C data count register with a value. The value in the I2C data count register indicate how many data words to transfer when the I2C is configured as a master-transmitter and repeat mode is off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returns</td><td>the number of bytes transferred over the I2C bus. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac01d9c573c3ba726baaf7c0842d273c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CGetIntStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the status of specified interrupts in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlag</td><td>It specifies the interrupts whose status needs to be returned.</td></tr>
  </table>
  </dd>
</dl>
<p>intFlag can take following macros.</p>
<p>I2C_INT_ARBITRATION_LOST - Arbitration-lost interrupt. I2C_INT_NO_ACK - No-acknowledgement interrupt. I2C_INT_ADRR_READY_ACESS - I2C registers are ready to access. I2C_INT_RECV_READY - Receive-data-ready interrupt. I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt. I2C_INT_STOP_CONDITION - Stop condition interrupt. I2C_INT_ADRR_ZERO - Address of all zeros interrupt. I2C_INT_ADRR_SLAVE - Address-as-slave interrupt. I2C_INT_TRANSMIT_UNDER_FLOW - Transmit underflow interrupt. I2C_INT_RECV_OVER_RUN - Receive overrun interrupt. I2C_INT_BUS_BUSY - Bus busy Interrupt. I2C_INT_NO_ACK_SENT - No acknowlegement sent interrupt. I2C_INT_SLAVE_DIRECTION - Slave direction interrupt.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Status</td><td>of specified interrupts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac827f468b5171dc8532c7d89c0f9f740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CGetIntVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the interrupt vector code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returns</td><td>the interrupt vector register value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9ab2cceba222c8f6b28175d8143836af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CIntClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the status of specified interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlag</td><td>Specifies the interrupts whose status needs to be cleared</td></tr>
  </table>
  </dd>
</dl>
<p>intFlag can take following macros.</p>
<p>I2C_INT_ARBITRATION_LOST - Arbitration-lost interrupt. I2C_INT_NO_ACK - No-acknowledgement interrupt. I2C_INT_ADRR_READY_ACESS - I2C registers are ready to access. I2C_INT_RECV_READY - Receive-data-ready interrupt. I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt. I2C_INT_STOP_CONDITION - Stop condition interrupt. I2C_INT_ADRR_ZERO - Address of all zeros interrupt. I2C_INT_ADRR_SLAVE - Address-as-slave interrupt. I2C_INT_TRANSMIT_UNDER_FLOW - Transmit underflow interrupt. I2C_INT_RECV_OVER_RUN - Receive overrun interrupt. I2C_INT_BUS_BUSY - Bus busy Interrupt. I2C_INT_NO_ACK_SENT - No acknowlegement sent interrupt. I2C_INT_SLAVE_DIRECTION - Slave direction interrupt.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ad6d64a331fedc4daaf7dd4f0fa2c14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CIntDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function disables the specified I2C interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlag</td><td>Specifies the interrupts that are to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>intFlag can take following values.</p>
<p>I2C_INT_ARBITRATION_LOST - Arbitration-lost interrupt. I2C_INT_NO_ACK - No-acknowledgement interrupt. I2C_INT_ADRR_READY_ACESS - I2C registers are ready to access. I2C_INT_RECV_READY - Receive-data-ready interrupt. I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt. I2C_INT_STOP_CONDITION - Stop condition interrupt. I2C_INT_ADRR_SLAVE - Address-as-slave interrupt.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8451dd00e59879adfd63f388d4572660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CIntEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables only specified I2C interrupts in master mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">intFlag</td><td>Specifies the interrupts that are to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<p>intFlag can take following values.</p>
<p>I2C_INT_ARBITRATION_LOST - Arbitration-lost interrupt. I2C_INT_NO_ACK - No-acknowledgement interrupt. I2C_INT_ADRR_READY_ACESS - I2C registers are ready to access. I2C_INT_RECV_READY - Receive-data-ready interrupt. I2C_INT_TRANSMIT_READY - Transmit-data-ready interrupt. I2C_INT_STOP_CONDITION - Stop condition interrupt. I2C_INT_ADRR_SLAVE - Address-as-slave interrupt.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0e3692c68a98cd9101b407fefba92f45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool I2CMasterBusBusy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function determines whether bus is busy or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>It is the Memory address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>- bus is busy. </td></tr>
    <tr><td class="paramname">false</td><td>- bus is free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga933acd39be6955eae804a55eb7ae5f6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterControl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctrlMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctrlCmds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configure I2C in different modes of operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctrlMask</td><td>Mask of the control bits to configure I2C in different operating modes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ctrlCmds</td><td>Control bits which configures I2C in different operating modes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacafc05666dc2cca46003ad81abd76b8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the I2C module. This will bring the I2C module out of reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga64a064145db6b3bc581c0a17d391e01f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2CMasterErr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function determines whether error occurred or not during I2C operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">error</td><td>- non zero value. </td></tr>
    <tr><td class="paramname">No</td><td>error - 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6afa0e0aa62c74da684b2ac26df15271"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterInitClk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sysClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>internalClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>outputClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function determines and configures the module and master clock frequency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sysClk</td><td>System clock fed to I2C module. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalClk</td><td>Internal clock used by I2C module.Which is obtained by scaling System clock fed to I2C module. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outputClk</td><td>Required I2C bus speed or frequency.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5772c90e7f2f80014189e4d4b0200919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterSetSlaveAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slaveAdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the address of the slave device with which I2C wants to communicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slaveAdd</td><td>Slave address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaae3488a15c056b644b5cfd64eff163ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts a I2C transaction on the bus. This API must be called after all the configuration for the i2c module is done and after bringing I2C out of local reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga17e06a7b709d773a2ed55904b2b6c3e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CMasterStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function stops a I2C transaction on the bus. This function must be used in case a deliberate STOP needs to be sent on the bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0cf4fc55e944c6cdd4ce21073d9ae796"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CPutData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function transmits a byte from the I2C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data to be transmitted from the I2C Master.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadc3f165ef8483daa899feda5be1e9a1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the I2C Module. This will put the I2C module in reset. Only Tx and Rx are cleared, status bits are set their default values and all configuration registers are not reset, they keep their initial values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8142acecf2345a807d0a154f42cf22c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSetDataCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configure I2C data count register with a value. The value in the I2C data count register indicate how many data words to transfer when the I2C is configured as a master-transmitter and repeat mode is off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Value which is set to I2C data count register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab2572a631d73e705a1f05b3ad148f953"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSetOwnAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ownAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the own slave address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>Memory address of the I2C instance used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ownAddr</td><td>Slave address of the I2C instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0013a1dd9a09b03f3615da308118c1fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2CSetPSC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="reg__i2c_8h.html#a408cd0ba4b4c178b57028fe728d87ea4">I2CRegs</a> *&#160;</td>
          <td class="paramname"><em>i2cRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>psc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function configures the prescaler value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cRegs</td><td>It is the Memory address of the I2C instance used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">psc</td><td>Prescaler value to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Not</td><td>applicable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
