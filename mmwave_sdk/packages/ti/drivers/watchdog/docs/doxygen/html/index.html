<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Watchdog Driver</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Watchdog Driver </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Watchdog header file should be included in an application as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ti/drivers/watchdog/Watchdog.h&gt;</span></div></div><!-- fragment --><p>The <a class="el" href="reg__watchdog_8h.html" title="This file gives register definitions of MSS_RTIB module. ">watchdog/include/reg_watchdog.h</a> has the register layer definitons for the Watchdog Module.</p>
<h1>Operation</h1>
<p>The Watchdog driver simplifies configuring and starting the Watchdog peripherals. The Watchdog can be set up to produce a reset signal after a timeout, or simply cause a hardware interrupt at a programmable interval. The driver provides the ability to specify a callback function that is called when the Watchdog causes an interrupt.</p>
<p>When resets are turned on, it is the user application's responsibility to call <a class="el" href="group___w_a_t_c_h_d_o_g___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga396decd6b1807db10c636f9987c3be4c" title="Clears the Watchdog. ">Watchdog_clear()</a> in order to clear the Watchdog and prevent a reset. <a class="el" href="group___w_a_t_c_h_d_o_g___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga396decd6b1807db10c636f9987c3be4c" title="Clears the Watchdog. ">Watchdog_clear()</a> can be called at any time.</p>
<h2>Opening the driver</h2>
<p>The watchdog driver uses the ESM and SOC drivers. Make sure these modules are initialized before <a class="el" href="group___w_a_t_c_h_d_o_g___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gab73b727c26f57a2e0f29c5a8022bb728" title="Opens a Watchdog. ">Watchdog_open()</a> is called.</p>
<div class="fragment"><div class="line"><a class="code" href="struct_watchdog___config__t.html">Watchdog_Handle</a>     handle;</div><div class="line"><a class="code" href="struct_watchdog___params__t.html">Watchdog_Params</a>     params;</div><div class="line"></div><div class="line"><a class="code" href="group___w_a_t_c_h_d_o_g___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga6a6f54cfdac33d3bf33464a212262afc">Watchdog_Params_init</a>(&amp;params);</div><div class="line">params.<a class="code" href="struct_watchdog___params__t.html#a0d3339c23245141b2afe78278fffc7ce">resetMode</a> = <a class="code" href="group___w_a_t_c_h_d_o_g___d_r_i_v_e_r___e_x_t_e_r_n_a_l___d_a_t_a___s_t_r_u_c_t_u_r_e.html#gga582afe4c2709c89a0b929228da4fb04ba78ba6b49345f0116143f4d4e7a9ec488">Watchdog_RESET_OFF</a>;</div><div class="line">watchdogParams.callbackFxn = watchdogCallback;</div><div class="line">watchdogParams.socHandle = socHandle;</div><div class="line">watchdogParams.esmHandle = esmHandle;</div><div class="line">handle = <a class="code" href="group___w_a_t_c_h_d_o_g___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gab73b727c26f57a2e0f29c5a8022bb728">Watchdog_open</a>(Watchdog_configIndex, &amp;params);</div><div class="line"><span class="keywordflow">if</span> (!handle) {</div><div class="line">    System_printf(<span class="stringliteral">&quot;Watchdog did not open&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line">Handle may now be used to interact with the Watchdog just created</div></div><!-- fragment --><h1>Implementation</h1>
<p>Its purpose is to redirect the module's APIs to specific peripheral implementations which are specified using a pointer to a Watchdog_FxnTable.</p>
<p>The Watchdog driver interface module is joined (at link time) to a NULL-terminated array of Watchdog_Config data structures named <em>Watchdog_config</em>. <em>Watchdog_config</em> is implemented in the application with each entry being an instance of a Watchdog peripheral. Each entry in <em>Watchdog_config</em> contains a:</p><ul>
<li>(Watchdog_FxnTable *) to a set of functions that implement a Watchdog peripheral</li>
<li>(void *) data object that is associated with the Watchdog_FxnTable</li>
<li>(void *) hardware attributes that are associated to the Watchdog_FxnTable</li>
</ul>
<h2>Using the driver on MSS</h2>
<p>The watchdog reset mode can be configured to reset the system or generate a NMI on watchdog expiry. When the reset mode is reset OFF(i.e., generate NMI), application can register a callback function for additional handling on watchdog expiry.</p>
<h2>Using the driver on DSS</h2>
<p>The watchdog driver CANNOT be configured to be in reset mode. It can only generate an NMI on watchdog expiry. The NMI generated by the watchdog running on DSS is first captured by the BIOS NMI exception handler. Refer to the ESM driver documentation for steps on how to populate the exception handler.</p>
<p>When the reset mode is reset OFF(generate NMI), application can register a callback function for additional handling on watchdog expiry.</p>
<p>In addition to generating the NMI on DSS, the watch module also generates a group1 ESM error on the MSS. The application can register a callback on MSS using the ESM notifier functionality to handle these errors.</p>
<ul>
<li><div class="fragment"><div class="line">notifyParams.groupNumber = 1;</div><div class="line">notifyParams.errorNumber = SOC_XWR16XX_MSS_DSS_GP2_ERR_ESM;</div><div class="line">notifyParams.arg = NULL;</div><div class="line">notifyParams.notify = DSPNotifyMSSCallback;</div><div class="line">retVal = ESM_registerNotifier (esmHandle, &amp;notifyParams, &amp;errCode);</div></div><!-- fragment --></li>
</ul>
<h1>Instrumentation</h1>
<p>The Watchdog driver interface produces log statements if instrumentation is enabled.</p>
<table class="doxtable">
<tr>
<th>Diagnostics Mask </th><th>Log details  </th></tr>
<tr>
<td>Diags_USER1 </td><td>basic Watchdog operations to be performed </td></tr>
</table>
<hr/>
 </div></div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
