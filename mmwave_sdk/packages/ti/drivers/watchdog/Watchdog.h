/*
 * Copyright (c) 2015-2016, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/** @mainpage Watchdog Driver
 *
 *  The Watchdog header file should be included in an application as follows:
 *  @code
 *  #include <ti/drivers/watchdog/Watchdog.h>
 *  @endcode
 *
 *  The watchdog/include/reg_watchdog.h has the register layer definitons for the
 *  Watchdog Module.
 *
 *  # Operation #
 *
 *  The Watchdog driver simplifies configuring and starting the Watchdog
 *  peripherals. The Watchdog can be set up to produce a reset signal after a
 *  timeout, or simply cause a hardware interrupt at a programmable interval.
 *  The driver provides the ability to specify a callback function that is
 *  called when the Watchdog causes an interrupt.
 *
 *  When resets are turned on, it is the user application's responsibility to
 *  call Watchdog_clear() in order to clear the Watchdog and prevent a reset.
 *  Watchdog_clear() can be called at any time.
 *
 *  ## Opening the driver #
 *  The watchdog driver uses the ESM and SOC drivers. Make sure these modules are initialized before
 *  #Watchdog_open() is called.
 *
 *  @code
 *  Watchdog_Handle     handle;
 *  Watchdog_Params     params;
 *
 *  Watchdog_Params_init(&params);
 *  params.resetMode = Watchdog_RESET_OFF;
 *  watchdogParams.callbackFxn = watchdogCallback;
 *  watchdogParams.socHandle = socHandle;
 *  watchdogParams.esmHandle = esmHandle;
 *  handle = Watchdog_open(Watchdog_configIndex, &params);
 *  if (!handle) {
 *      System_printf("Watchdog did not open");
 *  }
 *
 *  Handle may now be used to interact with the Watchdog just created
 *  @endcode
 *
 *  # Implementation #
 *
 *  Its purpose is to redirect the module's APIs to specific
 *  peripheral implementations which are specified using a pointer to a
 *  Watchdog_FxnTable.
 *
 *  The Watchdog driver interface module is joined (at link time)
 *  to a NULL-terminated array of Watchdog_Config data structures named
 *  *Watchdog_config*. *Watchdog_config* is implemented in the application with
 *  each entry being an instance of a Watchdog peripheral. Each entry in
 *  *Watchdog_config* contains a:
 *  - (Watchdog_FxnTable *) to a set of functions that implement a Watchdog
 *    peripheral
 *  - (void *) data object that is associated with the Watchdog_FxnTable
 *  - (void *) hardware attributes that are associated to the Watchdog_FxnTable
 *
 *  ## Using the driver on MSS #
 *  The watchdog reset mode can be configured to reset the system or generate a NMI on watchdog expiry.
 *  When the reset mode is reset OFF(i.e., generate NMI), application can register a callback function for
 *  additional handling on watchdog expiry.
 *
 *  ## Using the driver on DSS #
 *  The watchdog driver CANNOT be configured to be in reset mode.  It can only generate an NMI on watchdog expiry.
 *  The NMI generated by the watchdog running on DSS is first captured by the BIOS NMI exception handler.
 *  Refer to the ESM driver documentation for steps on how to populate the exception handler.
 *
 *  When the reset mode is reset OFF(generate NMI), application can register a callback function for
 *  additional handling on watchdog expiry.
 *
 *  In addition to generating the NMI on DSS, the watch module also generates a group1 ESM error
 *  on the MSS. The application can register a callback on MSS using the ESM notifier functionality to handle these
 *  errors.
 *
 *   *  @code
 *
    notifyParams.groupNumber = 1;
    notifyParams.errorNumber = SOC_XWR16XX_MSS_DSS_GP2_ERR_ESM;
    notifyParams.arg = NULL;
    notifyParams.notify = DSPNotifyMSSCallback;
    retVal = ESM_registerNotifier (esmHandle, &notifyParams, &errCode);

 *  @endcode
 *
 *  # Instrumentation #
 *
 *  The Watchdog driver interface produces log statements if
 *  instrumentation is enabled.
 *
 *  Diagnostics Mask | Log details |
 *  ---------------- | ----------- |
 *  Diags_USER1      | basic Watchdog operations to be performed |
 *
 *  ===========================================================================
 */

#ifndef ti_drivers_Watchdog__include
#define ti_drivers_Watchdog__include

#ifdef __cplusplus
extern "C" {
#endif


#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <ti/common/mmwave_error.h>
#include <ti/drivers/soc/soc.h>
#include <ti/drivers/esm/esm.h>

/** @defgroup WATCHDOG_DRIVER      Watchdog Driver
 */

/**
@defgroup WATCHDOG_DRIVER_EXTERNAL_FUNCTION     Watchdog Driver External Functions
@ingroup WATCHDOG_DRIVER
@brief
*   The section has a list of all the exported API which the applications need to
*   invoke in order to use the Watchdog driver
*/

/**
@defgroup WATCHDOG_DRIVER_EXTERNAL_DATA_STRUCTURE      Watchdog Driver External Data Structures
@ingroup WATCHDOG_DRIVER
@brief
*   The section has a list of all the data structures which are exposed to the application
*/

/**
@defgroup WATCHDOG_DRIVER_ERROR_CODE            Watchdog Driver Error code
@ingroup WATCHDOG_DRIVER
@brief
*   The section has a list of all the error codes which are returned to the application.
*   Base error code for the Watchdog module is defined in the include ti/common/mmwave_error.h
 @{ */

/**
 * @brief   Error Code: Invalid argument
 */
#define WATCHDOG_EINVAL                 (MMWAVE_ERRNO_WATCHDOG_BASE-1)

/**
 * @brief   Error Code: Operation cannot be implemented because a previous
 * operation is still not complete.
 */
#define WATCHDOG_EINUSE                 (MMWAVE_ERRNO_WATCHDOG_BASE-2)

/**
 * @brief   Error Code: Operation is not implemented.
 */
#define WATCHDOG_ENOTIMPL               (MMWAVE_ERRNO_WATCHDOG_BASE-3)

/** @}*/
/**
 *  @defgroup WATCHDOG_CONTROL WATCHDOG Control command and status codes
 *  These Watchdog macros are reservations for Watchdog.h
 *  @{
 */

/** @}*/

/**
 *  @defgroup WATCHDOG_CMD Command Codes
 *  WATCHDOG_CMD_* macros are general command codes for Watchdog_control(). Not all Watchdog
 *  driver implementations support these command codes.
 *  @{
 *  @ingroup WATCHDOG_CONTROL
 *  @brief
 *   The section has a list of all the command codes supported by the driver.
 */

/*!
 * @brief   Command code used by Watchdog_control() to place configure the reset mode
 *
 * This command is available to configure the Watchdog Driver to either cause a system reset ot an interrupt upon expiry.
 * With this command code, @b arg is a pointer. Valid values: Refer to (Watchdog_ResetMode)

 */
#define WATCHDOG_CMD_RESETMODE              0

/*!
 * @brief   Command code used by Watchdog_control() to place configure the window mode
 *
 * This command is available to configure the Watchdog Driver window size.
 * With this command code, @b arg is a pointer. Valid values: Refer to (Watchdog_WindowSize)

 */
#define WATCHDOG_CMD_WINDOWSIZE             1
/** @}*/

/** @}*/

/** @addtogroup WATCHDOG_DRIVER_EXTERNAL_DATA_STRUCTURE
 @{ */

/*!
*  @brief      Watchdog Handle
*/
typedef struct Watchdog_Config_t *Watchdog_Handle;

/*!
 *  @brief      Watchdog debug stall settings
 *
 *  This enumeration defines the debug stall modes for the Watchdog. On some
 *  targets, the Watchdog timer will continue to count down while a debugging
 *  session is halted. To avoid unwanted resets, the Watchdog can be set to
 *  stall while the processor is stopped by the debugger.
 */
typedef enum Watchdog_DebugMode_t {
    Watchdog_DEBUG_STALL_ON, /*!< Watchdog will be stalled at breakpoints */
    Watchdog_DEBUG_STALL_OFF /*!< Watchdog will keep running at breakpoints */
} Watchdog_DebugMode;

/*!
 *  @brief      Watchdog reset mode settings
 *
 *  This enumeration defines the reset modes for the Watchdog. The Watchdog can
 *  be configured to either generate a reset upon timeout or simply produce a
 *  periodic interrupt.
 */
typedef enum Watchdog_ResetMode_t {
    Watchdog_RESET_OFF  = 0xAU, /*!< Timeouts generate NMI interrupt only */
    Watchdog_RESET_ON   = 0x5U   /*!< Generates reset after timeout */
} Watchdog_ResetMode;

/*!
 *  @brief      Watchdog Window Size settings
 *
 *  This enumeration defines the size of the digital watchdog window size.
 */
typedef enum Watchdog_WindowSize_t {
    Watchdog_WINDOW_100_PERCENT     = 0x00000005U, /*!< Window size is 100% */
    Watchdog_WINDOW_50_PERCENT      = 0x00000050U, /*!< Window size is 50% */
    Watchdog_WINDOW_25_PERCENT      = 0x00000500U, /*!< Window size is 25% */
    Watchdog_WINDOW_12_5_PERCENT    = 0x00005000U, /*!< Window size is 12.5% */
    Watchdog_WINDOW_6_25_PERCENT    = 0x00050000U, /*!< Window size is 6.25% */
    Watchdog_WINDOW_3_125_PERCENT   = 0x00500000U  /*!< Window size is 3.125% */
} Watchdog_WindowSize;

/*!
 *  @brief      Watchdog callback pointer
 *
 *  This is the typedef for the function pointer that will allow a callback
 *  function to be specified in the Watchdog_Params structure. The function
 *  will take a Watchdog_Handle of the Watchdog causing the interrupt as an argument.
 */
typedef void (*Watchdog_Callback)(Watchdog_Handle);

/*!
 *  @brief      Watchdog Parameters
 *
 *  Watchdog parameters are used to with the Watchdog_open() call. Default
 *  values for these parameters are set using Watchdog_Params_init().
 *
 *  @sa         Watchdog_Params_init()
 */
typedef struct Watchdog_Params_t {
    Watchdog_Callback       callbackFxn;    /*!< Pointer to callback. Valid when resetMode = Watchdog_RESET_OFF. */
    Watchdog_ResetMode      resetMode;      /*!< Mode to enable resets. */
    Watchdog_DebugMode      debugStallMode; /*!< Mode to stall watchdog at breakpoints. */
    Watchdog_WindowSize     windowSize;     /*!< Windowed watchdog window size. */
    uint32_t                preloadValue;   /*!< Preload value. */
    SOC_Handle              socHandle;      /*!< SOC Handle. */
    ESM_Handle              esmHandle;      /*!< ESM Handle. */
} Watchdog_Params;

/** @}*/

/*!
 *  @brief      A function pointer to a driver specific implementation of
 *              Watchdog_clear().
 */
typedef void (*Watchdog_ClearFxn)       (Watchdog_Handle handle);

/*!
 *  @brief      A function pointer to a driver specific implementation of
 *              Watchdog_close().
 */
typedef void (*Watchdog_CloseFxn)       (Watchdog_Handle handle);

/*!
 *  @brief      A function pointer to a driver specific implementation of
 *              Watchdog_control().
 */
typedef int  (*Watchdog_ControlFxn)     (Watchdog_Handle handle,
                                         uint32_t cmd,
                                         void *arg);

/*!
 *  @brief      A function pointer to a driver specific implementation of
 *              Watchdog_init().
 */
typedef void (*Watchdog_InitFxn)        (Watchdog_Handle handle);

/*!
 *  @brief      A function pointer to a driver specific implementation of
 *              Watchdog_open().
 */
typedef Watchdog_Handle (*Watchdog_OpenFxn)  (Watchdog_Handle handle,
                                              Watchdog_Params *params);

/*!
 *  @brief      The definition of a Watchdog function table that contains the
 *              required set of functions to control a specific Watchdog driver
 *              implementation.
 */
typedef struct Watchdog_FxnTable_t {
    Watchdog_ClearFxn             watchdogClear;
    Watchdog_CloseFxn             watchdogClose;
    Watchdog_ControlFxn           watchdogControl;
    Watchdog_InitFxn              watchdogInit;
    Watchdog_OpenFxn              watchdogOpen;
} Watchdog_FxnTable;

/*!
 *  @brief      Watchdog Global configuration
 *
 *  The Watchdog_Config structure contains a set of pointers used to
 *  characterize the Watchdog driver implementation.
 *
 *  This structure needs to be defined before calling Watchdog_init() and
 *  it must not be changed thereafter.
 *
 *  @sa     Watchdog_init()
 */
typedef struct Watchdog_Config_t {
    /*!
     * Pointer to a table of driver-specific implementations of Watchdog APIs
     */
    Watchdog_FxnTable const *fxnTablePtr;

    /*! Pointer to a driver specific data object */
    void                    *object;

    /*! Pointer to a driver specific hardware attributes structure */
    void              const *hwAttrs;
} Watchdog_Config;

/*!
 *  @brief      Clears the Watchdog
 *
 *  Clears the Watchdog to  prevent a reset signal from being generated if the
 *  module is in Watchdog_RESET_ON reset mode.
 *
 *  @param  handle      Watchdog Handle
 *
 *  \ingroup WATCHDOG_DRIVER_EXTERNAL_FUNCTION
 */
extern void Watchdog_clear(Watchdog_Handle handle);

/*!
 *  @brief  Function to close a Watchdog peripheral specified by the Watchdog
 *          handle.It stops (holds) the Watchdog counting on applicable
 *          platforms.
 *
 *  @pre    Watchdog_open() has to be called first.
 *
 *  @param  handle      A Watchdog_Handle returned from Watchdog_open
 *
 *  @sa     Watchdog_open()
 *
 *  \ingroup WATCHDOG_DRIVER_EXTERNAL_FUNCTION
 */
extern void Watchdog_close(Watchdog_Handle handle);

/*!
 *  @brief  Function performs implementation specific features on a given
 *          Watchdog_Handle.
 *
 *  Commands for Watchdog_control can originate from Watchdog.h or from implementation
 *  specific Watchdog*.h (_WatchdogCC26XX.h_, _WatchdogTiva.h_, etc.. ) files.
 *  While commands from Watchdog.h are API portable across driver implementations,
 *  not all implementations may support all these commands.
 *  Conversely, commands from driver implementation specific Watchdog*.h files add
 *  unique driver capabilities but are not API portable across all Watchdog driver
 *  implementations.
 *
 *  Commands supported by Watchdog.h follow a Watchdog_CMD_\<cmd\> naming
 *  convention.<br>
 *  Commands supported by Watchdog*.h follow a Watchdog*_CMD_\<cmd\> naming
 *  convention.<br>
 *  Each control command defines @b arg differently. The types of @b arg are
 *  documented with each command.
 *
 *  See @ref WATCHDOG_CMD "Watchdog_control command codes" for command codes.
 *
 *  @pre    Watchdog_open() has to be called first.
 *
 *  @param  handle      A Watchdog handle returned from Watchdog_open()
 *
 *  @param  cmd         Watchdog.h or Watchdog*.h commands.
 *
 *  @param  arg         An optional R/W (read/write) command argument
 *                      accompanied with cmd
 *
 *  @return Implementation specific return codes. Negative values indicate
 *          unsuccessful operations.
 *
 *  @sa     Watchdog_open()
 *
 *  \ingroup WATCHDOG_DRIVER_EXTERNAL_FUNCTION
 */
extern int Watchdog_control(Watchdog_Handle handle,
                            uint32_t cmd,
                            void *arg);

/*!
 *  @brief      Initializes the Watchdog module
 *
 *  The application-provided Watchdog_config must be present before the
 *  Watchdog_init function is called. The Watchdog_config must be persistent
 *  and not changed after Watchdog_init is called. This function must be called
 *  before any of the other Watchdog driver APIs.
 *
 *  \ingroup WATCHDOG_DRIVER_EXTERNAL_FUNCTION
 */
extern void Watchdog_init(void);

/*!
 *  @brief      Opens a Watchdog
 *
 *  Opens a Watchdog object with the index and parameters specified, and
 *  returns a Watchdog_Handle.
 *
 *  @param  index         Logical peripheral number for the Watchdog indexed
 *                        into the Watchdog_config table
 *
 *  @param  params        Pointer to an parameter block, if NULL it will use
 *                        default values. All the fields in this structure are
 *                        RO (read-only).
 *
 *  @return A Watchdog_Handle on success or a NULL on an error or if it has been
 *          opened already.
 *
 *  @sa     Watchdog_init()
 *  @sa     Watchdog_close()
 *
 *  \ingroup WATCHDOG_DRIVER_EXTERNAL_FUNCTION
 */
extern Watchdog_Handle Watchdog_open(uint32_t index, Watchdog_Params *params);

/*!
 *  @brief  Function to initialize the Watchdog_Params structure to its defaults
 *
 *  @param  params      An pointer to Watchdog_Params structure for
 *                      initialization
 *
 *  Default parameters:
 *      callbackFxn = NULL
 *      resetMode = Watchdog_RESET_ON
 *      debugStallMode = Watchdog_DEBUG_STALL_ON
 *
 *  \ingroup WATCHDOG_DRIVER_EXTERNAL_FUNCTION
 */
extern void Watchdog_Params_init(Watchdog_Params *params);

#ifdef __cplusplus
}
#endif

#endif /* ti_drivers_Watchdog__include */

