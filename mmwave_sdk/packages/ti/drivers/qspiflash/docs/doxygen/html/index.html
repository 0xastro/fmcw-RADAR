<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>QSPI Flash Driver</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">QSPI Flash Driver </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The QSPI Flash driver provides functionaity to access external SPI flash</p>
<p>The QSPI Flash header file should be included in an application as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="qspiflash_8h.html">ti/drivers/qspiflash/qspiflash.h</a>&gt;</span></div></div><!-- fragment --><h2>Initializing the driver</h2>
<p>The QSPI Flash Driver needs to be initialized once across the System. This is done using <a class="el" href="group___q_s_p_i_f_l_a_s_h___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga3dfffa9b307d21087b3f11f44b6730f9">QSPIFlash_init</a>. None of the QSPI Flash API can be used without invoking this API.</p>
<h2>Opening the driver</h2>
<p>Once the QSPI flash Driver has been initialized, the QSPI Driver can be opened using the <a class="el" href="group___q_s_p_i_f_l_a_s_h___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga8e56314ac09f1354b94593c45bddc857">QSPIFlash_open</a>. Successful <a class="el" href="group___q_s_p_i_f_l_a_s_h___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga8e56314ac09f1354b94593c45bddc857">QSPIFlash_open</a> call will return a <a class="el" href="qspiflash_8h.html#a619eb9010f942b6f1698f7bcce489328" title="A handle that is returned from a QSPI_open() call. ">QSPIFlash_Handle</a>, which can be used to read/write from/to serial flash. QSPI driver handle needs to be provided to the QSPI flash driver in order to access serial flash through QSPI hardware interface.</p>
<h2>Get flash device id</h2>
<p>Once the QSPI flash Driver has been opened, <a class="el" href="group___q_s_p_i_f_l_a_s_h___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga94aa45edbab024db93e760c1693b3d5a">QSPIFlash_getDeviceID</a> can be used to get the serial flash manufacture id and flash capacity.</p>
<h2>Read/Write in QSPI config mode</h2>
<p>Once the QSPI flash Driver has been opened, <a class="el" href="group___q_s_p_i_f_l_a_s_h___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga3a90711ea495a2cee8ae63ef3383df1d">QSPIFlash_singleRead</a> and <a class="el" href="group___q_s_p_i_f_l_a_s_h___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga7f736fdaa3adb679ea029781498ca25b">QSPIFlash_singleWrite</a> can be used to read/write one byte from/to serial flash</p>
<h2>Read/Write in memory mapped mode</h2>
<p>QSPI flash Driver can also be used memory mapped mode, <a class="el" href="group___q_s_p_i_f_l_a_s_h___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gab34f37798ca1473f28e633b13e7512df">QSPIFlash_configMmapRead</a> and <a class="el" href="group___q_s_p_i_f_l_a_s_h___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gaf055ccb829f268bb7b7e3ed80ee87e0f">QSPIFlash_configMmapWrite</a> need to be called to set QSPI in memory mapped mode. <a class="el" href="group___q_s_p_i_f_l_a_s_h___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gac5e75d1dab0f57b4d3ac3dfa5753d02c">QSPIFlash_mmapRead</a> and <a class="el" href="group___q_s_p_i_f_l_a_s_h___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gacf22957e5ee0b0b4e4a8e5008de5d6e3">QSPIFlash_mmapWrite</a> are the functions to read/Write from/to serial flash. Please note that the data length is in number of double words(8 bytes) and source and destination address should be 8 bytes aligned.</p>
<p>In memory mapped mode, serial flash can also be read/written in DMA mode. <a class="el" href="group___q_s_p_i_f_l_a_s_h___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gae6b114479aabb901978937a25bf1790b">QSPIFlash_sysDmaRead</a> and <a class="el" href="group___q_s_p_i_f_l_a_s_h___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga2b9c830818b1455c0b086e7dc16abc22">QSPIFlash_sysDmaWrite</a> are the two functions to read/write in DMA mode. Please note that DMA handle and dma channel number need to be provided to QSPI Flash driver.</p>
<dl class="section note"><dt>Note</dt><dd>In memory mapped mode, because of MPU setting of the mapped flash memory in NON-strongly ordered mode, ARM flush of writing buffer may be delayed. If read comes before the memory is flushed, incorrect content maybe read back. To avoid the issue, MEM_BARRIER() can be used when needed to make sure memory content is updated before read. For more details on the mode that flash memory is configured for, please refer to SOC_mpu_config.</dd></dl>
<h2>Instrumentation</h2>
<p>Uses DebugP_log functions for debug messages</p>
<h2>Serial Flash device File</h2>
<p>Every serial flash has to provide an init function and quad read programming function if quad read is supported. </p><hr/>
 </div></div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
