/*
 * Copyright (c) 2015, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 /** ============================================================================
 *  @file       hwa.h
 *
 *  @brief      HWA driver interface
 * 
 */

 /** @mainpage HWA Driver
 *
 *  The HWA driver provides APIs to configure, trigger and obtain results from the 
 *  hardware accelerator
 *
 *  The HWA header file should be included in an application as follows:
 *  @code
 *  #include <ti/drivers/hwa/hwa.h>
 *  @endcode
 *  
 *  ## Initializing the driver #
 *  The HWA Driver needs to be initialized once across the System. This is
 *  done using the #HWA_init. None of the HWA API can be used without invoking
 *  this API
 *
 *  ## Opening the driver #
 *  Once the HWA Driver has been initialized; the HWA Driver instance can be opened
 *  using the #HWA_open. The #HWA_open can be called multiple times from different
 *  context to obtain a valid HWA handle. However, only the first call to #HWA_open will 
 *  perform the hardware initialization. Other subsequent calls will just return the already
 *  open handle.
 *
 *  @code
 *  @endcode
 *
 *  ## Using the driver #
 *  Following is a psuedo code for using the HWA driver 
 *
 *  @code
 *   
     
     HWA_Handle     handle;
 
     HWA_init();
     handle = HWA_open(0, &errCode);
     
 *  @endcode
 *  Refer to the API (function and structures) documentation for more details on how to 
 *  use the HWA driver. 
 *  
 *  __Note:__
 *  All the API params which are output of the API have been marked with the keyword [__out__]. 
 *  If there is no such qualifier present, then it is safe to assume that that parameter is input only.
 *
 *  ## Instrumentation #
 *  Uses DebugP_log functions for debug messages
 *
 *  ## Hardware Register Map #
 *  The hardware register map used by this driver can be found at 
 *  include/reg_dsshwacc.h and include/reg_dsshwaccparam.h
 *
 *  ============================================================================
 */
 /**
 @defgroup HWA_DRIVER_EXTERNAL_FUNCTION            HWA Driver External Functions
 @ingroup HWA_DRIVER
 @brief
 *   The section has a list of all the exported API which the applications need to
 *   invoke in order to use the driver
 */
 /**
 @defgroup HWA_DRIVER_EXTERNAL_DATA_STRUCTURE      HWA Driver External Data Structures
 @ingroup HWA_DRIVER
 @brief
 *   The section has a list of all the data structures which are exposed to the application
 */
 /**
 @defgroup HWA_DRIVER_ERROR_CODE                   HWA Driver Error Codes
 @ingroup HWA_DRIVER
 @brief
 *   The section has a list of all the error codes which are generated by the HWA Driver
 *   module
 */

#ifndef ti_drivers_HWA__include
#define ti_drivers_HWA__include
    
#ifdef __cplusplus
    extern "C" {
#endif
    
#include <stdint.h>
#include <stddef.h>
#include <ti/common/mmwave_error.h>
#include <ti/drivers/soc/soc.h>


/** @addtogroup HWA_DRIVER_ERROR_CODE
 *
 * @brief
 *  Base error code for the HWA module is defined in the ti/common/mmwave_error.h
 *  \include ti/common/mmwave_error.h
 *
 @{ */

/**
 * @brief   Error Code: Invalid argument
 */
#define HWA_EINVAL                  (MMWAVE_ERRNO_HWA_BASE-1)

/**
 * @brief   Error Code: Operation cannot be done as HWA_init is not done.
 */
#define HWA_ENOINIT                 (MMWAVE_ERRNO_HWA_BASE-2)

/**
 * @brief   Error Code: input argument out of range
 */
#define HWA_EOUTOFRANGE             (MMWAVE_ERRNO_HWA_BASE-3)

/**
 * @brief   Error Code: out of memory
 */
#define HWA_EOUTOFMEM               (MMWAVE_ERRNO_HWA_BASE-4)

/**
 * @brief   Error Code: feature not supported
 */
#define HWA_ENOTSUPP                (MMWAVE_ERRNO_HWA_BASE-5)

/**
 * @brief   Error Code: channel or resource in use
 */
#define HWA_EINUSE                  (MMWAVE_ERRNO_HWA_BASE-6)

/**
 * @brief   Error Code: address is not aligned to the expected boundary
 */
#define HWA_ENOTALIGNED             (MMWAVE_ERRNO_HWA_BASE-7)


/** @}*/

/** @addtogroup HWA_DRIVER_EXTERNAL_DATA_STRUCTURE
 @{ */

/**
 * @defgroup HWA_MACROS     HWA_MACROS
 * @brief   Lists all the macros used in HWA driver
 * @{
 */

/**
 * @defgroup HWA_FEATURE_BIT        HWA_FEATURE_BIT
 * @brief    General macro to use for enable/disable bits
 * @{
 */
#define HWA_FEATURE_BIT_ENABLE          ((uint8_t)1U)       /*!<  Enable: use this macro to enable any feature bit */
#define HWA_FEATURE_BIT_DISABLE         ((uint8_t)0U)       /*!<  Disable: use this macro to disable any feature bit */
/** @}*/ /*HWA_FEATURE_BIT*/

/**
 * @defgroup HWA_SAMPLES_WIDTH      HWA_SAMPLES_WIDTH
 * @brief    Macros that define values for 16bit or 32bit width of input/output samples 
 * @{
 */
#define HWA_SAMPLES_WIDTH_16BIT         ((uint8_t)0U)      /*!<  sample width is 16 bit */
#define HWA_SAMPLES_WIDTH_32BIT         ((uint8_t)1U)      /*!<  sample width is 32 bit */
/** @}*/ /*HWA_SAMPLES_WIDTH*/

/**
 * @defgroup HWA_SAMPLES_FORMAT     HWA_SAMPLES_FORMAT
 * @brief    Macros that define values for real/complex format of input/output samples
 * @{
 */
#define HWA_SAMPLES_FORMAT_COMPLEX      ((uint8_t)0U)      /*!<  complex samples (I/Q) */
#define HWA_SAMPLES_FORMAT_REAL         ((uint8_t)1U)      /*!<  real samples (I) */
/** @}*/ /*HWA_SAMPLES_FORMAT*/

/**
 * @defgroup HWA_SAMPLES_SIGN       HWA_SAMPLES_SIGN
 * @brief    Macros that define values for signed/unsigned property of input/output samples
 * @{
 */
#define HWA_SAMPLES_UNSIGNED            ((uint8_t)0U)      /*!<  unsigned samples */
#define HWA_SAMPLES_SIGNED              ((uint8_t)1U)      /*!<  signed samples */
/** @}*/ /*HWA_SAMPLES_SIGN*/

/**
 * @defgroup HWA_WINDOW_SYMM        HWA_WINDOW_SYMM
 * @brief    Macros that define values for symmetric/non-symmetric property of the FFT window 
 * @{
 */
#define HWA_FFT_WINDOW_NONSYMMETRIC     ((uint8_t)0U)      /*!<  non-symmetric window for FFT windowing operation */
#define HWA_FFT_WINDOW_SYMMETRIC        ((uint8_t)1U)      /*!<  symmetric window for FFT windowing operation 
                                                                 Only the first half the window coefficients are expected 
                                                                 to be present in the window RAM. The same coefficients are read in 
                                                                 reverse direction for the second half.
                                                            */
/** @}*/ /*HWA_WINDOW_SYMM*/

/**
 * @defgroup HWA_FFT_WINDOW_INTERPOLATE_MODE        HWA_FFT_WINDOW_INTERPOLATE_MODE
 * @brief    Macros that define values for interpolation property of the FFT window to 
 *           acheive larget FFT size using stitching
 * @{
 */
#define HWA_FFT_WINDOW_INTERPOLATE_MODE_NONE    ((uint8_t)0U)      /*!<  no window interpolation is enabled */
#define HWA_FFT_WINDOW_INTERPOLATE_MODE_4K      ((uint8_t)1U)      /*!<  window interpolation to acheive 4K FFT*/
#define HWA_FFT_WINDOW_INTERPOLATE_MODE_2K      ((uint8_t)2U)      /*!<  window interpolation to acheive 2K FFT*/
/** @}*/ /*HWA_FFT_WINDOW_INTERPOLATE_MODE*/


/**
 * @defgroup HWA_FFT_MODE_MAGNITUDE_LOG2        HWA_FFT_MODE_MAGNITUDE_LOG2
 * @brief    Macros that define values for enabling/disabling the magniude and log2 computation in FFT block
 * @{
 */
#define HWA_FFT_MODE_MAGNITUDE_LOG2_DISABLED        ((uint8_t)0U)        /*!<  magnitude disabled and log2 disabled */
#define HWA_FFT_MODE_MAGNITUDE_ONLY_ENABLED         ((uint8_t)2U)        /*!<  magnitude enabled and log2 disabled */
#define HWA_FFT_MODE_MAGNITUDE_LOG2_ENABLED         ((uint8_t)3U)        /*!<  magnitude and log2 enabled */
/** @}*/ /*HWA_FFT_MODE_MAGNITUDE_LOG2*/

/**
 * @defgroup HWA_FFT_MODE_OUTPUT        HWA_FFT_MODE_OUTPUT
 * @brief    Macros that define values for the various outputs of the FFT block
 * @{
 */
#define HWA_FFT_MODE_OUTPUT_DEFAULT                 ((uint8_t)0U)    /*!< Default output (i.e., main data path output is sent out - eg. FFT or Log-Mag output) */
#define HWA_FFT_MODE_OUTPUT_MAX_STATS               ((uint8_t)2U)    /*!< Statistics output - Max statistics is sent out (Max valiue on the I arm, Max index on the Q arm) */
#define HWA_FFT_MODE_OUTPUT_SUM_STATS               ((uint8_t)3U)    /*!< Statistics output - Sum statistics is sent out */
/** @}*/ /*HWA_FFT_MODE_OUTPUT*/


/**
 * @defgroup HWA_NOISE_AVG_MODE_CFAR        HWA_NOISE_AVG_MODE_CFAR
 * @brief    Macros that define values for CFAR Noise Averaging mode
 * @{
 */
#define HWA_NOISE_AVG_MODE_CFAR_CA                  ((uint8_t)0U)      /*!< cumulative average of left+right */
#define HWA_NOISE_AVG_MODE_CFAR_CAGO                ((uint8_t)1U)      /*!< cumulative average of the side (left or right) that is greater */
#define HWA_NOISE_AVG_MODE_CFAR_CASO                ((uint8_t)2U)      /*!< cumulative average of the side (left or right) that is smaller */
/** @}*/ /*HWA_NOISE_AVG_MODE_CFAR*/

/**
 * @defgroup HWA_TRIG_MODE      HWA_TRIG_MODE
 * @brief    Macros that define values for the trigger mode of HWA paramsets
 * @{
 */
#define HWA_TRIG_MODE_IMMEDIATE                     ((uint8_t)0U)      /*!< state machine reads and immediately executes that paramset */
#define HWA_TRIG_MODE_SOFTWARE                      ((uint8_t)1U)      /*!< state machine reads the paramset but waits for s/w trigger before executing that paramset */
#define HWA_TRIG_MODE_DFE                           ((uint8_t)2U)      /*!< state machine reads the paramset but waits for DFE trigger before executing that paramset */
#define HWA_TRIG_MODE_DMA                           ((uint8_t)3U)      /*!< state machine reads the paramset but waits for DMA trigger before executing that paramset */
/** @}*/ /*HWA_TRIG_MODE*/

/**
 * @defgroup HWA_ACCELMODE      HWA_ACCELMODE
 * @brief    Macros that define values for the operational/accelerator mode of HWA
 * @{
 */
#define HWA_ACCELMODE_FFT                           ((uint8_t)0U)      /*!< HWA operational mode is FFT */
#define HWA_ACCELMODE_CFAR                          ((uint8_t)1U)      /*!< HWA operational mode is CFAR */
#define HWA_ACCELMODE_NONE                          ((uint8_t)3U)      /*!< HWA dummy operational mode: use this for waiting for multiple triggers */
/** @}*/ /*HWA_ACCELMODE*/


/**
 * @defgroup HWA_CFAR_OPER_MODE     HWA_CFAR_OPER_MODE
 * @brief    Macros that define values for the combination of CFAR operational mode (log, mag, mag sqr)
 *           and input samples type (real, complex)
 *
 *
 *Value  |CFAR_LOG_MODE  |CFAR_INP_MODE  |CFAR_ABS_MODE |register bits|description
 *-------| --------------|---------------|--------------|-------------|-------------
 * 0     |              1|              1|dont care     | 1100        |input are real, log-magnitude samples and no operation is needed inside HWA
 * 1     |              1|              0|3             | 0111        |input are complex samples and HWA should perform log-magnitude operation
 * 2     |              0|              1|dont care     | 1000        |input are real, magnitude samples and no operation is needed inside HWA
 * 3     |              0|              0|2             | 0010        |input are complex samples and HWA should perform magnitude operation
 * 4     |              0|              1|dont care     | 1000        |input are real, magnitude-sqr samples and no operation is needed inside HWA
 * 5     |              0|              0|0             | 0000        |input are complex samples and HWA should perform magnitude-sqr operation
 * @{
 */
#define HWA_CFAR_OPER_MODE_LOG_INPUT_REAL           0U     /*!<  input are real samples in log scale and no operation is needed inside HWA*/
#define HWA_CFAR_OPER_MODE_LOG_INPUT_COMPLEX        1U     /*!<  input are complex samples and HWA should perform log-magnitude operation */
#define HWA_CFAR_OPER_MODE_MAG_INPUT_REAL           2U     /*!<  input are real, magnitude samples and no operation is needed inside HWA */
#define HWA_CFAR_OPER_MODE_MAG_INPUT_COMPLEX        3U     /*!<  input are complex samples and HWA should perform magnitude operation */
#define HWA_CFAR_OPER_MODE_MAG_SQR_INPUT_REAL       4U     /*!<  input are real, magnitude-sqr samples and no operation is needed inside HWA */
#define HWA_CFAR_OPER_MODE_MAG_SQR_INPUT_COMPLEX    5U     /*!<  input are complex samples and HWA should perform magnitude-sqr operation */
/** @}*/ /*HWA_CFAR_OPER_MODE*/

/**
 * @defgroup HWA_CFAR_OUTPUT_MODE       HWA_CFAR_OUTPUT_MODE
 * @brief    Macros that define values for the output of CFAR block
 *           and input samples type (real, complex)
 * @details
 *             Value  |  I channel                             | Q channel
 *             ------ | ---------------------------------------|-------------
 *             0      |  Noise average values for all cells    | Cell under test
 *             1      |  Noise average values for all cells    | Binary detection flag
 *             2      |  Peak Index                            | Surrounding noise value
 *             3      |  Peak Index                            | Cell under test value
 * @{
 */
#define HWA_CFAR_OUTPUT_MODE_I_nAVG_ALL_Q_CUT                   ((uint8_t)0U)     /*!<I channel=Noise average values for all cells;
                                                                                        Q channel=Cell under test (CUT) */
#define HWA_CFAR_OUTPUT_MODE_I_nAVG_ALL_Q_DET_FLAG              ((uint8_t)1U)     /*!<I channel=Noise average values for all cells;
                                                                                        Q channel=Binary detection flag */
#define HWA_CFAR_OUTPUT_MODE_I_PEAK_IDX_Q_NEIGHBOR_NOISE_VAL    ((uint8_t)2U)     /*!<I channel=Peak Index;
                                                                                        Q channel=Surrounding noise value */
#define HWA_CFAR_OUTPUT_MODE_I_PEAK_IDX_Q_CUT                   ((uint8_t)3U)     /*!<I channel=Peak Index;
                                                                                        Q channel=Cell under test (CUT) */
/** @}*/ /*HWA_CFAR_OUTPUT_MODE*/

/**
 * @defgroup HWA_RAM_TYPE       HWA_RAM_TYPE
 * @brief    Macros that define values for the ramType argument of HWA_configRam() function.
 * @{
 */
#define HWA_RAM_TYPE_WINDOW_RAM             ((uint8_t)0U)         /*!< WINDOW RAM for windowing operation */
#define HWA_RAM_TYPE_INTERNAL_RAM           ((uint8_t)1U)         /*!< Internal RAM for Vector Multiplication mode */
/** @}*/ /*HWA_RAM_TYPE*/

/**
 * @defgroup HWA_PARAMDONE_INTERRUPT_TYPE       HWA_PARAMDONE_INTERRUPT_TYPE
 * @brief    Macros that define values for the destination of interrupt (CPU or DMA)
             when the paramset is completed.
 * @{
 */
#define HWA_PARAMDONE_INTERRUPT_TYPE_CPU              ((uint8_t)1U)   /*!< Interrupt CPU when paramset is completed */
#define HWA_PARAMDONE_INTERRUPT_TYPE_DMA              ((uint8_t)2U)   /*!< Trigger DMA when paramset is completed */
/** @}*/ /*HWA_PARAMDONE_INTERRUPT_TYPE*/

/**
 * @defgroup HWA_COMMONCONFIG_MASK      HWA_COMMONCONFIG_MASK
 * @brief    Macros that define values to use for \ref HWA_CommonConfig_t::configMask when specifying which values in 
 *           the \ref HWA_CommonConfig_t are valid.
 * @{
 */
#define HWA_COMMONCONFIG_MASK_NUMLOOPS              0x00000001      /*!< Use when \ref HWA_CommonConfig_t::numLoops is valid*/
#define HWA_COMMONCONFIG_MASK_PARAMSTARTIDX         0x00000002      /*!< Use when \ref HWA_CommonConfig_t::paramStartIdx is valid*/
#define HWA_COMMONCONFIG_MASK_PARAMSTOPIDX          0x00000004      /*!< Use when \ref HWA_CommonConfig_t::paramStopIdx is valid*/
#define HWA_COMMONCONFIG_MASK_FFT1DENABLE           0x00000008      /*!< Use when \ref HWA_CommonConfig_t::fft1DEnable is valid*/
#define HWA_COMMONCONFIG_MASK_BPMRATE               0x00000010      /*!< Use when \ref HWA_CommonConfig_t::bpmRate is valid*/
#define HWA_COMMONCONFIG_MASK_BPMPATTERN            0x00000020      /*!< Use when \ref HWA_CommonConfig_t::bpmPattern is valid*/
#define HWA_COMMONCONFIG_MASK_INTERFERENCETHRESHOLD 0x00000040      /*!< Use when \ref HWA_CommonConfig_t::interferenceThreshold is valid*/
#define HWA_COMMONCONFIG_MASK_TWIDDITHERENABLE      0x00000080      /*!< Use when \ref HWA_CommonConfig_t::twidDitherEnable is valid*/
#define HWA_COMMONCONFIG_MASK_LFSRSEED              0x00000100      /*!< Use when \ref HWA_CommonConfig_t::lfsrSeed is valid*/
#define HWA_COMMONCONFIG_MASK_FFTSUMDIV             0x00000200      /*!< Use when \ref HWA_CommonConfig_t::fftSumDiv is valid*/
#define HWA_COMMONCONFIG_MASK_CFARTHRESHOLDSCALE    0x00000400      /*!< Use when \ref HWA_CommonConfig_t::cfarThresholdScale is valid*/
#define HWA_COMMONCONFIG_MASK_I_CMULT_SCALE         0x00001000      /*!< Use when \ref HWA_CommonConfig_t::i_cmult_scale is valid*/
#define HWA_COMMONCONFIG_MASK_Q_CMULT_SCALE         0x00002000      /*!< Use when \ref HWA_CommonConfig_t::q_cmult_scale is valid*/
/** @}*/ /*HWA_COMMONCONFIG_MASK*/

/**
 * @defgroup HWA_COMPLEX_MULTIPLY_MODE      HWA_COMPLEX_MULTIPLY_MODE
 * @brief    Macros that define values for the various modes of the Complex multiply block
 * @{
 */
#define HWA_COMPLEX_MULTIPLY_MODE_DISABLE                   ((uint8_t)0U)    /*! 0-disable */
#define HWA_COMPLEX_MULTIPLY_MODE_FREQ_SHIFTER              ((uint8_t)1U)    /*! 1-Freq Shifter mode (set also twidIncrement) */
#define HWA_COMPLEX_MULTIPLY_MODE_SLOW_DFT                  ((uint8_t)2U)    /*! 2-slow DFT mode (set also dft.startFreq and dft.freqIncrement) */
#define HWA_COMPLEX_MULTIPLY_MODE_FFT_STITCHING             ((uint8_t)3U)    /*! 3-FFT stitching mode (set also twidFactorPattern) */
#define HWA_COMPLEX_MULTIPLY_MODE_MAG_SQUARED               ((uint8_t)4U)    /*! 4-Magnitude Squared mode */
#define HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT               ((uint8_t)5U)    /*! 5-Scalar Multiplication mode 
                                                                        set also \ref HWA_CommonConfig_t::i_cmult_scale and 
                                                                        \ref HWA_CommonConfig_t::q_cmult_scale) */
#define HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT               ((uint8_t)6U)    /*! 6-Vector Multiplication mode (set also Internal RAM using HWA_configRam) */
#define HWA_COMPLEX_MULTIPLY_MODE_VECTOR_MULT_2             ((uint8_t)7U)    /*! 7-Vector Multiplication mode 2 (set also Internal RAM using HWA_configRam) */
/** @}*/ /*HWA_COMPLEX_MULTIPLY_MODE*/

/**
 * @defgroup HWA_FFT_STITCHING_TWID_PATTERN     HWA_FFT_STITCHING_TWID_PATTERN
 * @brief    Macros that define values for the various modes of the Complex multiply block      block
 * @{
 */
#define HWA_FFT_STITCHING_TWID_PATTERN_2K                   ((uint8_t)0U)     /*! 2K fft stitching twid factor pattern */
#define HWA_FFT_STITCHING_TWID_PATTERN_4K                   ((uint8_t)1U)     /*! 4K fft stitching twid factor pattern */
/** @}*/ /*HWA_FFT_STITCHING_TWID_PATTERN*/

/** @}*/ /*end of HWA_MACROS group*/


/*!
 *  @brief      A handle that is returned from a HWA_open() call.
 */
typedef void* HWA_Handle;


/*!
 *  @brief    HWA Interrupt callback function after every paramset completion
 *
 *  HWA Interrupt callback function to be used with HWA_enableParamSetInterrupt() call
 *
 */
typedef void (*HWA_ParamDone_IntHandlerFuncPTR)(uint32_t paramSet, void * arg);

/*!
 *  @brief    HWA Interrupt callback function after all paramsets completion
 *
 *  HWA Interrupt callback function to be used with HWA_enableDoneInterrupt() call
 *
 */
typedef void (*HWA_Done_IntHandlerFuncPTR)( void * arg);


/*!
 *  @brief    HWA H/W Parameters
 *
 *  HWA parameters are used to with the HWA_open() call. 
 *
 */
typedef struct HWA_HWAttrs_t {
    uint32_t                instanceNum;                /*!< HWA Instance num - this is related to actual H/W instance of this IP */
    volatile uint32_t       ctrlBaseAddr;               /*!< HWA Peripheral's base address for the control/common register space */
    volatile uint32_t       paramBaseAddr;              /*!< HWA Peripheral's base address for the paramset space */
    volatile uint32_t       ramBaseAddr;                /*!< HWA Peripheral's base address for the Window/Internal RAM space */
    volatile uint32_t       dssBaseAddr;                /*!< DSS base address for the common settings */
    uint32_t                numHwaParamSets;            /*!< Number of HWA paramsets in this instance */
    uint32_t                intNumParamSet;             /*!< HWA Peripheral's interrupt vector for individual paramset completion*/
    uint32_t                intNumDone;                 /*!< HWA Peripheral's interrupt vector for completion of all programmed paramset*/
    uint32_t                numDmaChannels;             /*!< Number of DMA channels available for HWA (src or dst) */
    volatile uint32_t       accelMemBaseAddr;           /*!< HWA Accelerator processing memory base address */
    uint32_t                accelMemSize;               /*!< HWA Accelerator processing memory size in bytes */
} HWA_HWAttrs;

/*!
 *  @brief    Source trigger DMA parameters 
 *
 *  Source trigger DMA parameters that the user can use to configure a generic DMA channel to trigger the HWA
 *  
 *  Note: source and destination addresses represent CPU view of HWA address. 
 *        Depending on the SOC and the dma engine which is used for transfer, they may need to be translated by caller. 
 * 
 *  Example: SOC_translateAddr API with SOC_TranslateAddr_Dir_TO_EDMA should be used 
 *           when passing it to EDMA API for configuration.
 */
typedef struct HWA_SrcDMAConfig_t {
    uint32_t       srcAddr;             /*!< source Address for the DMA programming */
    uint32_t       destAddr;            /*!< destination Address for the DMA programming */
    uint16_t       aCnt;                /*!< A count for the DMA programming */
    uint16_t       bCnt;                /*!< B count for the DMA programming */
    uint16_t       cCnt;                /*!< C count for the DMA programming */
} HWA_SrcDMAConfig;



/*!
 *  @brief    HWA Common Config
 *
 *  HWA common config parameters that are used with the HWA_ConfigCommon() call. 
 *
 */
typedef struct HWA_CommonConfig_t {
    uint32_t            configMask;             /*!< See \ref HWA_COMMONCONFIG_MASK macros for correct values.
                                                     Set this to specify which of the fields are valid when calling 
                                                     HWA_ConfigCommon API. */
    uint16_t            numLoops;               /*!< number of loops to run from paramStartIdx to paramStopIdx 
                                                     valid value (12 bits): 0-4094; 4095 for infinitie. 
                                                     Sets the NUMLOOPS */
    uint8_t             paramStartIdx;          /*!< start index of paramset through which state machine loops through 
                                                     valid value: 4bits (0-15)
                                                     Sets the PARAMSTART */
    uint8_t             paramStopIdx;           /*!< stop index of paramset through which state machine loops through 
                                                     valid value: 4bits (0-15)
                                                     Sets the PARAMSTOP */
    struct {
        uint8_t         fft1DEnable;            /*!< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                        Setting to 1 enables HWA in FFT1D mode - ACCEL_MEM0 and ACCEL_MEM1 
                                                        are assumed to be shared with the ping-pong ADC buffers.
                                                        At the end of the active transmission portion of a frame, this bit can be reset,
                                                        so that the accelerator has access to all the four local memories independently.
                                                     Sets FFT1DEN bit of HWACCREG1 */
        uint16_t        bpmRate;                /*!< 10 bit value: specifies the number of input samples corresponding to each BPM chip.
                                                        value of 0 is invalid
                                                     Sets BPMRATE bits in HWACCREG7 */
        uint32_t        bpmPattern[2];          /*!< 64-bit value: specifies a Binary Phase Modulation (BPM) pattern to be removed on 
                                                        the input samples prior to FFT
                                                     Sets HWACCREG5 (MSB,bpmPattern[1])  and HWACCREG6 (LSB,bpmPattern[0]) registers */
        uint32_t        interferenceThreshold;  /*!< 24-bit value: Interference zero-out threshold - is used to zero-out sample(s), 
                                                        whose magnitude (24-bit absolute value of the 24-bit complex input)
                                                        is very high, prior to computing the FFT 
                                                        The HWA_AccelModeFFT_t::interfZeroOutEn field should be enabled
                                                        in the intended paramset for this threshold to be used*/
        uint8_t         twidDitherEnable;       /*!< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                        Setting to 1 Enable Dithering for Twiddle Factors 
                                                        It is recommended to keep this register bit always set to 1 
                                                        (i.e., dithering enabled)
                                                     Sets the DITHERTWIDEN bit in HWACCREG7 register */
        uint32_t        lfsrSeed;               /*!< 29-bit value: LFSR seed. Sets the LFSRSEED bits in HWACCREG11 */
        uint8_t         fftSumDiv;              /*!< 5-bit value: specifies the number of bits to right-shift the sum statistic (36-bit)
                                                        before it is written to destination memory (24-bit)
                                                     Sets the FFTSUMDIV bits in HWACCREG8 register */
    } fftConfig;
    
    struct {
        uint32_t        cfarThresholdScale;     /*!< 18-bit value: specifies the threshold scale factor that is used to 
                                                        either multiply or add to the 'surrounding noise average' to determine 
                                                        the threshold used for detection of the present cell under test
                                                        in log mode, this value should be represented as 7.11.
                                                        in mag/mag-sqr mode, this value should be represented as 14.4.
                                                     Sets the CFAR_THRESH bits in HWACCREG13 register */
    } cfarConfig;
    
    struct {
        uint32_t    i_cmult_scale;              /*!< 21 bit value: real part of the scalar complex number used for scalar mult mode
                                                        i.e. \ref HWA_ComplexMultiply_t::mode=HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT
                                                     Sets the ICMULT_SCALE bits of HWACCREG9 */
        uint32_t    q_cmult_scale;              /*!< 21 bit value: imaginary part of the scalar complex number used for scalar mult mode
                                                        i.e. \ref HWA_ComplexMultiply_t::mode=HWA_COMPLEX_MULTIPLY_MODE_SCALAR_MULT
                                                     Sets the ICMULT_SCALE bits of HWACCREG10 */
    } scalarMult;
} HWA_CommonConfig;

/*!
 *  @brief    HWA Paramset Config for Input Formatter/Source block
 *
 *  HWA paramset config parameters for the Input Formatter/Source block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call. 
 *
 */
typedef struct HWA_SourceConfig_t {
    uint16_t    srcAddr;                    /*!< 16 bit value:  specifies the starting address of the input samples
                                                    in the accelerator memory. Value of 0x0000 points to the 
                                                    first byte of accelerator memory and 16-bit value covers 
                                                    the entire address space of the four memories (4x16KB=64 KB)
                                                 Sets the SRCADDR bits of PARAM1_1 */
    uint16_t    srcAcnt;                    /*!< 12 bit value: specifies the number of samples (minus 1) from the source memory 
                                                    to process for every iteration. 
                                                    Note: The unit is samples and not bytes.
                                                 Sets the SRCACNT bits of PARAM1_2 */
    int16_t     srcAIdx;                    /*!< 16 bit value: specifies the number of bytes separating successive samples 
                                                    in the source memory
                                                 Sets the SRCAINDX bits of PARAM1_3 */
    uint16_t    srcBcnt;                    /*!< 12 bit value: specifies the number of times (minus 1) the processing should be iterated
                                                 Sets the BCNT bits of PARAM1_5 */
    int16_t     srcBIdx;                    /*!< 16 bit value: Specifies the number of bytes separating the start 
                                                    address of samples for successive iterations in the 
                                                    source memory (in bytes, signed value)
                                                Sets the SRCBIDX bits in PARAM1_4  */
    uint16_t    srcShift;                   /*!< 12 bit value: specifies the circular shift (offset in samples) that should 
                                                    be applied on the sequence of input samples before feeding them 
                                                    to the Core Computational unit
                                                 Sets the CIRCIRSHIFT bits of PARAM1_7 */
    uint8_t     srcCircShiftWrap;           /*!< 4 bit value: indicates at what number (power-of-2) the sample count value should wraparound, 
                                                    when using circular shift.
                                                 Sets the CIRCSHIFTWRAP bits of PARAM1_7 */
    uint8_t     srcRealComplex;             /*!< 1 bit value: See \ref HWA_SAMPLES_FORMAT macros for correct values.
                                                    Real or Complex data in the source memory.
                                                 Sets the SRCREAL bits in PARAM1_2*/
    uint8_t     srcWidth;                   /*!< 1 bit value: See \ref HWA_SAMPLES_WIDTH macros for correct values.
                                                    16-bit or 32-bit data width in source memory.
                                                 Sets the SRC16b32b bits in PARAM1_2 */
    uint8_t     srcSign;                    /*!< 1 bit value: See \ref HWA_SAMPLES_SIGN macros for correct values.
                                                    Signed or Unsigned data in the source memory. 
                                                    This setting is only relevant for srcWidth=0 (16 bits), 
                                                    because that is when sign-extension 
                                                    may be required to convert to internal 24-bit width.
                                                 Sets the SRCSIGNED bits in PARAM1_2 */
    uint8_t     srcConjugate;               /*!< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable Conjugation of the input samples.
                                                        0: No conjugation
                                                        1: Enable conjugation
                                                    This register only makes sense for srcRealComplex=0 (complex). 
                                                    It is useful in conjunction with DSTCONJ to derive an IFFT 
                                                    mode (by conjugating at both input and output)
                                                 Sets the SRCCONJ bit of PARAM1_2 */
    uint8_t     srcScale;                   /*!< 4 bit value: Specifies a programmable scaling, via right bit-shift,
                                                    from 0 bits to 8 bits, for the input samples.
                                                 Sets the SRCSCAL bits of PARAM1_5 (0-8).
                                                 Based on the REG_SRCSCAL register value, a right bit-shift of
                                                 0 to 8 bits is applied first, with additional MSB sign-extension
                                                 (based on REG_SRCSIGNED) and LSB rounding.  The resulting 32-bit
                                                 sample is then saturated to a 24-bit number by saturating the 8 MSBs */
    uint8_t     bpmEnable;                  /*!< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable for BPM removal operation
                                                        0: disable
                                                        1: enable
                                                 Sets the BPM_EN bits of PARAM1_0*/
    uint8_t     bpmPhase;                   /*!< 4 bit value: Specifies the starting phase of the BPM pattern 
                                                    to be applied
                                                 Sets the BPMPHASE bits of PARAM1_6*/
} HWA_SourceConfig;

/*!
 *  @brief    HWA Paramset Config for Output Formatter/Destination block
 *
 *  HWA paramset config parameters for the Output Formatter/Destination block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call. 
 *
 */
typedef struct HWA_DestConfig_t {
    uint16_t    dstAddr;                    /*!< 16 bit value:  specifies the starting address of the output samples
                                                    in the accelerator memory. Value of 0x0000 points to the 
                                                    first byte of accelerator memory and 16-bit value covers 
                                                    the entire address space of the four memories (4x16KB=64 KB)
                                                 Sets the DSTADDR bits of PARAM1_1 */
    uint16_t    dstAcnt;                    /*!< 12 bit value: specifies the number of samples (minus 1) from the destination
                                                    memory to process for every iteration. 
                                                    Note: The unit is samples and not bytes.
                                                 Sets the DSTACNT bits of PARAM1_2 */
    int16_t     dstAIdx;                    /*!< 16 bit value: specifies the number of bytes separating successive samples 
                                                    in the destination memory
                                                 Sets the DSTAINDX bits of PARAM1_3 */
    int16_t     dstBIdx;                    /*!< 16 bit value: Specifies the number of bytes separating the start 
                                                    address of samples for successive iterations in the 
                                                    destination memory (in bytes, signed value)
                                                 Sets the DSTBIDX bits in PARAM1_4  */
    uint8_t     dstRealComplex;             /*!< 1 bit value: See \ref HWA_SAMPLES_FORMAT macros for correct values.
                                                    Real or Complex data in the destination memory.
                                                 Sets the DSTREAL bits in PARAM1_2*/
    uint8_t     dstWidth;                   /*!< 1 bit value: See \ref HWA_SAMPLES_WIDTH macros for correct values.
                                                    16-bit or 32-bit alignment of data in destination memory.
                                                 Sets the DST16b32b bits in PARAM1_2 */
    uint8_t     dstSign;                    /*!< 1 bit value: See \ref HWA_SAMPLES_SIGN macros for correct values.
                                                    Signed or Unsigned data in the destination memory. 
                                                    This setting is only relevant for dstWidth=0, 
                                                    because that is when sign-extension 
                                                    may be required to convert to internal 24-bit width.
                                                 Sets the DSTSIGNED bits in PARAM1_2 */
    uint8_t     dstConjugate;               /*!< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable Conjugation of the output samples.
                                                        0: No conjugation
                                                        1: Enable conjugation
                                                    This register only makes sense for dstRealComplex=0. 
                                                    It is useful in conjunction with DSTCONJ to derive an IFFT 
                                                    mode (by conjugating at both output and output)
                                                 Sets the DSTCONJ bit of PARAM1_2 */
    uint8_t     dstScale;                   /*!< 4 bit value: Specifies a programmable scaling, via right bit-shift,
                                                    from 0 bits to 8 bits, for the output samples.
                                                 Sets the DSTSCAL bits of PARAM1_5 (0-8) The 24-bit complex samples
                                                 are first converted to 32-bit complex samples by zero padding 8 LSBs.
                                                 Then, based on the REG_DSTSCAL register value, a right bit-shift of 0
                                                 to 8 bits is applied (with MSB sign filling, if required).*/
    uint16_t    dstSkipInit;                /*!<10 bit value: Number of samples to skip in the beginning (for each 
                                                    iteration) before writing samples to the destination 
                                                    memory.
                                                 Sets the DST_SKIP_INIT bits of PARAM1_5*/
}HWA_DestConfig;

/*!
 *  @brief    HWA Paramset Config for FFT block
 *
 *  HWA paramset config parameters for the FFT block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call. 
 *
 */
typedef struct HWA_AccelModeFFT_t{
    uint8_t      fftEn;                     /*!< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable for FFT computation
                                                        0 - FFT disabled (Pipelined FFT sub-block bypassed)
                                                        1 - FFT enabled  (Pipelined FFT sub-block enabled)
                                                Sets the FFT_EN bits of PARAM1_0 */
    uint8_t      fftSize;                   /*!< 4 bit value: Specifies FFT size. Actual FFT size is equal to 2^(fftSize)
                                                    Supported values are [1..10], which correspond to FFT sizes [2..1024].
                                                    The actual FFT size should be equal to or larger than srcAcnt
                                                Sets the FFTSIZE bits of PARAM1_6 */
    uint16_t     butterflyScaling;          /*!< 10 bit value: 1 bit per butterfly stage. LSB is for last stage and MSB is for the first stage 
                                                    for each bit, 
                                                        0 - MSB is saturated
                                                        1 - convergent rounded at LSB (divide by 2)
                                                    Number of valid bits in this field depends on the fftSize.
                                                Sets the BFLY_SCALING bits of PARAM1_6 */
    uint8_t      interfZeroOutEn;          /*!< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable for interference zeroing out
                                                    HWA_CommonConfig_t::interferenceThreshold field 
                                                    should be set to a valid value if this field is enabled.
                                                Sets the INTERF_THRESH_EN bits of PARAM1_6 */
    uint8_t      windowEn;                  /*!< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    Enable/Disable for Windowing operation
                                                Sets the WINDOW_EN bits of PARAM1_0 */
    uint16_t     windowStart;               /*!< 10 bit value: (0-1023) Specifies the offset from the actual Window RAM base address
                                                    and represents the starting address of the window function 
                                                    in the Window RAM. A value of 0x0 means the starting address 
                                                    is the first 32-bit word in the Window RAM, 0x1 is the second 32-bit word and so on.
                                                Sets the WINDOW_START bits of PARAM1_6 */
    uint8_t      winSymm;                   /*!< 1 bit value: See \ref HWA_WINDOW_SYMM macros for correct values.
                                                    Indicates whether the window function is symmetric or not
                                                Sets the WINSYMM bits of PARAM1_6 */
    uint8_t      winInterpolateMode;        /*!< 2 bit value: See \ref HWA_FFT_WINDOW_INTERPOLATE_MODE macros for correct values.
                                                    Configures linear interpolation for the window coefficients, which is 
                                                    relevant for large-size FFT computation (i.e., FFT sizes of 2K, 4K) that 
                                                    is obtained via stitching multiple smaller-size FFTs.
                                                    (Note: winSymm should be set to 0 when using 4K or 2K mode(
                                                Sets the WINDOW_INTERP_FRACTION bits of PARAM1_7 */
    uint8_t       magLogEn;                  /*!< 2 bit value: See \ref HWA_FFT_MODE_MAGNITUDE_LOG2 macros for correct values.
                                                    Enable/Disable for Magnitude and Log2 computation
                                                Sets the ABS_EN, LOG2EN bits of PARAM1_0 */ 
    uint8_t       fftOutMode;                /*!< 2 bit value: See \ref HWA_FFT_MODE_OUTPUT macros for correct values.
                                                    Configures the output mode of the FFT Engine path
                                                    For stats mode, following parameters will be overriden in 
                                                    \ref HWA_DestConfig of that paramset
                                                      dstAcnt=4095, dstAIdx=dstBIdx=8, dstWidth=1, dstRealComplex=0.
                                                Sets the FFT_OUTPUT_MODE bits of PARAM1_0 */
} HWA_AccelModeFFT;

/*!
 *  @brief    HWA Paramset Config for ComplexMultiply block
 *
 *  HWA paramset config parameters for the ComplexMultiply block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call. 
 *
 */
typedef struct HWA_ComplexMultiply_t {
    uint8_t      mode;                      /*!< 3 bit value: See \ref HWA_COMPLEX_MULTIPLY_MODE macros for correct values.
                                                   Configuration for the Complex Multiplier block
                                               Sets the CMULT_MODE bits of PARAM1_0 */
    union {
        uint16_t    twidIncrement;          /*!< 14 bit value: used when \ref HWA_ComplexMultiply_t::mode 
                                                    is HWA_COMPLEX_MULTIPLY_MODE_FREQ_SHIFTER and specifies how the LUT read index 
                                                    is incremented for every successive input sample and hence it controls 
                                                    the de-rotation frequency
                                                Sets the TWIDINCR bits of PARAM1_7 */
        struct {
            uint16_t    startFreq;          /*!< 14 bit value: used when \ref HWA_ComplexMultiply_t::mode=HWA_COMPLEX_MULTIPLY_MODE_SLOW_DFT
                                                    and specifies starting frequency for the DFT computation 
                                                 Sets the TWIDINCR bits of PARAM1_7 */
            uint8_t     freqIncrement;      /*!< 4 bit value: used when \ref HWA_ComplexMultiply_t::mode=HWA_COMPLEX_MULTIPLY_MODE_SLOW_DFT
                                                    and specifies the increment value by which the frequency increments in every iteration.
                                                    Supported values are [0..14]
                                                    The true increment value is 2^(14-freqIncrement).
                                                 Sets the FFTSIZE bits of PARAM1_6 */
        } dft;
        uint8_t     twidFactorPattern;      /*!< 2 bit value: See \ref HWA_FFT_STITCHING_TWID_PATTERN macros for correct values.
                                                    This field is used when \ref HWA_ComplexMultiply_t::mode=HWA_COMPLEX_MULTIPLY_MODE_FFT_STITCHING
                                                    and conveys the twid factor pattern to be used. 
                                                    0: 2K (2x1024) size FFT stitching twiddle factor pattern
                                                    1: 4K (4x1024) size FFT stitching twiddle factor pattern
                                                    other values are invalid
                                                Sets the TWIDINCR bits of PARAM1_7 */
    }cmpMulArgs;
}HWA_ComplexMultiply;

/*!
 *  @brief    HWA Paramset Config for CFAR block
 *
 *  HWA paramset config parameters for the CFAR block inside HWA_ParamConfig which is used with the HWA_ConfigParamSet() call. 
 *
 */
typedef struct HWA_AccelModeCFAR_t{
    uint8_t      numNoiseSamplesLeft;       /*!< 6 bit value: specify the number of samples used for noise averaging
                                                    to the left of the cell under test.
                                                    Note: The actual number of samples used for noise averaging in H/W is equal 
                                                    to the value of this field multiplied by 2
                                                Sets the CFAR_AVG_LEFT (add note of factor of 2) bits of PARAM1_7 */
    uint8_t      numNoiseSamplesRight;      /*!< 6 bit value: specify the number of samples used for noise averaging
                                                    to the right of the cell under test.
                                                    Note: The actual number of samples used for noise averaging in H/W is equal 
                                                    to the value of this field multiplied by 2
                                                Sets the CFAR_AVG_RIGHT (add note of factor of 2) bits of PARAM1_7 */
    uint8_t      numGuardCells;             /*!< 3 bit value: specifies the number of guard cells to ignore on either side of the cell under test
                                                Sets the CFAR_GUARD_INT bits of PARAM1_6 */
    uint8_t      nAvgDivFactor;             /*!< 4 bit value: specifies the division factor by which the noise sum calculated from the 
                                                    left and right noise windows are divided by in order to get the final 
                                                    surrounding noise average value.
                                                    The division factor is equal to 2^nAvgDivFactor
                                                    Valid values: 0-8
                                                Sets the CFAR_NOISEDIV (add note) bits of PARAM1_6 */
    uint8_t      nAvgMode;                  /*!< 2 bit value: See \ref HWA_NOISE_AVG_MODE_CFAR macros for correct values.
                                                    configures the noise averaging mode in the CFAR detector
                                              Sets the CFAR_CA_MODE bits of PARAM1_7 */
    uint8_t      operMode;                  /*!< See \ref HWA_CFAR_OPER_MODE macros for correct values.
                                                Sets the CFAR_LOG_MODE, CFAR_INP_MODE, CFAR_ABS_MODE bits of PARAM1_0 */
    uint8_t      outputMode;                /*!< 2 bit value: See \ref HWA_CFAR_OUTPUT_MODE macros for correct values.
                                                    select the output mode of the CFAR engine
                                                Sets the CFAR_OUT_MODE  bits of PARAM1_7 */
    uint8_t      peakGroupEn;               /*!< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    specifies whether peak grouping should be enabled
                                                      HWA_FEATURE_BIT_DISABLE - peak grouping is disabled, which means that a peak is declared as detected 
                                                          as long as the cell under test exceeds the threshold
                                                      HWA_FEATURE_BIT_ENABLE - peak is declared as detected only if it the cell under test exceeds the threshold,
                                                          as well as, if the cell under test exceeds the two neighboring cells to its immediate 
                                                          left and right
                                                Sets the CFAR_GROUPING_EN bits of PARAM1_0 */
    uint8_t      cyclicModeEn;              /*!< 1 bit value: See \ref HWA_FEATURE_BIT macros for correct values.
                                                    specifies whether the CFAR-CA detector needs to work in cyclic mode or in non-cyclic mode
                                                              HWA_FEATURE_BIT_DISABLE=non-cyclic mode
                                                              HWA_FEATURE_BIT_ENABLE=cyclic mode
                                                Sets the CFAR_CYCLIC  bits of PARAM1_0 */
}HWA_AccelModeCFAR;

/*!
 *  @brief    HWA Paramset Config
 *
 *  HWA paramset config parameters that are used with the HWA_ConfigParamSet() call. 
 *
 */
typedef struct HWA_ParamConfig_t {
    uint8_t             triggerMode;                /*!< See \ref HWA_TRIG_MODE macros for correct values.
                                                         Sets the TRIGMODE bits of PARAM1_0*/
    uint8_t             dmaTriggerSrc;              /*!< DMA channel number to be monitored for dma based trigger mode.
                                                            this field is used only when \ref HWA_ParamConfig_t::triggerMode
                                                            is set to \ref HWA_TRIG_MODE_DMA
                                                         Sets the DMA2ACC_CHANNEL_TRIGSRC bits in PARAM1_0*/
    uint8_t             accelMode;                  /*!< 2 bit value: See \ref HWA_ACCELMODE macros for correct values.
                                                            Configures the mode of operation of the accelerator for 
                                                            the current parameter-set.
                                                         Sets the ACCEL_MODE bits of PARAM1_0*/
    HWA_SourceConfig    source;                     /*!< Source related params */
    HWA_DestConfig      dest;                       /*!< Dest related params */
    union {
        HWA_AccelModeFFT    fftMode;                /*!< FFT mode related params */
        HWA_AccelModeCFAR   cfarMode;               /*!< CFAR mode related params */
    }accelModeArgs;
    HWA_ComplexMultiply     complexMultiply;        /*!< Complex multiply related params used when \ref HWA_ParamConfig_t::accelMode 
                                                            is not \ref HWA_ACCELMODE_CFAR */
}HWA_ParamConfig;

/*!
 *  @brief    HWA Interrupt Config
 *
 *  HWA interrupt config parameters that are used with the HWA_enableParamSetInterrupt() call. 
 *
 */
typedef struct HWA_InterruptConfig_t {
    uint8_t             interruptTypeFlag;      /*!< Flag to specify whether Interrupt to CPU and/or DMA 
                                                     is desired on completion of paramset.
                                                     Defines for \ref HWA_PARAMDONE_INTERRUPT_TYPE can be ORed to
                                                     specify this flag */
    struct {
        HWA_ParamDone_IntHandlerFuncPTR   callbackFn;     /*!< Callback function to be called when interrupt destination is CPU */
        void                             *callbackArg;    /*!< Callback function argument */
    }cpu;
    struct {
        uint8_t                           dstChannel;     /*!< DMA channel number to be triggered on paramset completion 
                                                               if interrupt destination to DMA is desired */
    }dma;
}HWA_InterruptConfig;

/*!
 *  @brief    HWA Statistics from the STATISTICS block
 *
 *  HWA statistics - MAX and SUM - that are output from the statistics block. 
 *
 */
typedef struct HWA_Stats_t {
    uint32_t             maxValue;      /*!< 24 bits value from MAXnVALUE register */
    uint16_t             maxIndex;      /*!< 24 bits value from MAXnINDEX register */
    uint8_t              iSumMSB;       /*!< upper 4 bits of 36-bit value of iSUM; read from ISUMnMSB */
    uint8_t              qSumMSB;       /*!< upper 4 bits of 36-bit value of qSUM; read from QSUMnMSB */
    uint32_t             iSumLSB;       /*!< lower 32 bits of 36-bit value of iSUM; read from ISUMnLSB */
    uint32_t             qSumLSB;       /*!< lower 32 bits of 36-bit value of qSUM; read from QSUMnLSB */
}HWA_Stats;

/*!
 *  @brief    HWA Debug statistics 
 *
 *  HWA debug - current paramset, loopcount, trigger status - that are output from the statistics block. 
 *
 */
typedef struct HWA_DebugStats_t {
    uint8_t             currentParamSet;        /*!< Index of the current paramset that is under execution.
                                                   useful for debug, where parameter-sets can be executed 
                                                   one-by-one using SW trigger mode for each of them.  In 
                                                   such a debug, this register indicates which parameter-set
                                                   is currently waiting for the SW trigger*/
    uint16_t            currentLoopCount;       /*!< the loop count that is presently running */

    uint16_t            dmaTrigStatus;          /*!< indicates whether a trigger was received via DMA trigger method */
    uint8_t             dfePingPongStatus;      /*!< the status of DFE ping-pong trigger */
    uint8_t             swTrigStatus;           /*!< the status of software trigger */
}HWA_DebugStats;

/*!
 *  @brief    HWA Local memory Information
 *
 *  HWA Local processing memory info - base address and Size.
 *
 */
typedef struct HWA_MemInfo_t {
    uint32_t    baseAddress;        /*!< Base Address of HWA Local memory */
    uint16_t    bankSize;           /*!< Total size in bytes of one bank */
    uint16_t    numBanks;           /*!< number of banks can be used of HWA Local memory */
}HWA_MemInfo;

/** @}*/

/** @addtogroup HWA_DRIVER_EXTERNAL_FUNCTION
 @{ */

/*!
 *  @brief  Function to initialize the HWA module
 *
 *  @pre    This function must be called once per system and before
 *          any other HWA driver APIs. It resets the HWA H/W instances in the system.
 *
 */
extern void HWA_init(void);

/*!
 *  @brief  Function to initialize HWA specified by the
 *  particular index value. 
 *
 *  @pre    HWA_init() has been called
 *
 *  @param  index         HWA instance number 
 *
 *  @param  socHandle     SOC Handle (can be obtained used SOC_init by the caller) 
 *
 *  @param  errCode       [out] valid errorCode if NULL handle returned.
 *
 *  @return A HWA_Handle upon success. NULL if an error occurs.
 *
 *  @sa     HWA_init()
 *  @sa     HWA_close()
 */
extern HWA_Handle HWA_open(uint32_t  index, SOC_Handle socHandle, int32_t* errCode);

/*!
 *  @brief  Function to close a HWA peripheral specified by the HWA handle
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle      A HWA_Handle returned from HWA_open()
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_close(HWA_Handle handle);

/*!
 *  @brief  Function to reset the internal state machine of the HWA
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */

extern int32_t HWA_reset(HWA_Handle handle);


/*!
 *  @brief  Function to set the common HWA configuration parameters 
 *          needed for the next operations/iterations/paramsets of HWA
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  commonConfig    HWA Common Config Parameters
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_configCommon(HWA_Handle handle, HWA_CommonConfig *commonConfig);

/*!
 *  @brief  Function to set the HWA configuration parameters for a given paramSet
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  paramsetIdx     A valid paramSet index for which the paramConfig is provided.
 *
 *  @param  paramConfig     HWA ParamSet Config Parameters
 *
 *  @param  dmaConfig       [out] This parameter is set by the driver with values that user
 *                                should use to program the source trigger DMA. user should provide
 *                                a valid buffer here if the triggerMode is set to DMA in paramConfig
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_configParamSet(HWA_Handle handle, uint8_t paramsetIdx, HWA_ParamConfig *paramConfig, HWA_SrcDMAConfig *dmaConfig);
                                                       
/*!
*  @brief  Function to get the config to program the DMA for a given DMA Trigger channel.
*          Application should use the returned config to program the DMA so that it can then 
*          in turn trigger the paramset. Application should make sure that the channel provided
*          here in dmaTriggerSrc should match the \ref HWA_ParamConfig_t::dmaTriggerSrc passed
*          to HWA_configParamSet()
*
*  @pre    HWA_open() has been called.
*
*  @param  handle          A HWA_Handle returned from HWA_open()
*
*  @param  dmaTriggerSrc   Same as \ref HWA_ParamConfig_t::dmaTriggerSrc of the paramset for 
*                          whom this DMA is getting configured
*
*  @param  dmaConfig       [out]This parameter is set by the driver with values that user
*                               should use to program the source trigger DMA. user should provide
*                               a valid buffer here if the triggerMode is set to DMA in paramConfig
*
*  @return 0 upon success. error code if an error occurs.
*
*  @sa     HWA_open()
*/
extern int32_t HWA_getDMAconfig(HWA_Handle handle, uint8_t dmaTriggerSrc, HWA_SrcDMAConfig *dmaConfig);

/*!
 *  @brief  Function to set the HWA RAM (either Internal RAM or window RAM)
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  ramType         Use defines \ref HWA_RAM_TYPE 
 *
 *  @param  data            data pointer that needs to be copied to RAM
 *
 *  @param  dataSize        Size of data to be copied
 *
 *  @param  startIdx        start index (in bytes) within RAM where data needs to be copied
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_configRam(HWA_Handle handle, uint8_t ramType, uint8_t *data, uint32_t dataSize, uint32_t startIdx);

/*!
 *  @brief  Function to enable the CPU and/or DMA interrupt after a paramSet completion.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  paramsetIdx     A valid paramSet index for which the intrConfig is provided.
 *
 *  @param  intrConfig      HWA Interrupt Config Parameters
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_enableParamSetInterrupt(HWA_Handle handle, uint8_t paramsetIdx, HWA_InterruptConfig *intrConfig);

/*!
 *  @brief  Function to enable the CPU interrupt after all programmed paramSets have been completed. 
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  callbackFn      user defined callback function to be called when this interrupt is generated
 *
 *  @param  callbackArg     user defined callback arg for the callback function
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_enableDoneInterrupt(HWA_Handle handle, HWA_Done_IntHandlerFuncPTR callbackFn, void * callbackArg );

/*!
 *  @brief  Function to disable the CPU and/or DMA interrupt after a paramSet completion. 
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle              A HWA_Handle returned from HWA_open()
 *
 *  @param  paramsetIdx         A valid paramSet index for which the interrupt is to be disabled
 *
 *  @param  interruptTypeFlag   Flag to indicate if CPU and/or DMA interrupts are to be disabled
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_disableParamSetInterrupt(HWA_Handle handle, uint8_t paramsetIdx, uint8_t interruptTypeFlag);

/*!
 *  @brief  Function to disable the CPU interrupt after all programmed paramSets have been completed. 
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_disableDoneInterrupt(HWA_Handle handle);

/*!
 *  @brief  Function to enable the state machine of the HWA. This should be called after 
 *          paramset and RAM have been programmed
 *
 *  @pre    HWA_open() HWA_ConfigCommon() HWA_ConfigParamSet HWA_ConfigRam has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  flagEnDis       Enable/Disable Flag: 0-disable, 1-enable
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_enable(HWA_Handle handle, uint8_t flagEnDis);

/*!
 *  @brief  Function to manually trigger the execution of the state machine via software
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_setSoftwareTrigger(HWA_Handle handle);


/*!
 *  @brief  Function to manually trigger the execution of the state machine waiting on DMA via software
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  idx            DMA channel number for whom software should simulate the trigger
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_setDMA2ACCManualTrig(HWA_Handle handle, uint16_t idx);


/*!
 *  @brief  Function to read the Clip Status registers
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  pbuf            pointer to a uint8_t size memory where value of Clip 
 *                          Status Register would be copied
 *
 *  @param  size            size (in bytes) of the pbuf register provided. 
 *                          It should be atleast 2 bytes.
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_readClipStatus(HWA_Handle handle, uint8_t *pbuf, uint8_t size);

/*!
 *  @brief  Function to clear the Clip Status registers
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_clearClipStatus(HWA_Handle handle);

/*!
 *  @brief  Function to read the 4 sets of 'MAX' statistics register
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  pStats          pointer to a memory of type HWA_Stats where value of all the  
 *                          Max and statistics Registers would be copied
 *
 *  @param  numIter         number of iterations to read. Value 1-4 should be provided. 
 *                          User is expected to provide enough space for the pStats to hold 'numIter' worth of HWA_Stats 
 *                          Ex: HWA_Stats appHWAStats[3]; HWA_readStatsReg(appHWAhandle,appHWAStats,3);
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_readStatsReg(HWA_Handle handle, HWA_Stats *pStats, uint8_t numIter);

/*!
 *  @brief  Function to read the PEAKCNT register
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  pbuf            pointer to a memory where value of the  
 *                          PEAKCNT Registers would be copied
 *
 *  @param  size            size (in bytes) of the pbuf register provided. 
 *                          It should be atleast 2 bytes.
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_readCFARPeakCountReg(HWA_Handle handle, uint8_t *pbuf, uint8_t size);

/*!
 *  @brief  Function to read the debug registers (paramcurr, loopcou, acc_trig_in_stat)
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  pStats          pointer to a memory of type HWA_debugStats where value of the
 *                          RDSTATUS and HWACCREG12 Registers would be copied
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_readDebugReg(HWA_Handle handle, HWA_DebugStats *pStats);



/*!
 *  @brief  Function to clear the debug registers (acc_trig_in_clr)
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_clearDebugReg(HWA_Handle handle);

/*!
 *  @brief  Function to get HWA processing Memory information including address, 
 *          size and number of banks.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  memInfo         Pointer to save HWA processing memory information
 *
  *  @return 0 upon success. error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_getHWAMemInfo(HWA_Handle handle, HWA_MemInfo *memInfo);

/*!
 *  @brief  Function to get the dma destination index with a given EDMA channel number 
 *          This function assumes the EDMA channel number is from the first EDMA instance.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  edmaChanId      EDMA channell id
 *
 *  @param  hwaDestChan     Pointer to save destination channel index
 *
 *  @return     =0          Success
 *              <0          Error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_getDMAChanIndex(HWA_Handle handle, uint8_t edmaChanId, uint8_t *hwaDestChan);

/*!
 *  @brief  Function to get the edma EDMA channel number from a given HWA paramset destination channel.
 *          This function assumes the EDMA channel number is from the first EDMA instance.
 *
 *  @pre    HWA_open() has been called.
 *
 *  @param  handle          A HWA_Handle returned from HWA_open()
 *
 *  @param  hwaDMAdestChan  Destination channle id set in a paramset
 *
 *  @return     >=0         Upon success, EDMA channel number
 *              <0          Error code if an error occurs.
 *
 *  @sa     HWA_open()
 */
extern int32_t HWA_getEDMAChanId(HWA_Handle handle, uint8_t hwaDMAdestChan);

/** @}*/


#ifdef __cplusplus
}
#endif

#endif /* ti_drivers_HWA__include */

