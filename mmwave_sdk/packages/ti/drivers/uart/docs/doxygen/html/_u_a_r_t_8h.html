<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>drivers/uart/UART.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_14bc92f4b96c8519b376567118ac28b3.html">drivers</a></li><li class="navelem"><a class="el" href="dir_e58102cd600d9275988c57b90c0b6f56.html">uart</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the header file for the UART driver which exposes the data structures and exported API which can be used by the applications to use the UART driver.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;ti/common/mmwave_error.h&gt;</code><br />
<code>#include &lt;ti/drivers/edma/edma.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___params__t.html">UART_Params_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Parameters.  <a href="struct_u_a_r_t___params__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___fxn_table__t.html">UART_FxnTable_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a UART function table that contains the required set of functions to control a specific UART driver implementation.  <a href="struct_u_a_r_t___fxn_table__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___config__t.html">UART_Config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Global configuration.  <a href="struct_u_a_r_t___config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_u_a_r_t___stats__t.html">UART_Stats_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Statistics.  <a href="struct_u_a_r_t___stats__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga923b8674ce5729a0838d61b668824b27"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_r_r_o_r___c_o_d_e.html#ga923b8674ce5729a0838d61b668824b27">UART_EINVAL</a>&#160;&#160;&#160;(MMWAVE_ERRNO_UART_BASE-1)</td></tr>
<tr class="memdesc:ga923b8674ce5729a0838d61b668824b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error Code: Invalid argument. <br /></td></tr>
<tr class="separator:ga923b8674ce5729a0838d61b668824b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56f63f4ad4979c54f65119fce0ca10d8"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_r_r_o_r___c_o_d_e.html#ga56f63f4ad4979c54f65119fce0ca10d8">UART_EINUSE</a>&#160;&#160;&#160;(MMWAVE_ERRNO_UART_BASE-2)</td></tr>
<tr class="memdesc:ga56f63f4ad4979c54f65119fce0ca10d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error Code: Operation cannot be implemented because a previous operation is still not complete. <br /></td></tr>
<tr class="separator:ga56f63f4ad4979c54f65119fce0ca10d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1513f8f6691830cec887ebf9bda38f97"><td class="memItemLeft" align="right" valign="top">
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_r_r_o_r___c_o_d_e.html#ga1513f8f6691830cec887ebf9bda38f97">UART_ENOTIMPL</a>&#160;&#160;&#160;(MMWAVE_ERRNO_UART_BASE-3)</td></tr>
<tr class="memdesc:ga1513f8f6691830cec887ebf9bda38f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error Code: Operation is not implemented. <br /></td></tr>
<tr class="separator:ga1513f8f6691830cec887ebf9bda38f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e71e92409f7a0eb01e071fa46aeaaf3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#ga7e71e92409f7a0eb01e071fa46aeaaf3">UART_CMD_LOOPBACK</a>&#160;&#160;&#160;0U</td></tr>
<tr class="memdesc:ga7e71e92409f7a0eb01e071fa46aeaaf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command code used by <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga89b171e42c715ca3c5a467a089f4eae2" title="Function performs implementation specific features on a given UART_Handle. ">UART_control()</a> to place the UART in loopback mode.  <a href="group___u_a_r_t___c_m_d.html#ga7e71e92409f7a0eb01e071fa46aeaaf3">More...</a><br /></td></tr>
<tr class="separator:ga7e71e92409f7a0eb01e071fa46aeaaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a07e60a3263683a66c2287d762dfe3d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___c_m_d.html#ga8a07e60a3263683a66c2287d762dfe3d">UART_CMD_GET_STATS</a>&#160;&#160;&#160;1U</td></tr>
<tr class="memdesc:ga8a07e60a3263683a66c2287d762dfe3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command code used by <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga89b171e42c715ca3c5a467a089f4eae2" title="Function performs implementation specific features on a given UART_Handle. ">UART_control()</a> to get the UART Instance statistics.  <a href="group___u_a_r_t___c_m_d.html#ga8a07e60a3263683a66c2287d762dfe3d">More...</a><br /></td></tr>
<tr class="separator:ga8a07e60a3263683a66c2287d762dfe3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada620b673241eb6335a71e75da291716"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada620b673241eb6335a71e75da291716"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ada620b673241eb6335a71e75da291716">UART_WAIT_FOREVER</a>&#160;&#160;&#160;0xFFFFFFFFU</td></tr>
<tr class="memdesc:ada620b673241eb6335a71e75da291716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait forever define. <br /></td></tr>
<tr class="separator:ada620b673241eb6335a71e75da291716"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0456e19fcbce573bc31c1f501f8f1589"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0456e19fcbce573bc31c1f501f8f1589"></a>
typedef struct <a class="el" href="struct_u_a_r_t___config__t.html">UART_Config_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a></td></tr>
<tr class="memdesc:a0456e19fcbce573bc31c1f501f8f1589"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from a <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga8a5775cb1f4aae7cca153d4e1f6ad716" title="Function to initialize a given UART peripheral. ">UART_open()</a> call. <br /></td></tr>
<tr class="separator:a0456e19fcbce573bc31c1f501f8f1589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa180fc9d177be8a1fbf44fc33a2bc73c"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_8h.html#af181cd5aa441af5f4e18ab6bc7212b94">UART_ReturnMode_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aa180fc9d177be8a1fbf44fc33a2bc73c">UART_ReturnMode</a></td></tr>
<tr class="memdesc:aa180fc9d177be8a1fbf44fc33a2bc73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART return mode settings.  <a href="#aa180fc9d177be8a1fbf44fc33a2bc73c">More...</a><br /></td></tr>
<tr class="separator:aa180fc9d177be8a1fbf44fc33a2bc73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df8ab128966ece5c06a82213a1a7aac"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_8h.html#a337b3c4a16154975e56efd930999fcb8">UART_DataMode_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a3df8ab128966ece5c06a82213a1a7aac">UART_DataMode</a></td></tr>
<tr class="memdesc:a3df8ab128966ece5c06a82213a1a7aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data mode settings.  <a href="#a3df8ab128966ece5c06a82213a1a7aac">More...</a><br /></td></tr>
<tr class="separator:a3df8ab128966ece5c06a82213a1a7aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e11c6c8410167fd0ae53f151c2f917"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_8h.html#a300f4e491cd61d8e974598e670ff39e8">UART_Echo_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ab8e11c6c8410167fd0ae53f151c2f917">UART_Echo</a></td></tr>
<tr class="memdesc:ab8e11c6c8410167fd0ae53f151c2f917"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART echo settings.  <a href="#ab8e11c6c8410167fd0ae53f151c2f917">More...</a><br /></td></tr>
<tr class="separator:ab8e11c6c8410167fd0ae53f151c2f917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafb90f891f1e14959d9ed45d7af1b09"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_8h.html#a3d8a0f559cd6fd14ab9e1d7a0b6d5a93">UART_LEN_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#afafb90f891f1e14959d9ed45d7af1b09">UART_LEN</a></td></tr>
<tr class="memdesc:afafb90f891f1e14959d9ed45d7af1b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART data length settings.  <a href="#afafb90f891f1e14959d9ed45d7af1b09">More...</a><br /></td></tr>
<tr class="separator:afafb90f891f1e14959d9ed45d7af1b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91040de76e05e47441f1112522bf69a6"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_8h.html#a354ada9bf4e549345820568ff9ad0ca7">UART_STOP_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a91040de76e05e47441f1112522bf69a6">UART_STOP</a></td></tr>
<tr class="memdesc:a91040de76e05e47441f1112522bf69a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART stop bit settings.  <a href="#a91040de76e05e47441f1112522bf69a6">More...</a><br /></td></tr>
<tr class="separator:a91040de76e05e47441f1112522bf69a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac030bbb8f2bbf15cc97cc8d965cc76ca"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="_u_a_r_t_8h.html#a6c5930832f38f32dacf8370542ba2f67">UART_PAR_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ac030bbb8f2bbf15cc97cc8d965cc76ca">UART_PAR</a></td></tr>
<tr class="memdesc:ac030bbb8f2bbf15cc97cc8d965cc76ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART parity type settings.  <a href="#ac030bbb8f2bbf15cc97cc8d965cc76ca">More...</a><br /></td></tr>
<tr class="separator:ac030bbb8f2bbf15cc97cc8d965cc76ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f3f34eb2c04f183e8e0d7ba54b4350"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t___params__t.html">UART_Params_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a80f3f34eb2c04f183e8e0d7ba54b4350">UART_Params</a></td></tr>
<tr class="memdesc:a80f3f34eb2c04f183e8e0d7ba54b4350"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Parameters.  <a href="#a80f3f34eb2c04f183e8e0d7ba54b4350">More...</a><br /></td></tr>
<tr class="separator:a80f3f34eb2c04f183e8e0d7ba54b4350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08ff15291bd6b21cb4e2eb1fce164a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae08ff15291bd6b21cb4e2eb1fce164a6"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ae08ff15291bd6b21cb4e2eb1fce164a6">UART_CloseFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ae08ff15291bd6b21cb4e2eb1fce164a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#ae08ff15291bd6b21cb4e2eb1fce164a6" title="A function pointer to a driver specific implementation of UART_CloseFxn(). ">UART_CloseFxn()</a>. <br /></td></tr>
<tr class="separator:ae08ff15291bd6b21cb4e2eb1fce164a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3a1deae1514eb9c268f34542fe27b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef3a1deae1514eb9c268f34542fe27b2"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aef3a1deae1514eb9c268f34542fe27b2">UART_ControlFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle, uint32_t cmd, void *arg)</td></tr>
<tr class="memdesc:aef3a1deae1514eb9c268f34542fe27b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#aef3a1deae1514eb9c268f34542fe27b2" title="A function pointer to a driver specific implementation of UART_ControlFxn(). ">UART_ControlFxn()</a>. <br /></td></tr>
<tr class="separator:aef3a1deae1514eb9c268f34542fe27b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e89df3065fffb47e7354067c14d1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b3e89df3065fffb47e7354067c14d1b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a2b3e89df3065fffb47e7354067c14d1b">UART_InitFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:a2b3e89df3065fffb47e7354067c14d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a2b3e89df3065fffb47e7354067c14d1b" title="A function pointer to a driver specific implementation of UART_InitFxn(). ">UART_InitFxn()</a>. <br /></td></tr>
<tr class="separator:a2b3e89df3065fffb47e7354067c14d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e21ac60f24eb9ce32286e21de713d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39e21ac60f24eb9ce32286e21de713d1"></a>
typedef <a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a39e21ac60f24eb9ce32286e21de713d1">UART_OpenFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle, <a class="el" href="_u_a_r_t_8h.html#a80f3f34eb2c04f183e8e0d7ba54b4350">UART_Params</a> *params)</td></tr>
<tr class="memdesc:a39e21ac60f24eb9ce32286e21de713d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a39e21ac60f24eb9ce32286e21de713d1" title="A function pointer to a driver specific implementation of UART_OpenFxn(). ">UART_OpenFxn()</a>. <br /></td></tr>
<tr class="separator:a39e21ac60f24eb9ce32286e21de713d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541cf3112195fb1fec2561ba7fc5cd01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a541cf3112195fb1fec2561ba7fc5cd01"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a541cf3112195fb1fec2561ba7fc5cd01">UART_ReadFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle, uint8_t *buffer, uint32_t size)</td></tr>
<tr class="memdesc:a541cf3112195fb1fec2561ba7fc5cd01"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a541cf3112195fb1fec2561ba7fc5cd01" title="A function pointer to a driver specific implementation of UART_ReadFxn(). ">UART_ReadFxn()</a>. <br /></td></tr>
<tr class="separator:a541cf3112195fb1fec2561ba7fc5cd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924d1707a32b68d1f59be214bd2cfc21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a924d1707a32b68d1f59be214bd2cfc21"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a924d1707a32b68d1f59be214bd2cfc21">UART_ReadPollingFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle, uint8_t *buffer, uint32_t size)</td></tr>
<tr class="memdesc:a924d1707a32b68d1f59be214bd2cfc21"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#a924d1707a32b68d1f59be214bd2cfc21" title="A function pointer to a driver specific implementation of UART_ReadPollingFxn(). ">UART_ReadPollingFxn()</a>. <br /></td></tr>
<tr class="separator:a924d1707a32b68d1f59be214bd2cfc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46296acc2c197a775d44458e1eca197"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa46296acc2c197a775d44458e1eca197"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aa46296acc2c197a775d44458e1eca197">UART_ReadCancelFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:aa46296acc2c197a775d44458e1eca197"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#aa46296acc2c197a775d44458e1eca197" title="A function pointer to a driver specific implementation of UART_ReadCancelFxn(). ">UART_ReadCancelFxn()</a>. <br /></td></tr>
<tr class="separator:aa46296acc2c197a775d44458e1eca197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58da6782cc5e22a082534a78b0a6ef4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af58da6782cc5e22a082534a78b0a6ef4"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#af58da6782cc5e22a082534a78b0a6ef4">UART_WriteFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle, uint8_t *buffer, uint32_t size)</td></tr>
<tr class="memdesc:af58da6782cc5e22a082534a78b0a6ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#af58da6782cc5e22a082534a78b0a6ef4" title="A function pointer to a driver specific implementation of UART_WriteFxn(). ">UART_WriteFxn()</a>. <br /></td></tr>
<tr class="separator:af58da6782cc5e22a082534a78b0a6ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa035c9a2af57a1189d2360b68f935da1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa035c9a2af57a1189d2360b68f935da1"></a>
typedef int32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aa035c9a2af57a1189d2360b68f935da1">UART_WritePollingFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle, uint8_t *buffer, uint32_t size)</td></tr>
<tr class="memdesc:aa035c9a2af57a1189d2360b68f935da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#aa035c9a2af57a1189d2360b68f935da1" title="A function pointer to a driver specific implementation of UART_WritePollingFxn(). ...">UART_WritePollingFxn()</a>. <br /></td></tr>
<tr class="separator:aa035c9a2af57a1189d2360b68f935da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a3d974279a2d161746dfbc8ca91774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5a3d974279a2d161746dfbc8ca91774"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#ac5a3d974279a2d161746dfbc8ca91774">UART_WriteCancelFxn</a>) (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ac5a3d974279a2d161746dfbc8ca91774"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function pointer to a driver specific implementation of <a class="el" href="_u_a_r_t_8h.html#ac5a3d974279a2d161746dfbc8ca91774" title="A function pointer to a driver specific implementation of UART_WriteCancelFxn(). ">UART_WriteCancelFxn()</a>. <br /></td></tr>
<tr class="separator:ac5a3d974279a2d161746dfbc8ca91774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba83a2b353c8e165702c4be3ec162680"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba83a2b353c8e165702c4be3ec162680"></a>
typedef struct <a class="el" href="struct_u_a_r_t___fxn_table__t.html">UART_FxnTable_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aba83a2b353c8e165702c4be3ec162680">UART_FxnTable</a></td></tr>
<tr class="memdesc:aba83a2b353c8e165702c4be3ec162680"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a UART function table that contains the required set of functions to control a specific UART driver implementation. <br /></td></tr>
<tr class="separator:aba83a2b353c8e165702c4be3ec162680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f93ca07abbc6c42cdeb455150f8295b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t___config__t.html">UART_Config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#a1f93ca07abbc6c42cdeb455150f8295b">UART_Config</a></td></tr>
<tr class="memdesc:a1f93ca07abbc6c42cdeb455150f8295b"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Global configuration.  <a href="#a1f93ca07abbc6c42cdeb455150f8295b">More...</a><br /></td></tr>
<tr class="separator:a1f93ca07abbc6c42cdeb455150f8295b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2974d56486405dbaa8dbafebf0250f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_u_a_r_t___stats__t.html">UART_Stats_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_u_a_r_t_8h.html#aab2974d56486405dbaa8dbafebf0250f">UART_Stats</a></td></tr>
<tr class="memdesc:aab2974d56486405dbaa8dbafebf0250f"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Statistics.  <a href="#aab2974d56486405dbaa8dbafebf0250f">More...</a><br /></td></tr>
<tr class="separator:aab2974d56486405dbaa8dbafebf0250f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6b49b65f3db709c408dc4db23a68895d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga6b49b65f3db709c408dc4db23a68895d">UART_close</a> (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga6b49b65f3db709c408dc4db23a68895d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to close a UART peripheral specified by the UART handle.  <a href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga6b49b65f3db709c408dc4db23a68895d">More...</a><br /></td></tr>
<tr class="separator:ga6b49b65f3db709c408dc4db23a68895d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89b171e42c715ca3c5a467a089f4eae2"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga89b171e42c715ca3c5a467a089f4eae2">UART_control</a> (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle, uint32_t cmd, void *arg)</td></tr>
<tr class="memdesc:ga89b171e42c715ca3c5a467a089f4eae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function performs implementation specific features on a given UART_Handle.  <a href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga89b171e42c715ca3c5a467a089f4eae2">More...</a><br /></td></tr>
<tr class="separator:ga89b171e42c715ca3c5a467a089f4eae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab60a36f7295d704926120d22f806dcd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gab60a36f7295d704926120d22f806dcd1">UART_init</a> (void)</td></tr>
<tr class="memdesc:gab60a36f7295d704926120d22f806dcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the UART module.  <a href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gab60a36f7295d704926120d22f806dcd1">More...</a><br /></td></tr>
<tr class="separator:gab60a36f7295d704926120d22f806dcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a5775cb1f4aae7cca153d4e1f6ad716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga8a5775cb1f4aae7cca153d4e1f6ad716">UART_open</a> (uint32_t index, <a class="el" href="_u_a_r_t_8h.html#a80f3f34eb2c04f183e8e0d7ba54b4350">UART_Params</a> *params)</td></tr>
<tr class="memdesc:ga8a5775cb1f4aae7cca153d4e1f6ad716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize a given UART peripheral.  <a href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga8a5775cb1f4aae7cca153d4e1f6ad716">More...</a><br /></td></tr>
<tr class="separator:ga8a5775cb1f4aae7cca153d4e1f6ad716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40e5c0823bb7ffd2e8fbf19f9f20b399"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga40e5c0823bb7ffd2e8fbf19f9f20b399">UART_Params_init</a> (<a class="el" href="_u_a_r_t_8h.html#a80f3f34eb2c04f183e8e0d7ba54b4350">UART_Params</a> *params)</td></tr>
<tr class="memdesc:ga40e5c0823bb7ffd2e8fbf19f9f20b399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize the UART_Params struct to its defaults.  <a href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga40e5c0823bb7ffd2e8fbf19f9f20b399">More...</a><br /></td></tr>
<tr class="separator:ga40e5c0823bb7ffd2e8fbf19f9f20b399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga969a1c67076d036e70146bff1ed42503"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga969a1c67076d036e70146bff1ed42503">UART_write</a> (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle, uint8_t *buffer, uint32_t size)</td></tr>
<tr class="memdesc:ga969a1c67076d036e70146bff1ed42503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a UART with interrupts enabled. Usage of this API is mutually exclusive with usage of <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga9d3b47576851e307338d707235bf7795" title="Function that writes data to a UART, polling the peripheral to wait until new data can be written...">UART_writePolling()</a>. In other words, for an opened UART peripheral, either <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga969a1c67076d036e70146bff1ed42503" title="Function that writes data to a UART with interrupts enabled. Usage of this API is mutually exclusive ...">UART_write()</a> or <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga9d3b47576851e307338d707235bf7795" title="Function that writes data to a UART, polling the peripheral to wait until new data can be written...">UART_writePolling()</a> may be used, but not both.  <a href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga969a1c67076d036e70146bff1ed42503">More...</a><br /></td></tr>
<tr class="separator:ga969a1c67076d036e70146bff1ed42503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d3b47576851e307338d707235bf7795"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga9d3b47576851e307338d707235bf7795">UART_writePolling</a> (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle, uint8_t *buffer, uint32_t size)</td></tr>
<tr class="memdesc:ga9d3b47576851e307338d707235bf7795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that writes data to a UART, polling the peripheral to wait until new data can be written. Usage of this API is mutually exclusive with usage of <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga969a1c67076d036e70146bff1ed42503" title="Function that writes data to a UART with interrupts enabled. Usage of this API is mutually exclusive ...">UART_write()</a>.  <a href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga9d3b47576851e307338d707235bf7795">More...</a><br /></td></tr>
<tr class="separator:ga9d3b47576851e307338d707235bf7795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0482cd0ab9ee7e802c8e785a5754d16d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga0482cd0ab9ee7e802c8e785a5754d16d">UART_writeCancel</a> (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga0482cd0ab9ee7e802c8e785a5754d16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga969a1c67076d036e70146bff1ed42503" title="Function that writes data to a UART with interrupts enabled. Usage of this API is mutually exclusive ...">UART_write()</a> function call.  <a href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga0482cd0ab9ee7e802c8e785a5754d16d">More...</a><br /></td></tr>
<tr class="separator:ga0482cd0ab9ee7e802c8e785a5754d16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25062276eca4dc0c12f00d8adf93b765"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga25062276eca4dc0c12f00d8adf93b765">UART_read</a> (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle, uint8_t *buffer, uint32_t size)</td></tr>
<tr class="memdesc:ga25062276eca4dc0c12f00d8adf93b765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads data from a UART with interrupt enabled. This API must be used mutually exclusive with <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga223055c1744586a53b2d5af96fa4c109" title="Function that reads data from a UART without interrupts. This API must be used mutually exclusive wit...">UART_readPolling()</a>.  <a href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga25062276eca4dc0c12f00d8adf93b765">More...</a><br /></td></tr>
<tr class="separator:ga25062276eca4dc0c12f00d8adf93b765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga223055c1744586a53b2d5af96fa4c109"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga223055c1744586a53b2d5af96fa4c109">UART_readPolling</a> (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle, uint8_t *buffer, uint32_t size)</td></tr>
<tr class="memdesc:ga223055c1744586a53b2d5af96fa4c109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that reads data from a UART without interrupts. This API must be used mutually exclusive with <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga25062276eca4dc0c12f00d8adf93b765" title="Function that reads data from a UART with interrupt enabled. This API must be used mutually exclusive...">UART_read()</a>.  <a href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga223055c1744586a53b2d5af96fa4c109">More...</a><br /></td></tr>
<tr class="separator:ga223055c1744586a53b2d5af96fa4c109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga51ed7e94d5b409ca1fcb2d65c5a25c3c">UART_readCancel</a> (<a class="el" href="_u_a_r_t_8h.html#a0456e19fcbce573bc31c1f501f8f1589">UART_Handle</a> handle)</td></tr>
<tr class="memdesc:ga51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that cancels a <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga25062276eca4dc0c12f00d8adf93b765" title="Function that reads data from a UART with interrupt enabled. This API must be used mutually exclusive...">UART_read()</a> function call. This function cancels a <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga25062276eca4dc0c12f00d8adf93b765" title="Function that reads data from a UART with interrupt enabled. This API must be used mutually exclusive...">UART_read()</a> operation for a UART peripheral.  <a href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga51ed7e94d5b409ca1fcb2d65c5a25c3c">More...</a><br /></td></tr>
<tr class="separator:ga51ed7e94d5b409ca1fcb2d65c5a25c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the header file for the UART driver which exposes the data structures and exported API which can be used by the applications to use the UART driver. </p>
<p>Copyright (c) 2015, Texas Instruments Incorporated All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ul>
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of Texas Instruments Incorporated nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a1f93ca07abbc6c42cdeb455150f8295b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t___config__t.html">UART_Config_t</a>  <a class="el" href="_u_a_r_t_8h.html#a1f93ca07abbc6c42cdeb455150f8295b">UART_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART Global configuration. </p>
<p>The UART_Config structure contains a set of pointers used to characterize the UART driver implementation.</p>
<p>This structure needs to be defined before calling <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gab60a36f7295d704926120d22f806dcd1" title="Function to initialize the UART module. ">UART_init()</a> and it must not be changed thereafter.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gab60a36f7295d704926120d22f806dcd1" title="Function to initialize the UART module. ">UART_init()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3df8ab128966ece5c06a82213a1a7aac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_8h.html#a337b3c4a16154975e56efd930999fcb8">UART_DataMode_e</a>  <a class="el" href="_u_a_r_t_8h.html#a3df8ab128966ece5c06a82213a1a7aac">UART_DataMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data mode settings. </p>
<p>This enumeration defines the data mode for read and write. In UART_DATA_TEXT mode the driver will examine the UART_ReturnMode value. </p>

</div>
</div>
<a class="anchor" id="ab8e11c6c8410167fd0ae53f151c2f917"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_8h.html#a300f4e491cd61d8e974598e670ff39e8">UART_Echo_e</a>  <a class="el" href="_u_a_r_t_8h.html#ab8e11c6c8410167fd0ae53f151c2f917">UART_Echo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART echo settings. </p>
<p>This enumeration defines if the driver will echo data when uses in UART_DATA_TEXT mode. This only applies to data received by the UART.</p>
<p>UART_ECHO_ON will echo back characters it received while in UART_DATA_TEXT mode. UART_ECHO_OFF will not echo back characters it received in UART_DATA_TEXT mode.</p>
<dl class="section pre"><dt>Precondition</dt><dd>UART driver must be used in UART_DATA_TEXT mode. </dd></dl>

</div>
</div>
<a class="anchor" id="afafb90f891f1e14959d9ed45d7af1b09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_8h.html#a3d8a0f559cd6fd14ab9e1d7a0b6d5a93">UART_LEN_e</a>  <a class="el" href="_u_a_r_t_8h.html#afafb90f891f1e14959d9ed45d7af1b09">UART_LEN</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data length settings. </p>
<p>This enumeration defines the UART data lengths. </p>

</div>
</div>
<a class="anchor" id="ac030bbb8f2bbf15cc97cc8d965cc76ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_8h.html#a6c5930832f38f32dacf8370542ba2f67">UART_PAR_e</a>  <a class="el" href="_u_a_r_t_8h.html#ac030bbb8f2bbf15cc97cc8d965cc76ca">UART_PAR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART parity type settings. </p>
<p>This enumeration defines the UART parity types. </p>

</div>
</div>
<a class="anchor" id="a80f3f34eb2c04f183e8e0d7ba54b4350"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t___params__t.html">UART_Params_t</a>  <a class="el" href="_u_a_r_t_8h.html#a80f3f34eb2c04f183e8e0d7ba54b4350">UART_Params</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART Parameters. </p>
<p>UART parameters are used to with the <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga8a5775cb1f4aae7cca153d4e1f6ad716" title="Function to initialize a given UART peripheral. ">UART_open()</a> call. Default values for these parameters are set using <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga40e5c0823bb7ffd2e8fbf19f9f20b399" title="Function to initialize the UART_Params struct to its defaults. ">UART_Params_init()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga40e5c0823bb7ffd2e8fbf19f9f20b399" title="Function to initialize the UART_Params struct to its defaults. ">UART_Params_init()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa180fc9d177be8a1fbf44fc33a2bc73c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_8h.html#af181cd5aa441af5f4e18ab6bc7212b94">UART_ReturnMode_e</a>  <a class="el" href="_u_a_r_t_8h.html#aa180fc9d177be8a1fbf44fc33a2bc73c">UART_ReturnMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART return mode settings. </p>
<p>This enumeration defines the return modes for <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga25062276eca4dc0c12f00d8adf93b765" title="Function that reads data from a UART with interrupt enabled. This API must be used mutually exclusive...">UART_read()</a> and <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga223055c1744586a53b2d5af96fa4c109" title="Function that reads data from a UART without interrupts. This API must be used mutually exclusive wit...">UART_readPolling()</a>. This mode only functions when in UART_DATA_TEXT mode.</p>
<p>UART_RETURN_FULL unblocks when the read buffer has been filled. UART_RETURN_NEWLINE unblocks or performs a callback whenever a newline character has been received.</p>
<table class="doxtable">
<tr>
<th>UART operation </th><th>UART_RETURN_FULL </th><th>UART_RETURN_NEWLINE  </th></tr>
<tr>
<td>UART_read </td><td>Returns when buffer is full </td><td>Returns when buffer is full or newline was read </td></tr>
<tr>
<td>UART_write </td><td>Sends data as is </td><td>Sends data with an additional newline at the end </td></tr>
</table>
<dl class="section pre"><dt>Precondition</dt><dd>UART driver must be used in UART_DATA_TEXT mode. </dd></dl>

</div>
</div>
<a class="anchor" id="aab2974d56486405dbaa8dbafebf0250f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_u_a_r_t___stats__t.html">UART_Stats_t</a> <a class="el" href="_u_a_r_t_8h.html#aab2974d56486405dbaa8dbafebf0250f">UART_Stats</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART Statistics. </p>
<p>This structure holds the statistics which are maintained by the UART driver instance and can be used for debugging purpose</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga89b171e42c715ca3c5a467a089f4eae2" title="Function performs implementation specific features on a given UART_Handle. ">UART_control()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a91040de76e05e47441f1112522bf69a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="_u_a_r_t_8h.html#a354ada9bf4e549345820568ff9ad0ca7">UART_STOP_e</a>  <a class="el" href="_u_a_r_t_8h.html#a91040de76e05e47441f1112522bf69a6">UART_STOP</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART stop bit settings. </p>
<p>This enumeration defines the UART stop bits. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a337b3c4a16154975e56efd930999fcb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#a337b3c4a16154975e56efd930999fcb8">UART_DataMode_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data mode settings. </p>
<p>This enumeration defines the data mode for read and write. In UART_DATA_TEXT mode the driver will examine the UART_ReturnMode value. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a337b3c4a16154975e56efd930999fcb8aaa8edcbf6c236b0d86491ea1e7c9e4d8"></a>UART_DATA_BINARY&#160;</td><td class="fielddoc">
<p>Data is not processed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a337b3c4a16154975e56efd930999fcb8a87fdfb7ca981eab7f56c51380fd7094e"></a>UART_DATA_TEXT&#160;</td><td class="fielddoc">
<p>Data is processed according to above </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a300f4e491cd61d8e974598e670ff39e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#a300f4e491cd61d8e974598e670ff39e8">UART_Echo_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART echo settings. </p>
<p>This enumeration defines if the driver will echo data when uses in UART_DATA_TEXT mode. This only applies to data received by the UART.</p>
<p>UART_ECHO_ON will echo back characters it received while in UART_DATA_TEXT mode. UART_ECHO_OFF will not echo back characters it received in UART_DATA_TEXT mode.</p>
<dl class="section pre"><dt>Precondition</dt><dd>UART driver must be used in UART_DATA_TEXT mode. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a300f4e491cd61d8e974598e670ff39e8a2b286f182793d4a71bdf99409b9600dd"></a>UART_ECHO_OFF&#160;</td><td class="fielddoc">
<p>Data is not echoed </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a300f4e491cd61d8e974598e670ff39e8a6c4d8a2d4e30c22cf9fa45cd1bf79306"></a>UART_ECHO_ON&#160;</td><td class="fielddoc">
<p>Data is echoed </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a3d8a0f559cd6fd14ab9e1d7a0b6d5a93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#a3d8a0f559cd6fd14ab9e1d7a0b6d5a93">UART_LEN_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART data length settings. </p>
<p>This enumeration defines the UART data lengths. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a3d8a0f559cd6fd14ab9e1d7a0b6d5a93a27d04dd1fa818f764eb9b8e849feb7ff"></a>UART_LEN_5&#160;</td><td class="fielddoc">
<p>Data length is 5 bits </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3d8a0f559cd6fd14ab9e1d7a0b6d5a93a5bfd5507335d394d826e560930ce2a12"></a>UART_LEN_6&#160;</td><td class="fielddoc">
<p>Data length is 6 bits </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3d8a0f559cd6fd14ab9e1d7a0b6d5a93a2ac8467047f55cc1954388bf94c72e35"></a>UART_LEN_7&#160;</td><td class="fielddoc">
<p>Data length is 7 bits </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3d8a0f559cd6fd14ab9e1d7a0b6d5a93a31abbaaeaa38a5c66fbe13bfc8ece221"></a>UART_LEN_8&#160;</td><td class="fielddoc">
<p>Data length is 8 bits </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a6c5930832f38f32dacf8370542ba2f67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#a6c5930832f38f32dacf8370542ba2f67">UART_PAR_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART parity type settings. </p>
<p>This enumeration defines the UART parity types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a6c5930832f38f32dacf8370542ba2f67a469955a283c95f261990ad07043d5d2d"></a>UART_PAR_NONE&#160;</td><td class="fielddoc">
<p>No parity </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6c5930832f38f32dacf8370542ba2f67a5405c8d842bffa2f76999eef9cee32c3"></a>UART_PAR_EVEN&#160;</td><td class="fielddoc">
<p>Parity bit is even </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6c5930832f38f32dacf8370542ba2f67a498f72ae68542763da3072d3e3af6603"></a>UART_PAR_ODD&#160;</td><td class="fielddoc">
<p>Parity bit is odd </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6c5930832f38f32dacf8370542ba2f67adfb9d17fa33753ea5550e757b323bd46"></a>UART_PAR_ZERO&#160;</td><td class="fielddoc">
<p>Parity bit is always zero </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6c5930832f38f32dacf8370542ba2f67a7ab50a9a14f4c614e875fbab74911afa"></a>UART_PAR_ONE&#160;</td><td class="fielddoc">
<p>Parity bit is always one </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="af181cd5aa441af5f4e18ab6bc7212b94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#af181cd5aa441af5f4e18ab6bc7212b94">UART_ReturnMode_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART return mode settings. </p>
<p>This enumeration defines the return modes for <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga25062276eca4dc0c12f00d8adf93b765" title="Function that reads data from a UART with interrupt enabled. This API must be used mutually exclusive...">UART_read()</a> and <a class="el" href="group___u_a_r_t___d_r_i_v_e_r___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga223055c1744586a53b2d5af96fa4c109" title="Function that reads data from a UART without interrupts. This API must be used mutually exclusive wit...">UART_readPolling()</a>. This mode only functions when in UART_DATA_TEXT mode.</p>
<p>UART_RETURN_FULL unblocks when the read buffer has been filled. UART_RETURN_NEWLINE unblocks or performs a callback whenever a newline character has been received.</p>
<table class="doxtable">
<tr>
<th>UART operation </th><th>UART_RETURN_FULL </th><th>UART_RETURN_NEWLINE  </th></tr>
<tr>
<td>UART_read </td><td>Returns when buffer is full </td><td>Returns when buffer is full or newline was read </td></tr>
<tr>
<td>UART_write </td><td>Sends data as is </td><td>Sends data with an additional newline at the end </td></tr>
</table>
<dl class="section pre"><dt>Precondition</dt><dd>UART driver must be used in UART_DATA_TEXT mode. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="af181cd5aa441af5f4e18ab6bc7212b94a50c07cbaf7518a0acd14137e801687e5"></a>UART_RETURN_FULL&#160;</td><td class="fielddoc">
<p>Unblock/callback when buffer is full. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af181cd5aa441af5f4e18ab6bc7212b94a3b8e419e0e12abf80b25f72d17745f76"></a>UART_RETURN_NEWLINE&#160;</td><td class="fielddoc">
<p>Unblock/callback when newline character is received. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a354ada9bf4e549345820568ff9ad0ca7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_u_a_r_t_8h.html#a354ada9bf4e549345820568ff9ad0ca7">UART_STOP_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART stop bit settings. </p>
<p>This enumeration defines the UART stop bits. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a354ada9bf4e549345820568ff9ad0ca7a9bfa599e95c5da9cfe5f964dab8a9c6c"></a>UART_STOP_ONE&#160;</td><td class="fielddoc">
<p>One stop bit </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a354ada9bf4e549345820568ff9ad0ca7a3f41137f3775e7d33fdb250471c0248e"></a>UART_STOP_TWO&#160;</td><td class="fielddoc">
<p>Two stop bits </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
